"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reauthenticate = reauthenticate;
exports.Authenticate = Authenticate;
var react_native_onyx_1 = require("react-native-onyx");
var CONFIG_1 = require("@src/CONFIG");
var CONST_1 = require("@src/CONST");
var ONYXKEYS_1 = require("@src/ONYXKEYS");
var Delegate_1 = require("./actions/Delegate");
var updateSessionAuthTokens_1 = require("./actions/Session/updateSessionAuthTokens");
var SignInRedirect_1 = require("./actions/SignInRedirect");
var ErrorUtils_1 = require("./ErrorUtils");
var Log_1 = require("./Log");
var Network_1 = require("./Network");
var NetworkStore_1 = require("./Network/NetworkStore");
var requireParameters_1 = require("./requireParameters");
var isAuthenticatingWithShortLivedToken = false;
react_native_onyx_1.default.connect({
    key: ONYXKEYS_1.default.SESSION,
    callback: function (value) {
        isAuthenticatingWithShortLivedToken = !!(value === null || value === void 0 ? void 0 : value.isAuthenticatingWithShortLivedToken);
    },
});
function Authenticate(parameters) {
    var commandName = 'Authenticate';
    try {
        (0, requireParameters_1.default)(['partnerName', 'partnerPassword', 'partnerUserID', 'partnerUserSecret'], parameters, commandName);
    }
    catch (error) {
        var errorMessage = error.message;
        Log_1.default.hmmm('Redirecting to Sign In because we failed to reauthenticate', {
            error: errorMessage,
        });
        (0, SignInRedirect_1.default)(errorMessage);
        return Promise.resolve();
    }
    return (0, Network_1.post)(commandName, {
        // When authenticating for the first time, we pass useExpensifyLogin as true so we check
        // for credentials for the expensify partnerID to let users Authenticate with their expensify user
        // and password.
        useExpensifyLogin: parameters.useExpensifyLogin,
        partnerName: parameters.partnerName,
        partnerPassword: parameters.partnerPassword,
        partnerUserID: parameters.partnerUserID,
        partnerUserSecret: parameters.partnerUserSecret,
        twoFactorAuthCode: parameters.twoFactorAuthCode,
        authToken: parameters.authToken,
        shouldRetry: false,
        // Force this request to be made because the network queue is paused when re-authentication is happening
        forceNetworkRequest: true,
        // Add email param so the first Authenticate request is logged on the server w/ this email
        email: parameters.email,
    });
}
/**
 * Reauthenticate using the stored credentials and redirect to the sign in page if unable to do so.
 * @param [command] command name for logging purposes
 * @return returns true if reauthentication was successful, false otherwise.
 */
function reauthenticate(command) {
    if (command === void 0) { command = ''; }
    Log_1.default.hmmm('Reauthenticate - Attempting re-authentication', {
        command: command,
    });
    // Prevent re-authentication if authentication with shortLiveToken is in progress
    if (isAuthenticatingWithShortLivedToken) {
        Log_1.default.hmmm('Reauthenticate - Authentication with shortLivedToken is in progress. Re-authentication aborted.', {
            command: command,
        });
        return Promise.resolve(false);
    }
    // Prevent any more requests from being processed while authentication happens
    (0, NetworkStore_1.setIsAuthenticating)(true);
    Log_1.default.hmmm('Reauthenticate - Waiting for credentials', {
        command: command,
    });
    return (0, NetworkStore_1.hasReadRequiredDataFromStorage)().then(function () {
        var credentials = (0, NetworkStore_1.getCredentials)();
        Log_1.default.hmmm('Reauthenticate - Starting authentication process', {
            command: command,
        });
        return Authenticate({
            useExpensifyLogin: false,
            partnerName: CONFIG_1.default.EXPENSIFY.PARTNER_NAME,
            partnerPassword: CONFIG_1.default.EXPENSIFY.PARTNER_PASSWORD,
            partnerUserID: credentials === null || credentials === void 0 ? void 0 : credentials.autoGeneratedLogin,
            partnerUserSecret: credentials === null || credentials === void 0 ? void 0 : credentials.autoGeneratedPassword,
        }).then(function (response) {
            var _a;
            if (!response) {
                return false;
            }
            Log_1.default.hmmm('Reauthenticate - Processing authentication result', {
                command: command,
            });
            if (response.jsonCode === CONST_1.default.JSON_CODE.UNABLE_TO_RETRY) {
                // When a fetch() fails due to a network issue and an error is thrown we won't log the user out. Most likely they
                // have a spotty connection and will need to retry reauthenticate when they come back online. Error so it can be handled by the retry mechanism.
                throw new Error('Unable to retry Authenticate request');
            }
            // If authentication fails and we are online then log the user out
            if (response.jsonCode !== 200) {
                var errorMessage = (0, ErrorUtils_1.getAuthenticateErrorMessage)(response);
                (0, NetworkStore_1.setIsAuthenticating)(false);
                Log_1.default.hmmm('Redirecting to Sign In because we failed to reauthenticate', {
                    command: command,
                    error: errorMessage,
                });
                (0, SignInRedirect_1.default)(errorMessage);
                return false;
            }
            // If we reauthenticate due to an expired delegate token, restore the delegate's original account.
            // This is because the credentials used to reauthenticate were for the delegate's original account, and not for the account they were connected as.
            if ((0, Delegate_1.isConnectedAsDelegate)()) {
                Log_1.default.info('Reauthenticate while connected as a delegate. Restoring original account.');
                (0, Delegate_1.restoreDelegateSession)(response);
                return true;
            }
            // Update authToken in Onyx and in our local variables so that API requests will use the new authToken
            (0, updateSessionAuthTokens_1.default)(response.authToken, response.encryptedAuthToken);
            // Note: It is important to manually set the authToken that is in the store here since any requests that are hooked into
            // reauthenticate .then() will immediate post and use the local authToken. Onyx updates subscribers lately so it is not
            // enough to do the updateSessionAuthTokens() call above.
            (0, NetworkStore_1.setAuthToken)((_a = response.authToken) !== null && _a !== void 0 ? _a : null);
            // The authentication process is finished so the network can be unpaused to continue processing requests
            (0, NetworkStore_1.setIsAuthenticating)(false);
            Log_1.default.hmmm('Reauthenticate - Re-authentication successful', {
                command: command,
            });
            return true;
        });
    });
}
