import _ from 'underscore';
import lodashGet from 'lodash/get';
import PropTypes from 'prop-types';
import React, {useCallback, useState, useEffect, useRef, useLayoutEffect, useMemo} from 'react';
import {AppState, Linking} from 'react-native';
import Onyx, {withOnyx} from 'react-native-onyx';
import Encryptify from 'react-native-encryptify';
import performance from 'react-native-performance';
import * as Report from './libs/actions/Report';
import BootSplash from './libs/BootSplash';
import * as ActiveClientManager from './libs/ActiveClientManager';
import ONYXKEYS from './ONYXKEYS';
import NavigationRoot from './libs/Navigation/NavigationRoot';
import migrateOnyx from './libs/migrateOnyx';
import PushNotification from './libs/Notification/PushNotification';
import UpdateAppModal from './components/UpdateAppModal';
import Visibility from './libs/Visibility';
import GrowlNotification from './components/GrowlNotification';
import * as Growl from './libs/Growl';
import StartupTimer from './libs/StartupTimer';
import Log from './libs/Log';
import ConfirmModal from './components/ConfirmModal';
import compose from './libs/compose';
import withLocalize, {withLocalizePropTypes} from './components/withLocalize';
import * as User from './libs/actions/User';
import NetworkConnection from './libs/NetworkConnection';
import Navigation from './libs/Navigation/Navigation';
import PopoverReportActionContextMenu from './pages/home/report/ContextMenu/PopoverReportActionContextMenu';
import * as ReportActionContextMenu from './pages/home/report/ContextMenu/ReportActionContextMenu';
import SplashScreenHider from './components/SplashScreenHider';
import AppleAuthWrapper from './components/SignInButtons/AppleAuthWrapper';
import EmojiPicker from './components/EmojiPicker/EmojiPicker';
import * as EmojiPickerAction from './libs/actions/EmojiPickerAction';
import * as DemoActions from './libs/actions/DemoActions';
import DeeplinkWrapper from './components/DeeplinkWrapper';
// import useEncryptify from './hooks/useEncryptify';

// This lib needs to be imported, but it has nothing to export since all it contains is an Onyx connection
// eslint-disable-next-line no-unused-vars
import UnreadIndicatorUpdater from './libs/UnreadIndicatorUpdater';
// eslint-disable-next-line no-unused-vars
import subscribePushNotification from './libs/Notification/PushNotification/subscribePushNotification';

// 255 characters string for testing the encryption lib
const ENCRYPTION_DATA =
    'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula eget dolor. Aenean massa. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Donec quam felis, ultricies nec, pellentesque eu, pretium quis,';
const ENCRYPTION_IV = 'Lorem ipsum dolor sit amet';

Onyx.registerLogger(({level, message}) => {
    if (level === 'alert') {
        Log.alert(message);
        console.error(message);
    } else {
        Log.info(message);
    }
});

const propTypes = {
    /* Onyx Props */

    /** Session info for the currently logged in user. */
    session: PropTypes.shape({
        /** Currently logged in user authToken */
        authToken: PropTypes.string,

        /** Currently logged in user accountID */
        accountID: PropTypes.number,
    }),

    /** Whether a new update is available and ready to install. */
    updateAvailable: PropTypes.bool,

    /** Tells us if the sidebar has rendered */
    isSidebarLoaded: PropTypes.bool,

    /** Information about a screen share call requested by a GuidesPlus agent */
    screenShareRequest: PropTypes.shape({
        /** Access token required to join a screen share room, generated by the backend */
        accessToken: PropTypes.string,

        /** Name of the screen share room to join */
        roomName: PropTypes.string,
    }),

    /** Whether the app is waiting for the server's response to determine if a room is public */
    isCheckingPublicRoom: PropTypes.bool,

    ...withLocalizePropTypes,
};

const defaultProps = {
    session: {
        authToken: null,
        accountID: null,
    },
    updateAvailable: false,
    isSidebarLoaded: false,
    screenShareRequest: null,
    isCheckingPublicRoom: true,
};

function Expensify(props) {
    const appStateChangeListener = useRef(null);
    const [isNavigationReady, setIsNavigationReady] = useState(false);
    const [isOnyxMigrated, setIsOnyxMigrated] = useState(false);
    const [isSplashHidden, setIsSplashHidden] = useState(false);
    const [hasAttemptedToOpenPublicRoom, setAttemptedToOpenPublicRoom] = useState(false);

    useEffect(() => {
        if (props.isCheckingPublicRoom) {
            return;
        }
        setAttemptedToOpenPublicRoom(true);
    }, [props.isCheckingPublicRoom]);

    const isAuthenticated = useMemo(() => Boolean(lodashGet(props.session, 'authToken', null)), [props.session]);
    const shouldInit = isNavigationReady && (!isAuthenticated || props.isSidebarLoaded) && hasAttemptedToOpenPublicRoom;
    const shouldHideSplash = shouldInit && !isSplashHidden;

    const initializeClient = () => {
        if (!Visibility.isVisible()) {
            return;
        }

        ActiveClientManager.init();
    };

    const setNavigationReady = useCallback(() => {
        setIsNavigationReady(true);

        // Navigate to any pending routes now that the NavigationContainer is ready
        Navigation.setIsNavigationReady();
    }, []);

    const onSplashHide = useCallback(() => {
        setIsSplashHidden(true);
    }, []);

    useLayoutEffect(() => {
        // Initialize this client as being an active client
        ActiveClientManager.init();

        // Used for the offline indicator appearing when someone is offline
        NetworkConnection.subscribeToNetInfo();
    }, []);

    useEffect(() => {
        setTimeout(() => {
            BootSplash.getVisibilityStatus().then((status) => {
                const appState = AppState.currentState;
                Log.info('[BootSplash] splash screen status', false, {appState, status});

                if (status === 'visible') {
                    const propsToLog = _.omit(props, ['children', 'session']);
                    propsToLog.isAuthenticated = isAuthenticated;
                    Log.alert('[BootSplash] splash screen is still visible', {propsToLog}, false);
                }
            });
        }, 30 * 1000);

        // This timer is set in the native layer when launching the app and we stop it here so we can measure how long
        // it took for the main app itself to load.
        StartupTimer.stop();

        // Run any Onyx schema migrations and then continue loading the main app
        migrateOnyx().then(() => {
            // In case of a crash that led to disconnection, we want to remove all the push notifications.
            if (!isAuthenticated) {
                PushNotification.clearNotifications();
            }

            setIsOnyxMigrated(true);
        });

        appStateChangeListener.current = AppState.addEventListener('change', initializeClient);

        // If the app is opened from a deep link, get the reportID (if exists) from the deep link and navigate to the chat report
        Linking.getInitialURL().then((url) => {
            DemoActions.runDemoByURL(url);
            Report.openReportFromDeepLink(url, isAuthenticated);
        });

        // Open chat report from a deep link (only mobile native)
        Linking.addEventListener('url', (state) => {
            DemoActions.runDemoByURL(state.url);
            Report.openReportFromDeepLink(state.url, isAuthenticated);
        });

        return () => {
            if (!appStateChangeListener.current) {
                return;
            }
            appStateChangeListener.current.remove();
        };
        // eslint-disable-next-line react-hooks/exhaustive-deps -- we don't want this effect to run again
    }, []);

    useEffect(() => {
        performance.mark('KEMGenKeys');
        const kemKeys = Encryptify.KEMGenKeys();
        performance.measure('KEMGenKeys', 'KEMGenKeys');

        // eslint-disable-next-line no-console
        console.log({kemKeys});

        performance.mark('KEMEncrypt');
        const {sharedSecret, cipherText} = Encryptify.KEMEncrypt(kemKeys.public);
        performance.measure('KEMEncrypt', 'KEMEncrypt');

        performance.mark('AESEncrypt');
        const encryptedData = Encryptify.AESEncrypt(ENCRYPTION_IV, sharedSecret, ENCRYPTION_DATA);
        performance.measure('AESEncrypt', 'AESEncrypt');

        // After encryption on the sender side, the message is sent to the receiver:
        // Only the encryptedData an the cipherText must be sent to the receiver
        // The receiver can then decrypt the cipherText with his private keys

        performance.mark('KEMDecrypt');
        const decryptedSharedSecret = Encryptify.KEMDecrypt(kemKeys.private, cipherText);
        performance.measure('KEMDecrypt', 'KEMDecrypt');

        performance.mark('AESDecrypt');
        const decryptedData = Encryptify.AESDecrypt(ENCRYPTION_IV, decryptedSharedSecret, encryptedData);
        performance.measure('AESDecrypt', 'AESDecrypt');

        const logString = `"${ENCRYPTION_DATA}"
got encrypted to:
${encryptedData}
and decrypted back to:
${decryptedData}

Success: ${ENCRYPTION_DATA === decryptedData}

Performance:

`;

        // eslint-disable-next-line no-console
        console.log(logString);
        // eslint-disable-next-line no-console
        console.log(performance.getEntriesByType('measure'));

        performance.clearMarks();
        performance.clearMeasures();

        for (let i = 0; i < 100; i++) {
            // eslint-disable-next-line no-bitwise
            const inputData = ENCRYPTION_DATA >> i;

            performance.mark('AESEncrypt under load');
            const encryptedDataIter = Encryptify.AESEncrypt(ENCRYPTION_IV, sharedSecret, inputData);
            performance.measure(`Iteration ${i}`, 'AESEncrypt under load');

            performance.mark('AESDecrypt under load');
            Encryptify.AESDecrypt(ENCRYPTION_IV, sharedSecret, encryptedDataIter);
            performance.measure(`Iteration ${i}`, 'AESDecrypt under load');
        }

        // eslint-disable-next-line no-console
        console.log('Under Load: (encrypting/decrypting 100 times)');
        // eslint-disable-next-line no-console
        console.log(performance.getEntriesByName('AESEncrypt under load'));
        // eslint-disable-next-line no-console
        console.log(performance.getEntriesByName('AESDecrypt under load'));
    }, []);

    // Display a blank page until the onyx migration completes
    if (!isOnyxMigrated) {
        return null;
    }

    return (
        <DeeplinkWrapper isAuthenticated={isAuthenticated}>
            {shouldInit && (
                <>
                    <GrowlNotification ref={Growl.growlRef} />
                    <PopoverReportActionContextMenu ref={ReportActionContextMenu.contextMenuRef} />
                    <EmojiPicker ref={EmojiPickerAction.emojiPickerRef} />
                    {/* We include the modal for showing a new update at the top level so the option is always present. */}
                    {props.updateAvailable ? <UpdateAppModal /> : null}
                    {props.screenShareRequest ? (
                        <ConfirmModal
                            title={props.translate('guides.screenShare')}
                            onConfirm={() => User.joinScreenShare(props.screenShareRequest.accessToken, props.screenShareRequest.roomName)}
                            onCancel={User.clearScreenShareRequest}
                            prompt={props.translate('guides.screenShareRequest')}
                            confirmText={props.translate('common.join')}
                            cancelText={props.translate('common.decline')}
                            isVisible
                        />
                    ) : null}
                </>
            )}

            <AppleAuthWrapper />
            {hasAttemptedToOpenPublicRoom && (
                <NavigationRoot
                    onReady={setNavigationReady}
                    authenticated={isAuthenticated}
                />
            )}

            {shouldHideSplash && <SplashScreenHider onHide={onSplashHide} />}
        </DeeplinkWrapper>
    );
}

Expensify.propTypes = propTypes;
Expensify.defaultProps = defaultProps;
export default compose(
    withLocalize,
    withOnyx({
        isCheckingPublicRoom: {
            key: ONYXKEYS.IS_CHECKING_PUBLIC_ROOM,
            initWithStoredValues: false,
        },
        session: {
            key: ONYXKEYS.SESSION,
        },
        updateAvailable: {
            key: ONYXKEYS.UPDATE_AVAILABLE,
            initWithStoredValues: false,
        },
        isSidebarLoaded: {
            key: ONYXKEYS.IS_SIDEBAR_LOADED,
        },
        screenShareRequest: {
            key: ONYXKEYS.SCREEN_SHARE_REQUEST,
        },
    }),
)(Expensify);
