{"version":3,"sources":["index.ts"],"names":["global","__QuickSQLiteProxy","QuickSQLiteModule","NativeModules","QuickSQLite","Error","nativeCallSyncHook","install","result","proxy","locks","enhanceQueryResult","rows","_array","length","item","idx","_open","open","dbName","location","queue","inProgress","_close","close","setImmediate","_execute","execute","query","params","_executeAsync","executeAsync","res","transaction","callback","tx","start","e","startNextTransaction","push","transactionAsync","shift","openDatabase","options","ok","fail","name","connection","sql","response","fn","attach","dbNameToAttach","alias","detach","delete","executeBatch","commands","executeBatchAsync","loadFile","loadFileAsync"],"mappings":"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","sourcesContent":["import { NativeModules } from 'react-native';\n\ndeclare global {\n  function nativeCallSyncHook(): unknown;\n  var __QuickSQLiteProxy: object | undefined;\n}\n\nif (global.__QuickSQLiteProxy == null) {\n  const QuickSQLiteModule = NativeModules.QuickSQLite;\n\n  if (QuickSQLiteModule == null) {\n    throw new Error(\n      'Base quick-sqlite module not found. Maybe try rebuilding the app.'\n    );\n  }\n\n  // Check if we are running on-device (JSI)\n  if (global.nativeCallSyncHook == null || QuickSQLiteModule.install == null) {\n    throw new Error(\n      'Failed to install react-native-quick-sqlite: React Native is not running on-device. QuickSQLite can only be used when synchronous method invocations (JSI) are possible. If you are using a remote debugger (e.g. Chrome), switch to an on-device debugger (e.g. Flipper) instead.'\n    );\n  }\n\n  // Call the synchronous blocking install() function\n  const result = QuickSQLiteModule.install();\n  if (result !== true) {\n    throw new Error(\n      `Failed to install react-native-quick-sqlite: The native QuickSQLite Module could not be installed! Looks like something went wrong when installing JSI bindings: ${result}`\n    );\n  }\n\n  // Check again if the constructor now exists. If not, throw an error.\n  if (global.__QuickSQLiteProxy == null) {\n    throw new Error(\n      'Failed to install react-native-quick-sqlite, the native initializer function does not exist. Are you trying to use QuickSQLite from different JS Runtimes?'\n    );\n  }\n}\n\nconst proxy = global.__QuickSQLiteProxy;\nexport const QuickSQLite = proxy as ISQLite;\n\n/**\n * Object returned by SQL Query executions {\n *  insertId: Represent the auto-generated row id if applicable\n *  rowsAffected: Number of affected rows if result of a update query\n *  message: if status === 1, here you will find error description\n *  rows: if status is undefined or 0 this object will contain the query results\n * }\n *\n * @interface QueryResult\n */\nexport interface QueryResult {\n  insertId?: number;\n  rowsAffected: number;\n  rows?: {\n    /** Raw array with all dataset */\n    _array: any[];\n    /** The lengh of the dataset */\n    length: number;\n    /** A convenience function to acess the index based the row object\n     * @param idx the row index\n     * @returns the row structure identified by column names\n     */\n    item: (idx: number) => any;\n  };\n  /**\n   * Query metadata, avaliable only for select query results\n   */\n  metadata?: ColumnMetadata[];\n}\n\n/**\n * Column metadata\n * Describes some information about columns fetched by the query\n */\nexport type ColumnMetadata = {\n  /** The name used for this column for this resultset */\n  columnName: string;\n  /** The declared column type for this column, when fetched directly from a table or a View resulting from a table column. \"UNKNOWN\" for dynamic values, like function returned ones. */\n  columnDeclaredType: string;\n  /**\n   * The index for this column for this resultset*/\n  columnIndex: number;\n};\n\n/**\n * Allows the execution of bulk of sql commands\n * inside a transaction\n * If a single query must be executed many times with different arguments, its preferred\n * to declare it a single time, and use an array of array parameters.\n */\ntype SQLBatchParams = [string] | [string, Array<any> | Array<Array<any>>];\n\n/**\n * status: 0 or undefined for correct execution, 1 for error\n * message: if status === 1, here you will find error description\n * rowsAffected: Number of affected rows if status == 0\n */\nexport interface BatchQueryResult {\n  rowsAffected?: number;\n}\n\n/**\n * Result of loading a file and executing every line as a SQL command\n * Similar to BatchQueryResult\n */\nexport interface FileLoadResult extends BatchQueryResult {\n  commands?: number;\n}\n\nexport interface Transaction {\n  execute: (query: string, params?: any[]) => QueryResult;\n}\n\nexport interface TransactionAsync {\n  execute: (query: string, params?: any[]) => QueryResult;\n  executeAsync: (\n    query: string,\n    params: any[] | undefined\n  ) => Promise<QueryResult>;\n}\n\nexport interface PendingTransaction {\n  start: () => void;\n}\n\ninterface ISQLite {\n  open: (dbName: string, location?: string) => void;\n  close: (dbName: string) => void;\n  delete: (dbName: string, location?: string) => void;\n  attach: (\n    mainDbName: string,\n    dbNameToAttach: string,\n    alias: string,\n    location?: string\n  ) => void;\n  detach: (mainDbName: string, alias: string) => void;\n  transactionAsync: (\n    dbName: string,\n    fn: (tx: TransactionAsync) => Promise<void>\n  ) => void;\n  transaction: (dbName: string, fn: (tx: Transaction) => void) => void;\n  execute: (dbName: string, query: string, params?: any[]) => QueryResult;\n  executeAsync: (\n    dbName: string,\n    query: string,\n    params?: any[]\n  ) => Promise<QueryResult>;\n  executeBatch: (\n    dbName: string,\n    commands: SQLBatchParams[]\n  ) => BatchQueryResult;\n  executeBatchAsync: (\n    dbName: string,\n    commands: SQLBatchParams[]\n  ) => Promise<BatchQueryResult>;\n  loadFile: (dbName: string, location: string) => FileLoadResult;\n  loadFileAsync: (dbName: string, location: string) => Promise<FileLoadResult>;\n}\n\n//   _______ _____            _   _  _____         _____ _______ _____ ____  _   _  _____\n//  |__   __|  __ \\     /\\   | \\ | |/ ____|  /\\   / ____|__   __|_   _/ __ \\| \\ | |/ ____|\n//     | |  | |__) |   /  \\  |  \\| | (___   /  \\ | |       | |    | || |  | |  \\| | (___\n//     | |  |  _  /   / /\\ \\ | . ` |\\___ \\ / /\\ \\| |       | |    | || |  | | . ` |\\___ \\\n//     | |  | | \\ \\  / ____ \\| |\\  |____) / ____ \\ |____   | |   _| || |__| | |\\  |____) |\n//     |_|  |_|  \\_\\/_/    \\_\\_| \\_|_____/_/    \\_\\_____|  |_|  |_____\\____/|_| \\_|_____/\n\nconst locks: Record<\n  string,\n  { queue: PendingTransaction[]; inProgress: boolean }\n> = {};\n\n// Enhance some host functions\n\n// Add 'item' function to result object to allow the sqlite-storage typeorm driver to work\nconst enhanceQueryResult = (result: QueryResult): void => {\n  // Add 'item' function to result object to allow the sqlite-storage typeorm driver to work\n  if (result.rows == null) {\n    result.rows = {\n      _array: [],\n      length: 0,\n      item: (idx: number) => result.rows._array[idx],\n    };\n  } else {\n    result.rows.item = (idx: number) => result.rows._array[idx];\n  }\n};\n\nconst _open = QuickSQLite.open;\nQuickSQLite.open = (dbName: string, location?: string) => {\n  _open(dbName, location);\n\n  locks[dbName] = {\n    queue: [],\n    inProgress: false,\n  };\n};\n\nconst _close = QuickSQLite.close;\nQuickSQLite.close = (dbName: string) => {\n  _close(dbName);\n  setImmediate(() => {\n    delete locks[dbName];\n  });\n};\n\nconst _execute = QuickSQLite.execute;\nQuickSQLite.execute = (\n  dbName: string,\n  query: string,\n  params: any[] | undefined\n): QueryResult => {\n  const result = _execute(dbName, query, params);\n  enhanceQueryResult(result);\n  return result;\n};\n\nconst _executeAsync = QuickSQLite.executeAsync;\nQuickSQLite.executeAsync = async (\n  dbName: string,\n  query: string,\n  params: any[] | undefined\n): Promise<QueryResult> => {\n  const res = await _executeAsync(dbName, query, params);\n  enhanceQueryResult(res);\n  return res;\n};\n\nQuickSQLite.transaction = (\n  dbName: string,\n  callback: (tx: Transaction) => void\n) => {\n  if (!locks[dbName]) {\n    throw Error(`No lock found on db: ${dbName}`);\n  }\n\n  // Local transaction context object implementation\n  const execute = (query: string, params?: any[]): QueryResult => {\n    return QuickSQLite.execute(dbName, query, params);\n  };\n\n  const tx: PendingTransaction = {\n    start: () => {\n      try {\n        QuickSQLite.execute(dbName, 'BEGIN TRANSACTION', null);\n        callback({ execute });\n\n        QuickSQLite.execute(dbName, 'COMMIT', null);\n      } catch (e: any) {\n        QuickSQLite.execute(dbName, 'ROLLBACK', null);\n        throw e;\n      } finally {\n        locks[dbName].inProgress = false;\n        startNextTransaction(dbName);\n      }\n    },\n  };\n\n  locks[dbName].queue.push(tx);\n  startNextTransaction(dbName);\n};\n\nQuickSQLite.transactionAsync = (\n  dbName: string,\n  callback: (tx: TransactionAsync) => Promise<void>\n) => {\n  if (!locks[dbName]) {\n    throw Error(`Quick SQLite Error: No lock found on db: ${dbName}`);\n  }\n\n  // Local transaction context object implementation\n  const execute = (query: string, params?: any[]): QueryResult => {\n    return QuickSQLite.execute(dbName, query, params);\n  };\n\n  const executeAsync = (query: string, params: any[] | undefined) => {\n    return QuickSQLite.executeAsync(dbName, query, params);\n  };\n\n  const tx: PendingTransaction = {\n    start: async () => {\n      try {\n        QuickSQLite.execute(dbName, 'BEGIN TRANSACTION', null);\n        await callback({\n          execute,\n          executeAsync,\n        });\n\n        QuickSQLite.execute(dbName, 'COMMIT', null);\n      } catch (e: any) {\n        QuickSQLite.execute(dbName, 'ROLLBACK', null);\n        throw e;\n      } finally {\n        locks[dbName].inProgress = false;\n        startNextTransaction(dbName);\n      }\n    },\n  };\n\n  locks[dbName].queue.push(tx);\n  startNextTransaction(dbName);\n};\n\nconst startNextTransaction = (dbName: string) => {\n  if (locks[dbName].inProgress) {\n    // Transaction is already in process bail out\n    return;\n  }\n\n  setImmediate(() => {\n    if (!locks[dbName]) {\n      throw Error(`Lock not found for db ${dbName}`);\n    }\n\n    if (locks[dbName].queue.length) {\n      locks[dbName].inProgress = true;\n      locks[dbName].queue.shift().start();\n    }\n  });\n};\n\n//   _________     _______  ______ ____  _____  __  __            _____ _____\n//  |__   __\\ \\   / /  __ \\|  ____/ __ \\|  __ \\|  \\/  |     /\\   |  __ \\_   _|\n//     | |   \\ \\_/ /| |__) | |__ | |  | | |__) | \\  / |    /  \\  | |__) || |\n//     | |    \\   / |  ___/|  __|| |  | |  _  /| |\\/| |   / /\\ \\ |  ___/ | |\n//     | |     | |  | |    | |___| |__| | | \\ \\| |  | |  / ____ \\| |    _| |_\n//     |_|     |_|  |_|    |______\\____/|_|  \\_\\_|  |_| /_/    \\_\\_|   |_____|\n\nexport interface TypeOrmDBConnection {\n  execute: (\n    sql: string,\n    args: any[],\n    ok: (res: QueryResult) => void,\n    fail: (msg: string) => void\n  ) => void;\n\n  close: (ok: (res: any) => void, fail: (msg: string) => void) => void;\n  attach: (\n    dbNameToAttach: string,\n    alias: string,\n    location: string | undefined,\n    callback: () => void\n  ) => void;\n  detach: (alias: string, callback: () => void) => void;\n  transaction: (fn: (tx: Transaction) => boolean) => void;\n}\n\n/**\n * DO NOT USE THIS! THIS IS MEANT FOR TYPEORM\n * If you are looking for a convenience wrapper use `connect`\n */\nexport const openDatabase = (\n  options: {\n    name: string;\n    location?: string;\n  },\n  ok: (db: TypeOrmDBConnection) => void,\n  fail: (msg: string) => void\n): TypeOrmDBConnection => {\n  try {\n    QuickSQLite.open(options.name, options.location);\n\n    const connection: TypeOrmDBConnection = {\n      execute: (\n        sql: string,\n        params: any[] | undefined,\n        ok: (res: QueryResult) => void,\n        fail: (msg: string) => void\n      ) => {\n        try {\n          let response = QuickSQLite.execute(options.name, sql, params);\n          enhanceQueryResult(response);\n          ok(response);\n        } catch (e) {\n          fail(e);\n        }\n      },\n      transaction: (fn: (tx: Transaction) => boolean): void => {\n        QuickSQLite.transaction(options.name, fn);\n      },\n      close: (ok: any, fail: any) => {\n        try {\n          QuickSQLite.close(options.name);\n          ok();\n        } catch (e) {\n          fail(e);\n        }\n      },\n      attach: (\n        dbNameToAttach: string,\n        alias: string,\n        location: string | undefined,\n        callback: () => void\n      ) => {\n        QuickSQLite.attach(options.name, dbNameToAttach, alias, location);\n\n        callback();\n      },\n      detach: (alias, callback: () => void) => {\n        QuickSQLite.detach(options.name, alias);\n        callback();\n      },\n    };\n\n    ok(connection);\n\n    return connection;\n  } catch (e) {\n    fail(e);\n  }\n};\n\nexport interface QuickSQLiteConnection {\n  close: () => void;\n  delete: () => void;\n  attach: (dbNameToAttach: string, alias: string, location?: string) => void;\n  detach: (alias: string) => void;\n  transactionAsync: (fn: (tx: TransactionAsync) => Promise<void>) => void;\n  transaction: (fn: (tx: Transaction) => boolean) => void;\n  execute: (query: string, params?: any[]) => QueryResult;\n  executeAsync: (query: string, params?: any[]) => Promise<QueryResult>;\n  executeBatch: (commands: SQLBatchParams[]) => BatchQueryResult;\n  executeBatchAsync: (commands: SQLBatchParams[]) => Promise<BatchQueryResult>;\n  loadFile: (location: string) => FileLoadResult;\n  loadFileAsync: (location: string) => Promise<FileLoadResult>;\n}\n\nexport const open = (options: {\n  name: string;\n  location?: string;\n}): QuickSQLiteConnection => {\n  QuickSQLite.open(options.name, options.location);\n\n  return {\n    close: () => QuickSQLite.close(options.name),\n    delete: () => QuickSQLite.delete(options.name, options.location),\n    attach: (dbNameToAttach: string, alias: string, location?: string) =>\n      QuickSQLite.attach(options.name, dbNameToAttach, alias, location),\n    detach: (alias: string) => QuickSQLite.detach(options.name, alias),\n    transactionAsync: (fn: (tx: TransactionAsync) => Promise<void>) =>\n      QuickSQLite.transactionAsync(options.name, fn),\n    transaction: (fn: (tx: Transaction) => void) =>\n      QuickSQLite.transaction(options.name, fn),\n    execute: (query: string, params: any[] | undefined): QueryResult =>\n      QuickSQLite.execute(options.name, query, params),\n    executeAsync: (\n      query: string,\n      params: any[] | undefined\n    ): Promise<QueryResult> =>\n      QuickSQLite.executeAsync(options.name, query, params),\n    executeBatch: (commands: SQLBatchParams[]) =>\n      QuickSQLite.executeBatch(options.name, commands),\n    executeBatchAsync: (commands: SQLBatchParams[]) =>\n      QuickSQLite.executeBatchAsync(options.name, commands),\n    loadFile: (location: string) =>\n      QuickSQLite.loadFile(options.name, location),\n    loadFileAsync: (location: string) =>\n      QuickSQLite.loadFileAsync(options.name, location)\n  };\n};\n"]}