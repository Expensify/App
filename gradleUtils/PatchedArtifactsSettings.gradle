import groovy.json.JsonSlurper
import java.util.concurrent.TimeUnit

apply from: "ExpensiLog.gradle"

class PatchedArtifactsConfig {
    String version = null
    String packageName = null
    Boolean buildFromSource = true
}

def patchedArtifacts = settings.getExtensions().create('patchedArtifacts', PatchedArtifactsConfig)

def warnIfNotConfigured(reason) {
    ExpensiLog.warn("$reason")
    ExpensiLog.warn("For setup instructions, refer to: https://github.com/Expensify/App?tab=readme-ov-file#enabling-prebuilt-react-native-artifacts-on-android")
}

def getNewDotRootDir() {
    return "${rootDir}/${hasProperty('newDotRoot') ? getProperty('newDotRoot') : "/.."}"
}

def runCommand(command) {
    def process = command.execute()
    process.waitFor(10, TimeUnit.SECONDS)
    return [output: process.in.text?.trim(), exitCode: process.exitValue()]
}


def getReactNativeVersion() {
    def packageJsonPath = "${getNewDotRootDir()}/package.json"
    def packageJson = file(packageJsonPath)
    return new JsonSlurper().parse(packageJson).dependencies.'react-native'
}

def getArtifactsCandidates(packageName) {
    def mavenMetadata= new XmlSlurper().parse(
        new URL("https://example.com/com/expensify/${packageName}/react-android/maven-metadata.xml").openConnection().with {
            getInputStream()
        }
    )

    def reactNativeVersion = getReactNativeVersion()
    return mavenMetadata.versioning.versions.version.findAll { it.text().startsWith(reactNativeVersion) }
}

def getPomFile(version, packageName) {
    return new XmlSlurper().parse(
        new URL("https://example.com/com/expensify/${packageName}/react-android/${version}/react-android-${version}.pom").openConnection().with {
            getInputStream()
        }
    )
}

def getLocalPatchesHash() {
    def newDotRootDir = getNewDotRootDir()
    def computePatchesScript = "${getNewDotRootDir()}/scripts/compute-patches-hash.sh"
    def arguments = hasProperty('newDotRoot') ? ["${newDotRootDir}/patches", "${newDotRootDir}/Mobile-Expensify/patches"] : ["${newDotRootDir}/patches"]
    def localPatchesHash = runCommand([computePatchesScript] + arguments).output.trim()

    return localPatchesHash
}

def findMatchingArtifactsVersion(packageName) {
    try {
        def localPatchesHash = getLocalPatchesHash()
        def candidates = getArtifactsCandidates(packageName)
        ExpensiLog.lifecycle("Candidates: ${candidates}")
        for (candidate in candidates) {
            def patchesHashFromPomFile = getPomFile(candidate, packageName).properties.patchesHash.text().trim()
            ExpensiLog.lifecycle("Patches hash from pom file: ${patchesHashFromPomFile}")
            if (patchesHashFromPomFile == localPatchesHash) {
                return candidate
            }
        }
    } catch (Exception e) {
        ExpensiLog.error("Failed to find matching artifacts version for ${packageName}. Reason: $e")
        return null
    }
}

settings.extensions.configure(PatchedArtifactsConfig) { config ->
    ExpensiLog.setPrefix("PatchedArtifacts")
    config.buildFromSource = getProperty('patchedArtifacts.forceBuildFromSource') == 'true'
    if(config.buildFromSource) {
        ExpensiLog.lifecycle("Forcing build from source.")
        return
    }

    config.packageName = getProperty('patchedArtifacts.packageName')
    config.version = findMatchingArtifactsVersion(config.packageName)

    if(config.version == null || config.packageName == null) {
        config.buildFromSource = true
        ExpensiLog.lifecycle("No matching artifacts version found for ${config.packageName}. Building react-native from source.")
    }
    else {
        config.buildFromSource = false
        ExpensiLog.lifecycle("Using patched react-native artifacts: ${config.packageName}:${config.version}")
    }
}
