diff --git a/node_modules/@expensify/react-native-live-markdown/lib/module/parseExpensiMark.js b/node_modules/@expensify/react-native-live-markdown/lib/module/parseExpensiMark.js
index f492c22..3c3712e 100644
--- a/node_modules/@expensify/react-native-live-markdown/lib/module/parseExpensiMark.js
+++ b/node_modules/@expensify/react-native-live-markdown/lib/module/parseExpensiMark.js
@@ -1,249 +1,272 @@
 'worklet';
 
-import { Platform } from 'react-native';
-import { ExpensiMark } from 'expensify-common';
-import { unescapeText } from 'expensify-common/dist/utils';
-import { decode } from 'html-entities';
-import { groupRanges, sortRanges, splitRangesOnEmojis } from './rangeUtils';
+import {ExpensiMark} from 'expensify-common';
+import {unescapeText} from 'expensify-common/dist/utils';
+import {decode} from 'html-entities';
+import {Platform} from 'react-native';
+import {groupRanges, sortRanges, splitRangesOnEmojis} from './rangeUtils';
+
 function isWeb() {
-  return Platform.OS === 'web';
+    return Platform.OS === 'web';
 }
 function isJest() {
-  return !!global.process.env.JEST_WORKER_ID;
+    return !!global.process.env.JEST_WORKER_ID;
 }
 
 // eslint-disable-next-line no-underscore-dangle
 if (__DEV__ && !isWeb() && !isJest() && decode.__workletHash === undefined) {
-  throw new Error("[react-native-live-markdown] `parseExpensiMark` requires `html-entities` package to be workletized. Please add `'worklet';` directive at the top of `node_modules/html-entities/lib/index.js` using patch-package.");
+    throw new Error(
+        "[react-native-live-markdown] `parseExpensiMark` requires `html-entities` package to be workletized. Please add `'worklet';` directive at the top of `node_modules/html-entities/lib/index.js` using patch-package.",
+    );
 }
 const MAX_PARSABLE_LENGTH = 4000;
 function parseMarkdownToHTML(markdown) {
-  const parser = new ExpensiMark();
-  const html = parser.replace(markdown, {
-    shouldKeepRawInput: true
-  });
-  return html;
+    const parser = new ExpensiMark();
+    const html = parser.replace(markdown, {
+        shouldKeepRawInput: true,
+    });
+
+    return html;
 }
 function parseHTMLToTokens(html) {
-  const tokens = [];
-  let left = 0;
-  // eslint-disable-next-line no-constant-condition
-  while (true) {
-    const open = html.indexOf('<', left);
-    if (open === -1) {
-      if (left < html.length) {
-        tokens.push(['TEXT', html.substring(left)]);
-      }
-      break;
-    }
-    if (open !== left) {
-      tokens.push(['TEXT', html.substring(left, open)]);
-    }
-    const close = html.indexOf('>', open);
-    if (close === -1) {
-      throw new Error('[react-native-live-markdown] Error in function parseHTMLToTokens: Invalid HTML: no matching ">"');
+    const tokens = [];
+    let left = 0;
+    // eslint-disable-next-line no-constant-condition
+    while (true) {
+        const open = html.indexOf('<', left);
+        if (open === -1) {
+            if (left < html.length) {
+                tokens.push(['TEXT', html.substring(left)]);
+            }
+            break;
+        }
+        if (open !== left) {
+            tokens.push(['TEXT', html.substring(left, open)]);
+        }
+        const close = html.indexOf('>', open);
+        if (close === -1) {
+            throw new Error('[react-native-live-markdown] Error in function parseHTMLToTokens: Invalid HTML: no matching ">"');
+        }
+        tokens.push(['HTML', html.substring(open, close + 1)]);
+        left = close + 1;
     }
-    tokens.push(['HTML', html.substring(open, close + 1)]);
-    left = close + 1;
-  }
-  return tokens;
+    return tokens;
 }
 function parseTokensToTree(tokens) {
-  const stack = [{
-    tag: '<>',
-    children: []
-  }];
-  tokens.forEach(([type, payload]) => {
-    if (type === 'TEXT') {
-      const text = unescapeText(payload);
-      const top = stack[stack.length - 1];
-      top.children.push(text);
-    } else if (type === 'HTML') {
-      if (payload.startsWith('</')) {
-        // closing tag
-        const child = stack.pop();
-        const top = stack[stack.length - 1];
-        top.children.push(child);
-      } else if (payload.endsWith('/>')) {
-        // self-closing tag
-        const top = stack[stack.length - 1];
-        top.children.push({
-          tag: payload,
-          children: []
-        });
-      } else {
-        // opening tag
-        stack.push({
-          tag: payload,
-          children: []
-        });
-      }
-    } else {
-      throw new Error(`[react-native-live-markdown] Error in function parseTokensToTree: Unknown token type: ${type}. Expected 'TEXT' or 'HTML'. Please ensure tokens only contain these types.`);
+    const stack = [
+        {
+            tag: '<>',
+            children: [],
+        },
+    ];
+    tokens.forEach(([type, payload]) => {
+        if (type === 'TEXT') {
+            const text = unescapeText(payload);
+            const top = stack[stack.length - 1];
+            top.children.push(text);
+        } else if (type === 'HTML') {
+            if (payload.startsWith('</')) {
+                // closing tag
+                const child = stack.pop();
+                const top = stack[stack.length - 1];
+                top.children.push(child);
+            } else if (payload.endsWith('/>')) {
+                // self-closing tag
+                const top = stack[stack.length - 1];
+                top.children.push({
+                    tag: payload,
+                    children: [],
+                });
+            } else {
+                // opening tag
+                stack.push({
+                    tag: payload,
+                    children: [],
+                });
+            }
+        } else {
+            throw new Error(
+                `[react-native-live-markdown] Error in function parseTokensToTree: Unknown token type: ${type}. Expected 'TEXT' or 'HTML'. Please ensure tokens only contain these types.`,
+            );
+        }
+    });
+    if (stack.length !== 1) {
+        const unclosedTags =
+            stack.length > 0
+                ? stack
+                      .slice(1)
+                      .map((item) => item.tag)
+                      .join(', ')
+                : '';
+        throw new Error(
+            `[react-native-live-markdown] Invalid HTML structure: the following tags are not properly closed: ${unclosedTags}. Ensure each opening tag has a corresponding closing tag.`,
+        );
     }
-  });
-  if (stack.length !== 1) {
-    const unclosedTags = stack.length > 0 ? stack.slice(1).map(item => item.tag).join(', ') : '';
-    throw new Error(`[react-native-live-markdown] Invalid HTML structure: the following tags are not properly closed: ${unclosedTags}. Ensure each opening tag has a corresponding closing tag.`);
-  }
-  return stack[0];
+    return stack[0];
 }
 function parseTreeToTextAndRanges(tree) {
-  let text = '';
-  function processChildren(node) {
-    if (typeof node === 'string') {
-      text += node;
-    } else {
-      node.children.forEach(dfs);
-    }
-  }
-  function appendSyntax(syntax) {
-    addChildrenWithStyle(syntax, 'syntax');
-  }
-  function addChildrenWithStyle(node, type) {
-    const start = text.length;
-    processChildren(node);
-    const end = text.length;
-    ranges.push({
-      type,
-      start,
-      length: end - start
-    });
-  }
-  const ranges = [];
-  function dfs(node) {
-    if (typeof node === 'string') {
-      text += node;
-    } else {
-      // eslint-disable-next-line no-lonely-if
-      if (node.tag === '<>') {
-        processChildren(node);
-      } else if (node.tag === '<strong>') {
-        appendSyntax('*');
-        addChildrenWithStyle(node, 'bold');
-        appendSyntax('*');
-      } else if (node.tag === '<em>') {
-        appendSyntax('_');
-        addChildrenWithStyle(node, 'italic');
-        appendSyntax('_');
-      } else if (node.tag === '<del>') {
-        appendSyntax('~');
-        addChildrenWithStyle(node, 'strikethrough');
-        appendSyntax('~');
-      } else if (node.tag === '<emoji>') {
-        addChildrenWithStyle(node, 'emoji');
-      } else if (node.tag === '<code>') {
-        appendSyntax('`');
-        addChildrenWithStyle(node, 'code');
-        appendSyntax('`');
-      } else if (node.tag === '<mention-here>') {
-        addChildrenWithStyle(node, 'mention-here');
-      } else if (node.tag === '<mention-user>') {
-        addChildrenWithStyle(node, 'mention-user');
-      } else if (node.tag === '<mention-short>') {
-        addChildrenWithStyle(node, 'mention-short');
-      } else if (node.tag === '<mention-report>') {
-        addChildrenWithStyle(node, 'mention-report');
-      } else if (node.tag === '<blockquote>') {
-        appendSyntax('>');
-        addChildrenWithStyle(node, 'blockquote');
-        // compensate for "> " at the beginning
-        if (ranges.length > 0) {
-          const curr = ranges[ranges.length - 1];
-          curr.start -= 1;
-          curr.length += 1;
-        }
-      } else if (node.tag === '<h1>') {
-        appendSyntax('# ');
-        addChildrenWithStyle(node, 'h1');
-      } else if (node.tag === '<br />') {
-        text += '\n';
-      } else if (node.tag.startsWith('<pre')) {
-        appendSyntax('```');
-        const content = node.children.join('');
-        addChildrenWithStyle(content, 'pre');
-        appendSyntax('```');
-      } else if (node.tag.startsWith('<a href="')) {
-        const rawHref = node.tag.match(/href="([^"]*)"/)[1]; // always present
-        const href = unescapeText(rawHref);
-        const isLabeledLink = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
-        const dataRawHref = node.tag.match(/data-raw-href="([^"]*)"/);
-        const matchString = dataRawHref ? unescapeText(dataRawHref[1]) : href;
-        if (!isLabeledLink && node.children.length === 1 && typeof node.children[0] === 'string' && (node.children[0] === matchString || `mailto:${node.children[0]}` === href)) {
-          addChildrenWithStyle(node.children[0], 'link');
+    let text = '';
+    function processChildren(node) {
+        if (typeof node === 'string') {
+            text += node;
         } else {
-          appendSyntax('[');
-          processChildren(node);
-          appendSyntax('](');
-          addChildrenWithStyle(matchString, 'link');
-          appendSyntax(')');
+            node.children.forEach(dfs);
         }
-      } else if (node.tag.startsWith('<img src="')) {
-        const src = node.tag.match(/src="([^"]*)"/)[1]; // always present
-        const alt = node.tag.match(/alt="([^"]*)"/);
-        const hasAlt = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
-        const rawLink = node.tag.match(/data-raw-href="([^"]*)"/);
-        const linkString = rawLink ? unescapeText(rawLink[1]) : src;
+    }
+    function appendSyntax(syntax) {
+        addChildrenWithStyle(syntax, 'syntax');
+    }
+    function addChildrenWithStyle(node, type) {
         const start = text.length;
-        const length = 3 + (hasAlt ? 2 + unescapeText((alt === null || alt === void 0 ? void 0 : alt[1]) || '').length : 0) + linkString.length;
+        processChildren(node);
+        const end = text.length;
         ranges.push({
-          type: 'inline-image',
-          start,
-          length
+            type,
+            start,
+            length: end - start,
         });
-        appendSyntax('!');
-        if (hasAlt) {
-          appendSyntax('[');
-          processChildren(unescapeText((alt === null || alt === void 0 ? void 0 : alt[1]) || ''));
-          appendSyntax(']');
-        }
-        appendSyntax('(');
-        addChildrenWithStyle(linkString, 'link');
-        appendSyntax(')');
-      } else if (node.tag.startsWith('<video data-expensify-source="')) {
-        const src = node.tag.match(/data-expensify-source="([^"]*)"/)[1]; // always present
-        const rawLink = node.tag.match(/data-raw-href="([^"]*)"/);
-        const hasAlt = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
-        const linkString = rawLink ? unescapeText(rawLink[1]) : src;
-        appendSyntax('!');
-        if (hasAlt) {
-          appendSyntax('[');
-          node.children.forEach(child => processChildren(child));
-          appendSyntax(']');
+    }
+    const ranges = [];
+    function dfs(node) {
+        if (typeof node === 'string') {
+            text += node;
+        } else {
+            // eslint-disable-next-line no-lonely-if
+            if (node.tag === '<>') {
+                processChildren(node);
+            } else if (node.tag === '<strong>') {
+                appendSyntax('*');
+                addChildrenWithStyle(node, 'bold');
+                appendSyntax('*');
+            } else if (node.tag === '<em>') {
+                appendSyntax('_');
+                addChildrenWithStyle(node, 'italic');
+                appendSyntax('_');
+            } else if (node.tag === '<del>') {
+                appendSyntax('~');
+                addChildrenWithStyle(node, 'strikethrough');
+                appendSyntax('~');
+            } else if (node.tag === '<emoji>') {
+                addChildrenWithStyle(node, 'emoji');
+            } else if (node.tag === '<code>') {
+                appendSyntax('`');
+                addChildrenWithStyle(node, 'code');
+                appendSyntax('`');
+            } else if (node.tag === '<mention-here>') {
+                addChildrenWithStyle(node, 'mention-here');
+            } else if (node.tag === '<mention-user>') {
+                addChildrenWithStyle(node, 'mention-user');
+            } else if (node.tag === '<mention-short>') {
+                addChildrenWithStyle(node, 'mention-short');
+            } else if (node.tag === '<command>') {
+                addChildrenWithStyle(node, 'command');
+            } else if (node.tag === '<mention-report>') {
+                addChildrenWithStyle(node, 'mention-report');
+            } else if (node.tag === '<blockquote>') {
+                appendSyntax('>');
+                addChildrenWithStyle(node, 'blockquote');
+                // compensate for "> " at the beginning
+                if (ranges.length > 0) {
+                    const curr = ranges[ranges.length - 1];
+                    curr.start -= 1;
+                    curr.length += 1;
+                }
+            } else if (node.tag === '<h1>') {
+                appendSyntax('# ');
+                addChildrenWithStyle(node, 'h1');
+            } else if (node.tag === '<br />') {
+                text += '\n';
+            } else if (node.tag.startsWith('<pre')) {
+                appendSyntax('```');
+                const content = node.children.join('');
+                addChildrenWithStyle(content, 'pre');
+                appendSyntax('```');
+            } else if (node.tag.startsWith('<a href="')) {
+                const rawHref = node.tag.match(/href="([^"]*)"/)[1]; // always present
+                const href = unescapeText(rawHref);
+                const isLabeledLink = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
+                const dataRawHref = node.tag.match(/data-raw-href="([^"]*)"/);
+                const matchString = dataRawHref ? unescapeText(dataRawHref[1]) : href;
+                if (!isLabeledLink && node.children.length === 1 && typeof node.children[0] === 'string' && (node.children[0] === matchString || `mailto:${node.children[0]}` === href)) {
+                    addChildrenWithStyle(node.children[0], 'link');
+                } else {
+                    appendSyntax('[');
+                    processChildren(node);
+                    appendSyntax('](');
+                    addChildrenWithStyle(matchString, 'link');
+                    appendSyntax(')');
+                }
+            } else if (node.tag.startsWith('<img src="')) {
+                const src = node.tag.match(/src="([^"]*)"/)[1]; // always present
+                const alt = node.tag.match(/alt="([^"]*)"/);
+                const hasAlt = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
+                const rawLink = node.tag.match(/data-raw-href="([^"]*)"/);
+                const linkString = rawLink ? unescapeText(rawLink[1]) : src;
+                const start = text.length;
+                const length = 3 + (hasAlt ? 2 + unescapeText((alt === null || alt === void 0 ? void 0 : alt[1]) || '').length : 0) + linkString.length;
+                ranges.push({
+                    type: 'inline-image',
+                    start,
+                    length,
+                });
+                appendSyntax('!');
+                if (hasAlt) {
+                    appendSyntax('[');
+                    processChildren(unescapeText((alt === null || alt === void 0 ? void 0 : alt[1]) || ''));
+                    appendSyntax(']');
+                }
+                appendSyntax('(');
+                addChildrenWithStyle(linkString, 'link');
+                appendSyntax(')');
+            } else if (node.tag.startsWith('<video data-expensify-source="')) {
+                const src = node.tag.match(/data-expensify-source="([^"]*)"/)[1]; // always present
+                const rawLink = node.tag.match(/data-raw-href="([^"]*)"/);
+                const hasAlt = node.tag.match(/data-link-variant="([^"]*)"/)[1] === 'labeled';
+                const linkString = rawLink ? unescapeText(rawLink[1]) : src;
+                appendSyntax('!');
+                if (hasAlt) {
+                    appendSyntax('[');
+                    node.children.forEach((child) => processChildren(child));
+                    appendSyntax(']');
+                }
+                appendSyntax('(');
+                addChildrenWithStyle(linkString, 'link');
+                appendSyntax(')');
+            } else {
+                throw new Error(`[react-native-live-markdown] Error in function parseTreeToTextAndRanges: Unknown tag '${node.tag}'. This tag is not supported in this function's logic.`);
+            }
         }
-        appendSyntax('(');
-        addChildrenWithStyle(linkString, 'link');
-        appendSyntax(')');
-      } else {
-        throw new Error(`[react-native-live-markdown] Error in function parseTreeToTextAndRanges: Unknown tag '${node.tag}'. This tag is not supported in this function's logic.`);
-      }
     }
-  }
-  dfs(tree);
-  return [text, ranges];
+    dfs(tree);
+    return [text, ranges];
 }
 const isAndroid = Platform.OS === 'android';
 function parseExpensiMark(markdown) {
-  if (markdown.length > MAX_PARSABLE_LENGTH) {
-    return [];
-  }
-  const html = parseMarkdownToHTML(markdown);
-  const tokens = parseHTMLToTokens(html);
-  const tree = parseTokensToTree(tokens);
-  const [text, ranges] = parseTreeToTextAndRanges(tree);
-  if (text !== markdown) {
-    console.error(`[react-native-live-markdown] Parsing error: the processed text does not match the original Markdown input. This may be caused by incorrect parsing functions or invalid input Markdown.\nProcessed input: '${JSON.stringify(text)}'\nOriginal input: '${JSON.stringify(markdown)}'`);
-    return [];
-  }
-  let markdownRanges = sortRanges(ranges);
-  if (isAndroid) {
-    // Blocks applying italic and strikethrough styles to emojis on Android
-    // TODO: Remove this condition when splitting emojis inside the inline code block will be fixed on the web
-    markdownRanges = splitRangesOnEmojis(markdownRanges, 'italic');
-    markdownRanges = splitRangesOnEmojis(markdownRanges, 'strikethrough');
-  }
-  const groupedRanges = groupRanges(markdownRanges);
-  return groupedRanges;
+    if (markdown.length > MAX_PARSABLE_LENGTH) {
+        return [];
+    }
+    const html = parseMarkdownToHTML(markdown);
+    const tokens = parseHTMLToTokens(html);
+    const tree = parseTokensToTree(tokens);
+    const [text, ranges] = parseTreeToTextAndRanges(tree);
+    if (text !== markdown) {
+        console.error(
+            `[react-native-live-markdown] Parsing error: the processed text does not match the original Markdown input. This may be caused by incorrect parsing functions or invalid input Markdown.\nProcessed input: '${JSON.stringify(
+                text,
+            )}'\nOriginal input: '${JSON.stringify(markdown)}'`,
+        );
+        return [];
+    }
+    let markdownRanges = sortRanges(ranges);
+    if (isAndroid) {
+        // Blocks applying italic and strikethrough styles to emojis on Android
+        // TODO: Remove this condition when splitting emojis inside the inline code block will be fixed on the web
+        markdownRanges = splitRangesOnEmojis(markdownRanges, 'italic');
+        markdownRanges = splitRangesOnEmojis(markdownRanges, 'strikethrough');
+    }
+    const groupedRanges = groupRanges(markdownRanges);
+    return groupedRanges;
 }
 export default parseExpensiMark;
 //# sourceMappingURL=parseExpensiMark.js.map
diff --git a/node_modules/@expensify/react-native-live-markdown/lib/module/styleUtils.js b/node_modules/@expensify/react-native-live-markdown/lib/module/styleUtils.js
index 1ab9c63..4f92154 100644
--- a/node_modules/@expensify/react-native-live-markdown/lib/module/styleUtils.js
+++ b/node_modules/@expensify/react-native-live-markdown/lib/module/styleUtils.js
@@ -39,6 +39,10 @@ function makeDefaultMarkdownStyle() {
       color: 'green',
       backgroundColor: 'lime'
     },
+    command: {
+      color: 'green',
+      backgroundColor: 'lime'
+    },
     mentionUser: {
       color: 'blue',
       backgroundColor: 'cyan'
diff --git a/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/blockUtils.js b/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/blockUtils.js
index ad119d2..f738be8 100644
--- a/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/blockUtils.js
+++ b/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/blockUtils.js
@@ -1,113 +1,118 @@
-import { addInlineImagePreview } from '../inputElements/inlineImage';
+import {addInlineImagePreview} from '../inputElements/inlineImage';
+
 function addStyleToBlock(targetElement, type, markdownStyle, isMultiline = true) {
-  const node = targetElement;
-  switch (type) {
-    case 'line':
-      Object.assign(node.style, {
-        margin: '0',
-        padding: '0'
-      });
-      break;
-    case 'syntax':
-      Object.assign(node.style, markdownStyle.syntax);
-      break;
-    case 'bold':
-      node.style.fontWeight = 'bold';
-      break;
-    case 'italic':
-      node.style.fontStyle = 'italic';
-      break;
-    case 'strikethrough':
-      node.style.textDecoration = 'line-through';
-      break;
-    case 'emoji':
-      Object.assign(node.style, {
-        ...markdownStyle.emoji,
-        verticalAlign: 'middle',
-        fontStyle: 'normal',
-        // remove italic
-        textDecoration: 'none',
-        // remove strikethrough
-        display: 'inline-block'
-      });
-      break;
-    case 'mention-here':
-      Object.assign(node.style, markdownStyle.mentionHere);
-      break;
-    case 'mention-user':
-      Object.assign(node.style, markdownStyle.mentionUser);
-      break;
-    case 'mention-report':
-      Object.assign(node.style, markdownStyle.mentionReport);
-      break;
-    case 'link':
-      Object.assign(node.style, {
-        ...markdownStyle.link,
-        textDecoration: 'underline'
-      });
-      break;
-    case 'code':
-      Object.assign(node.style, markdownStyle.code);
-      break;
-    case 'pre':
-      Object.assign(node.style, markdownStyle.pre);
-      break;
-    case 'blockquote':
-      Object.assign(node.style, {
-        ...markdownStyle.blockquote,
-        borderLeftStyle: 'solid',
-        display: 'inline-block',
-        maxWidth: '100%',
-        boxSizing: 'border-box',
-        overflowWrap: 'anywhere'
-      });
-      break;
-    case 'h1':
-      Object.assign(node.style, {
-        ...markdownStyle.h1,
-        fontWeight: 'bold'
-      });
-      break;
-    case 'block':
-      Object.assign(node.style, {
-        display: 'block',
-        margin: '0',
-        padding: '0',
-        position: 'relative'
-      });
-      break;
-    case 'text':
-      if (!isMultiline) {
-        var _targetElement$parent, _targetElement$parent2;
-        Object.assign(node.style, {
-          backgroundColor: (_targetElement$parent = targetElement.parentElement) === null || _targetElement$parent === void 0 ? void 0 : _targetElement$parent.style.backgroundColor
-        });
-        Object.assign(((_targetElement$parent2 = targetElement.parentElement) === null || _targetElement$parent2 === void 0 ? void 0 : _targetElement$parent2.style) ?? {}, {
-          backgroundColor: 'transparent'
-        });
-      }
-      break;
-    default:
-      break;
-  }
+    const node = targetElement;
+    switch (type) {
+        case 'line':
+            Object.assign(node.style, {
+                margin: '0',
+                padding: '0',
+            });
+            break;
+        case 'syntax':
+            Object.assign(node.style, markdownStyle.syntax);
+            break;
+        case 'bold':
+            node.style.fontWeight = 'bold';
+            break;
+        case 'italic':
+            node.style.fontStyle = 'italic';
+            break;
+        case 'strikethrough':
+            node.style.textDecoration = 'line-through';
+            break;
+        case 'emoji':
+            Object.assign(node.style, {
+                ...markdownStyle.emoji,
+                verticalAlign: 'middle',
+                fontStyle: 'normal',
+                // remove italic
+                textDecoration: 'none',
+                // remove strikethrough
+                display: 'inline-block',
+            });
+            break;
+        case 'mention-here':
+            Object.assign(node.style, markdownStyle.mentionHere);
+            break;
+        case 'command':
+            Object.assign(node.style, markdownStyle.command);
+            break;
+        case 'mention-user':
+            Object.assign(node.style, markdownStyle.mentionUser);
+            break;
+        case 'mention-report':
+            Object.assign(node.style, markdownStyle.mentionReport);
+            break;
+        case 'link':
+            Object.assign(node.style, {
+                ...markdownStyle.link,
+                textDecoration: 'underline',
+            });
+            break;
+        case 'code':
+            Object.assign(node.style, markdownStyle.code);
+            break;
+        case 'pre':
+            Object.assign(node.style, markdownStyle.pre);
+            break;
+        case 'blockquote':
+            Object.assign(node.style, {
+                ...markdownStyle.blockquote,
+                borderLeftStyle: 'solid',
+                display: 'inline-block',
+                maxWidth: '100%',
+                boxSizing: 'border-box',
+                overflowWrap: 'anywhere',
+            });
+            break;
+        case 'h1':
+            Object.assign(node.style, {
+                ...markdownStyle.h1,
+                fontWeight: 'bold',
+            });
+            break;
+        case 'block':
+            Object.assign(node.style, {
+                display: 'block',
+                margin: '0',
+                padding: '0',
+                position: 'relative',
+            });
+            break;
+        case 'text':
+            if (!isMultiline) {
+                var _targetElement$parent, _targetElement$parent2;
+                Object.assign(node.style, {
+                    backgroundColor:
+                        (_targetElement$parent = targetElement.parentElement) === null || _targetElement$parent === void 0 ? void 0 : _targetElement$parent.style.backgroundColor,
+                });
+                Object.assign(((_targetElement$parent2 = targetElement.parentElement) === null || _targetElement$parent2 === void 0 ? void 0 : _targetElement$parent2.style) ?? {}, {
+                    backgroundColor: 'transparent',
+                });
+            }
+            break;
+        default:
+            break;
+    }
 }
 const BLOCK_MARKDOWN_TYPES = ['inline-image'];
 const FULL_LINE_MARKDOWN_TYPES = ['blockquote'];
 function isBlockMarkdownType(type) {
-  return BLOCK_MARKDOWN_TYPES.includes(type);
+    return BLOCK_MARKDOWN_TYPES.includes(type);
 }
 function getFirstBlockMarkdownRange(ranges) {
-  const blockMarkdownRange = ranges.find(r => isBlockMarkdownType(r.type) || FULL_LINE_MARKDOWN_TYPES.includes(r.type));
-  return FULL_LINE_MARKDOWN_TYPES.includes((blockMarkdownRange === null || blockMarkdownRange === void 0 ? void 0 : blockMarkdownRange.type) || '') ? undefined : blockMarkdownRange;
+    const blockMarkdownRange = ranges.find((r) => isBlockMarkdownType(r.type) || FULL_LINE_MARKDOWN_TYPES.includes(r.type));
+    return FULL_LINE_MARKDOWN_TYPES.includes((blockMarkdownRange === null || blockMarkdownRange === void 0 ? void 0 : blockMarkdownRange.type) || '') ? undefined : blockMarkdownRange;
 }
 function extendBlockStructure(currentInput, targetNode, currentRange, ranges, text, markdownStyle, inlineImagesProps) {
-  switch (currentRange.type) {
-    case 'inline-image':
-      return addInlineImagePreview(currentInput, targetNode, text, ranges, markdownStyle, inlineImagesProps);
-    default:
-      break;
-  }
-  return targetNode;
+    switch (currentRange.type) {
+        case 'inline-image':
+            return addInlineImagePreview(currentInput, targetNode, text, ranges, markdownStyle, inlineImagesProps);
+        default:
+            break;
+    }
+    return targetNode;
 }
-export { addStyleToBlock, extendBlockStructure, isBlockMarkdownType, getFirstBlockMarkdownRange };
+export {addStyleToBlock, extendBlockStructure, isBlockMarkdownType, getFirstBlockMarkdownRange};
 //# sourceMappingURL=blockUtils.js.map
diff --git a/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/parserUtils.js b/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/parserUtils.js
index dcbe8fa..c096d8f 100644
--- a/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/parserUtils.js
+++ b/node_modules/@expensify/react-native-live-markdown/lib/module/web/utils/parserUtils.js
@@ -76,7 +76,7 @@ function addTextToElement(node, text, isMultiline = true) {
       span.appendChild(document.createTextNode(line));
       appendNode(span, node, 'text', line.length);
       const parentType = (_span$parentElement = span.parentElement) === null || _span$parentElement === void 0 ? void 0 : _span$parentElement.dataset.type;
-      if (!isMultiline && parentType && ['pre', 'code', 'mention-here', 'mention-user', 'mention-report'].includes(parentType)) {
+      if (!isMultiline && parentType && ['pre', 'code', 'mention-here', 'mention-user', 'mention-report', 'command'].includes(parentType)) {
         // this is a fix to background colors being shifted downwards in a singleline input
         addStyleToBlock(span, 'text', {}, false);
       }
