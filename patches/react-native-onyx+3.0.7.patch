diff --git a/node_modules/react-native-onyx/dist/ConnectionDebugUtils.d.ts b/node_modules/react-native-onyx/dist/ConnectionDebugUtils.d.ts
new file mode 100644
index 0000000..1485198
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/ConnectionDebugUtils.d.ts
@@ -0,0 +1,33 @@
+/**
+ * Debug utilities for inspecting Onyx connection state
+ * These should only be used for development/debugging purposes
+ */
+/**
+ * Logs the current connection manager state to console
+ */
+export declare function debugConnectionState(): void;
+/**
+ * Returns the current number of active connections
+ */
+export declare function getActiveConnectionCount(): number;
+/**
+ * Returns detailed information about all active connections
+ */
+export declare function getConnectionDetails(): Array<{
+    connectionID: string;
+    key: string;
+    callbackCount: number;
+    isConnectionMade: boolean;
+}>;
+/**
+ * Checks if a specific key has any active connections
+ */
+export declare function hasActiveConnectionForKey(key: string): boolean;
+/**
+ * Returns connection IDs for a specific key
+ */
+export declare function getConnectionIDsForKey(key: string): string[];
+/**
+ * Helper to log connection reuse test results
+ */
+export declare function testConnectionReuse(key: string, options1?: any, options2?: any): void;
diff --git a/node_modules/react-native-onyx/dist/ConnectionDebugUtils.js b/node_modules/react-native-onyx/dist/ConnectionDebugUtils.js
new file mode 100644
index 0000000..91c2376
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/ConnectionDebugUtils.js
@@ -0,0 +1,100 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.testConnectionReuse = exports.getConnectionIDsForKey = exports.hasActiveConnectionForKey = exports.getConnectionDetails = exports.getActiveConnectionCount = exports.debugConnectionState = void 0;
+const OnyxConnectionManager_1 = __importDefault(require("./OnyxConnectionManager"));
+/**
+ * Debug utilities for inspecting Onyx connection state
+ * These should only be used for development/debugging purposes
+ */
+/**
+ * Logs the current connection manager state to console
+ */
+function debugConnectionState() {
+    OnyxConnectionManager_1.default.debugConnectionState();
+}
+exports.debugConnectionState = debugConnectionState;
+/**
+ * Returns the current number of active connections
+ */
+function getActiveConnectionCount() {
+    // Access private connectionsMap for inspection
+    const connectionsMap = OnyxConnectionManager_1.default.connectionsMap;
+    return connectionsMap.size;
+}
+exports.getActiveConnectionCount = getActiveConnectionCount;
+/**
+ * Returns detailed information about all active connections
+ */
+function getConnectionDetails() {
+    const connectionsMap = OnyxConnectionManager_1.default.connectionsMap;
+    return Array.from(connectionsMap.entries()).map(([id, metadata]) => ({
+        connectionID: id,
+        key: metadata.onyxKey,
+        callbackCount: metadata.callbacks.size,
+        isConnectionMade: metadata.isConnectionMade,
+    }));
+}
+exports.getConnectionDetails = getConnectionDetails;
+/**
+ * Checks if a specific key has any active connections
+ */
+function hasActiveConnectionForKey(key) {
+    const connectionsMap = OnyxConnectionManager_1.default.connectionsMap;
+    for (const metadata of connectionsMap.values()) {
+        if (metadata.onyxKey === key) {
+            return true;
+        }
+    }
+    return false;
+}
+exports.hasActiveConnectionForKey = hasActiveConnectionForKey;
+/**
+ * Returns connection IDs for a specific key
+ */
+function getConnectionIDsForKey(key) {
+    const connectionsMap = OnyxConnectionManager_1.default.connectionsMap;
+    const connectionIDs = [];
+    for (const [id, metadata] of connectionsMap.entries()) {
+        if (metadata.onyxKey === key) {
+            connectionIDs.push(id);
+        }
+    }
+    return connectionIDs;
+}
+exports.getConnectionIDsForKey = getConnectionIDsForKey;
+/**
+ * Helper to log connection reuse test results
+ */
+function testConnectionReuse(key, options1 = {}, options2 = {}) {
+    console.log(`\n=== Testing Connection Reuse for key: ${key} ===`);
+    console.log('Before connections:', getActiveConnectionCount());
+    // Test connection 1
+    console.log('\nCreating first connection...');
+    console.log('Options 1:', options1);
+    // Test connection 2  
+    console.log('\nCreating second connection...');
+    console.log('Options 2:', options2);
+    setTimeout(() => {
+        console.log('\nFinal state:');
+        debugConnectionState();
+        const connectionIDs = getConnectionIDsForKey(key);
+        console.log(`\nConnections for key "${key}":`, connectionIDs);
+        console.log(`Connection reused: ${connectionIDs.length <= 1 ? 'YES' : 'NO'}`);
+        console.log('=== End Test ===\n');
+    }, 100);
+}
+exports.testConnectionReuse = testConnectionReuse;
+// Export for global access in development
+if (typeof window !== 'undefined') {
+    window.OnyxDebug = {
+        debugConnectionState,
+        getActiveConnectionCount,
+        getConnectionDetails,
+        hasActiveConnectionForKey,
+        getConnectionIDsForKey,
+        testConnectionReuse,
+    };
+}
diff --git a/node_modules/react-native-onyx/dist/DevTools.d.ts b/node_modules/react-native-onyx/dist/DevTools.d.ts
index b54d908..3fb50be 100644
--- a/node_modules/react-native-onyx/dist/DevTools.d.ts
+++ b/node_modules/react-native-onyx/dist/DevTools.d.ts
@@ -1,42 +1,19 @@
-type DevtoolsOptions = {
-    maxAge?: number;
-    name?: string;
-    postTimelineUpdate?: () => void;
-    preAction?: () => void;
-    logTrace?: boolean;
-    remote?: boolean;
-};
-type DevtoolsSubscriber = (message: {
-    type: string;
-    payload: unknown;
-    state: string;
-}) => void;
-type DevtoolsConnection = {
-    send(data: Record<string, unknown>, state: Record<string, unknown>): void;
-    init(state: Record<string, unknown>): void;
-    unsubscribe(): void;
-    subscribe(cb: DevtoolsSubscriber): () => void;
-};
-declare class DevTools {
-    private remoteDev?;
-    private state;
-    private defaultState;
-    constructor();
-    connectViaExtension(options?: DevtoolsOptions): DevtoolsConnection | undefined;
-    /**
-     * Registers an action that updated the current state of the storage
-     *
-     * @param type - name of the action
-     * @param payload - data written to the storage
-     * @param stateChanges - partial state that got updated after the changes
-     */
-    registerAction(type: string, payload: unknown, stateChanges?: Record<string, unknown> | null): void;
-    initState(initialState?: Record<string, unknown>): void;
-    /**
-     * This clears the internal state of the DevTools, preserving the keys included in `keysToPreserve`
-     */
-    clearState(keysToPreserve?: string[]): void;
-}
-declare const _default: DevTools;
-export default _default;
-export type { DevtoolsConnection };
+import type { IDevTools, DevtoolsConnection } from './DevTools/types';
+/**
+ * Initializes DevTools with the given enabled flag
+ */
+declare function initDevTools(enabled: boolean): void;
+/**
+ * Gets the current DevTools instance (for testing purposes only)
+ * @private
+ */
+declare function getDevToolsInstance(): IDevTools;
+/**
+ * Export a default object that delegates to the current devToolsInstance
+ * This allows the instance to be swapped out while keeping the same import signature
+ */
+declare const DevTools: IDevTools;
+export default DevTools;
+export { initDevTools, getDevToolsInstance };
+export type { DevtoolsConnection, IDevTools };
+export type { default as RealDevTools } from './DevTools/RealDevTools';
diff --git a/node_modules/react-native-onyx/dist/DevTools.js b/node_modules/react-native-onyx/dist/DevTools.js
index 0e5193a..1778772 100644
--- a/node_modules/react-native-onyx/dist/DevTools.js
+++ b/node_modules/react-native-onyx/dist/DevTools.js
@@ -1,69 +1,40 @@
 "use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
 Object.defineProperty(exports, "__esModule", { value: true });
-const ERROR_LABEL = 'Onyx DevTools - Error: ';
-class DevTools {
-    constructor() {
-        this.remoteDev = this.connectViaExtension();
-        this.state = {};
-        this.defaultState = {};
-    }
-    connectViaExtension(options) {
-        try {
-            // We don't want to augment the window type in a library code, so we use type assertion instead
-            // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-explicit-any
-            const reduxDevtools = typeof window === 'undefined' ? undefined : window.__REDUX_DEVTOOLS_EXTENSION__;
-            if ((options === null || options === void 0 ? void 0 : options.remote) || !reduxDevtools) {
-                return;
-            }
-            return reduxDevtools.connect(options);
-        }
-        catch (e) {
-            console.error(ERROR_LABEL, e);
-        }
-    }
-    /**
-     * Registers an action that updated the current state of the storage
-     *
-     * @param type - name of the action
-     * @param payload - data written to the storage
-     * @param stateChanges - partial state that got updated after the changes
-     */
+exports.initDevTools = initDevTools;
+exports.getDevToolsInstance = getDevToolsInstance;
+const RealDevTools_1 = __importDefault(require("./DevTools/RealDevTools"));
+const NoOpDevTools_1 = __importDefault(require("./DevTools/NoOpDevTools"));
+// Start with a no-op instance
+let devToolsInstance = new NoOpDevTools_1.default();
+/**
+ * Initializes DevTools with the given enabled flag
+ */
+function initDevTools(enabled) {
+    devToolsInstance = enabled ? new RealDevTools_1.default() : new NoOpDevTools_1.default();
+}
+/**
+ * Gets the current DevTools instance (for testing purposes only)
+ * @private
+ */
+function getDevToolsInstance() {
+    return devToolsInstance;
+}
+/**
+ * Export a default object that delegates to the current devToolsInstance
+ * This allows the instance to be swapped out while keeping the same import signature
+ */
+const DevTools = {
     registerAction(type, payload, stateChanges = {}) {
-        try {
-            if (!this.remoteDev) {
-                return;
-            }
-            const newState = Object.assign(Object.assign({}, this.state), stateChanges);
-            this.remoteDev.send({ type, payload }, newState);
-            this.state = newState;
-        }
-        catch (e) {
-            console.error(ERROR_LABEL, e);
-        }
-    }
+        devToolsInstance.registerAction(type, payload, stateChanges);
+    },
     initState(initialState = {}) {
-        try {
-            if (!this.remoteDev) {
-                return;
-            }
-            this.remoteDev.init(initialState);
-            this.state = initialState;
-            this.defaultState = initialState;
-        }
-        catch (e) {
-            console.error(ERROR_LABEL, e);
-        }
-    }
-    /**
-     * This clears the internal state of the DevTools, preserving the keys included in `keysToPreserve`
-     */
+        devToolsInstance.initState(initialState);
+    },
     clearState(keysToPreserve = []) {
-        const newState = Object.entries(this.state).reduce((obj, [key, value]) => {
-            // eslint-disable-next-line no-param-reassign
-            obj[key] = keysToPreserve.includes(key) ? value : this.defaultState[key];
-            return obj;
-        }, {});
-        this.registerAction('CLEAR', undefined, newState);
-    }
-}
-exports.default = new DevTools();
+        devToolsInstance.clearState(keysToPreserve);
+    },
+};
+exports.default = DevTools;
diff --git a/node_modules/react-native-onyx/dist/DevTools/NoOpDevTools.d.ts b/node_modules/react-native-onyx/dist/DevTools/NoOpDevTools.d.ts
new file mode 100644
index 0000000..3875372
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/DevTools/NoOpDevTools.d.ts
@@ -0,0 +1,11 @@
+import type { IDevTools } from './types';
+/**
+ * No-op implementation of DevTools that does nothing
+ * Used when DevTools is disabled
+ */
+declare class NoOpDevTools implements IDevTools {
+    registerAction(): void;
+    initState(): void;
+    clearState(): void;
+}
+export default NoOpDevTools;
diff --git a/node_modules/react-native-onyx/dist/DevTools/NoOpDevTools.js b/node_modules/react-native-onyx/dist/DevTools/NoOpDevTools.js
new file mode 100644
index 0000000..bd8c8f3
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/DevTools/NoOpDevTools.js
@@ -0,0 +1,18 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/**
+ * No-op implementation of DevTools that does nothing
+ * Used when DevTools is disabled
+ */
+class NoOpDevTools {
+    registerAction() {
+        // do nothing
+    }
+    initState() {
+        // do nothing
+    }
+    clearState() {
+        // do nothing
+    }
+}
+exports.default = NoOpDevTools;
diff --git a/node_modules/react-native-onyx/dist/DevTools/RealDevTools.d.ts b/node_modules/react-native-onyx/dist/DevTools/RealDevTools.d.ts
new file mode 100644
index 0000000..9d21b99
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/DevTools/RealDevTools.d.ts
@@ -0,0 +1,25 @@
+import type { IDevTools, DevtoolsOptions, DevtoolsConnection } from './types';
+/**
+ * Real implementation of DevTools that connects to Redux DevTools Extension
+ */
+declare class RealDevTools implements IDevTools {
+    private remoteDev?;
+    private state;
+    private defaultState;
+    constructor();
+    connectViaExtension(options?: DevtoolsOptions): DevtoolsConnection | undefined;
+    /**
+     * Registers an action that updated the current state of the storage
+     *
+     * @param type - name of the action
+     * @param payload - data written to the storage
+     * @param stateChanges - partial state that got updated after the changes
+     */
+    registerAction(type: string, payload: unknown, stateChanges?: Record<string, unknown> | null): void;
+    initState(initialState?: Record<string, unknown>): void;
+    /**
+     * This clears the internal state of the DevTools, preserving the keys included in `keysToPreserve`
+     */
+    clearState(keysToPreserve?: string[]): void;
+}
+export default RealDevTools;
diff --git a/node_modules/react-native-onyx/dist/DevTools/RealDevTools.js b/node_modules/react-native-onyx/dist/DevTools/RealDevTools.js
new file mode 100644
index 0000000..4482b5e
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/DevTools/RealDevTools.js
@@ -0,0 +1,72 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const ERROR_LABEL = 'Onyx DevTools - Error: ';
+/**
+ * Real implementation of DevTools that connects to Redux DevTools Extension
+ */
+class RealDevTools {
+    constructor() {
+        this.remoteDev = this.connectViaExtension();
+        this.state = {};
+        this.defaultState = {};
+    }
+    connectViaExtension(options) {
+        try {
+            // We don't want to augment the window type in a library code, so we use type assertion instead
+            // eslint-disable-next-line no-underscore-dangle, @typescript-eslint/no-explicit-any
+            const reduxDevtools = typeof window === 'undefined' ? undefined : window.__REDUX_DEVTOOLS_EXTENSION__;
+            if ((options === null || options === void 0 ? void 0 : options.remote) || !reduxDevtools) {
+                return;
+            }
+            return reduxDevtools.connect(options);
+        }
+        catch (e) {
+            console.error(ERROR_LABEL, e);
+        }
+    }
+    /**
+     * Registers an action that updated the current state of the storage
+     *
+     * @param type - name of the action
+     * @param payload - data written to the storage
+     * @param stateChanges - partial state that got updated after the changes
+     */
+    registerAction(type, payload, stateChanges = {}) {
+        try {
+            if (!this.remoteDev) {
+                return;
+            }
+            const newState = Object.assign(Object.assign({}, this.state), stateChanges);
+            this.remoteDev.send({ type, payload }, newState);
+            this.state = newState;
+        }
+        catch (e) {
+            console.error(ERROR_LABEL, e);
+        }
+    }
+    initState(initialState = {}) {
+        try {
+            if (!this.remoteDev) {
+                return;
+            }
+            this.remoteDev.init(initialState);
+            this.state = initialState;
+            this.defaultState = initialState;
+        }
+        catch (e) {
+            console.error(ERROR_LABEL, e);
+        }
+    }
+    /**
+     * This clears the internal state of the DevTools, preserving the keys included in `keysToPreserve`
+     */
+    clearState(keysToPreserve = []) {
+        const newState = Object.entries(this.state).reduce((obj, [key, value]) => {
+            // eslint-disable-next-line no-param-reassign
+            obj[key] = keysToPreserve.includes(key) ? value : this.defaultState[key];
+            return obj;
+        }, {});
+        this.registerAction('CLEAR', undefined, newState);
+    }
+}
+exports.default = RealDevTools;
diff --git a/node_modules/react-native-onyx/dist/DevTools/types.d.ts b/node_modules/react-native-onyx/dist/DevTools/types.d.ts
new file mode 100644
index 0000000..0537d59
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/DevTools/types.d.ts
@@ -0,0 +1,31 @@
+type DevtoolsOptions = {
+    maxAge?: number;
+    name?: string;
+    postTimelineUpdate?: () => void;
+    preAction?: () => void;
+    logTrace?: boolean;
+    remote?: boolean;
+};
+type DevtoolsSubscriber = (message: {
+    type: string;
+    payload: unknown;
+    state: string;
+}) => void;
+type DevtoolsConnection = {
+    send(data: Record<string, unknown>, state: Record<string, unknown>): void;
+    init(state: Record<string, unknown>): void;
+    unsubscribe(): void;
+    subscribe(cb: DevtoolsSubscriber): () => void;
+};
+type ReduxDevtools = {
+    connect(options?: DevtoolsOptions): DevtoolsConnection;
+};
+/**
+ * Type definition for DevTools instance
+ */
+type IDevTools = {
+    registerAction(type: string, payload: unknown, stateChanges?: Record<string, unknown> | null): void;
+    initState(initialState?: Record<string, unknown>): void;
+    clearState(keysToPreserve?: string[]): void;
+};
+export type { DevtoolsOptions, DevtoolsSubscriber, DevtoolsConnection, ReduxDevtools, IDevTools };
diff --git a/node_modules/react-native-onyx/dist/DevTools/types.js b/node_modules/react-native-onyx/dist/DevTools/types.js
new file mode 100644
index 0000000..c8ad2e5
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/DevTools/types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
diff --git a/node_modules/react-native-onyx/dist/Onyx.d.ts b/node_modules/react-native-onyx/dist/Onyx.d.ts
index 85c52d5..88c549b 100644
--- a/node_modules/react-native-onyx/dist/Onyx.d.ts
+++ b/node_modules/react-native-onyx/dist/Onyx.d.ts
@@ -2,7 +2,7 @@ import * as Logger from './Logger';
 import type { CollectionKeyBase, ConnectOptions, InitOptions, OnyxKey, OnyxMergeCollectionInput, OnyxMergeInput, OnyxMultiSetInput, OnyxSetInput, OnyxUpdate, SetOptions } from './types';
 import type { Connection } from './OnyxConnectionManager';
 /** Initialize the store with actions and listening for storage events */
-declare function init({ keys, initialKeyStates, evictableKeys, maxCachedKeysCount, shouldSyncMultipleInstances, enablePerformanceMetrics, skippableCollectionMemberIDs, }: InitOptions): void;
+declare function init({ keys, initialKeyStates, evictableKeys, maxCachedKeysCount, shouldSyncMultipleInstances, enablePerformanceMetrics, enableDevTools, skippableCollectionMemberIDs, }: InitOptions): void;
 /**
  * Connects to an Onyx key given the options passed and listens to its changes.
  * This method will be deprecated soon. Please use `Onyx.connectWithoutView()` instead.
diff --git a/node_modules/react-native-onyx/dist/Onyx.js b/node_modules/react-native-onyx/dist/Onyx.js
index 9e30232..e009f78 100644
--- a/node_modules/react-native-onyx/dist/Onyx.js
+++ b/node_modules/react-native-onyx/dist/Onyx.js
@@ -36,11 +36,12 @@ var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
 Object.defineProperty(exports, "__esModule", { value: true });
+const fast_equals_1 = require("fast-equals");
 const Logger = __importStar(require("./Logger"));
 const OnyxCache_1 = __importStar(require("./OnyxCache"));
 const storage_1 = __importDefault(require("./storage"));
 const utils_1 = __importDefault(require("./utils"));
-const DevTools_1 = __importDefault(require("./DevTools"));
+const DevTools_1 = __importStar(require("./DevTools"));
 const OnyxUtils_1 = __importDefault(require("./OnyxUtils"));
 const logMessages_1 = __importDefault(require("./logMessages"));
 const OnyxConnectionManager_1 = __importDefault(require("./OnyxConnectionManager"));
@@ -48,12 +49,13 @@ const GlobalSettings = __importStar(require("./GlobalSettings"));
 const metrics_1 = __importDefault(require("./metrics"));
 const OnyxMerge_1 = __importDefault(require("./OnyxMerge"));
 /** Initialize the store with actions and listening for storage events */
-function init({ keys = {}, initialKeyStates = {}, evictableKeys = [], maxCachedKeysCount = 1000, shouldSyncMultipleInstances = !!global.localStorage, enablePerformanceMetrics = false, skippableCollectionMemberIDs = [], }) {
+function init({ keys = {}, initialKeyStates = {}, evictableKeys = [], maxCachedKeysCount = 1000, shouldSyncMultipleInstances = !!global.localStorage, enablePerformanceMetrics = false, enableDevTools = true, skippableCollectionMemberIDs = [], }) {
     var _a;
     if (enablePerformanceMetrics) {
         GlobalSettings.setPerformanceMetricsEnabled(true);
         applyDecorators();
     }
+    (0, DevTools_1.initDevTools)(enableDevTools);
     storage_1.default.init();
     OnyxUtils_1.default.setSkippableCollectionMemberIDs(new Set(skippableCollectionMemberIDs));
     if (shouldSyncMultipleInstances) {
@@ -625,8 +627,22 @@ function setCollection(collectionKey, collection) {
         });
         const keyValuePairs = OnyxUtils_1.default.prepareKeyValuePairsForStorage(mutableCollection, true, undefined, true);
         const previousCollection = OnyxUtils_1.default.getCachedCollection(collectionKey);
-        keyValuePairs.forEach(([key, value]) => OnyxCache_1.default.set(key, value));
-        const updatePromise = OnyxUtils_1.default.scheduleNotifyCollectionSubscribers(collectionKey, mutableCollection, previousCollection);
+        // Preserve references for unchanged items in setCollection
+        const preservedCollection = {};
+        keyValuePairs.forEach(([key, value]) => {
+            const cachedValue = OnyxCache_1.default.get(key, false);
+            // Use deep equality check to preserve references for unchanged items
+            if (cachedValue !== undefined && (0, fast_equals_1.deepEqual)(value, cachedValue)) {
+                // Keep the existing reference
+                preservedCollection[key] = cachedValue;
+            }
+            else {
+                // Update cache only for changed items
+                OnyxCache_1.default.set(key, value);
+                preservedCollection[key] = value;
+            }
+        });
+        const updatePromise = OnyxUtils_1.default.scheduleNotifyCollectionSubscribers(collectionKey, preservedCollection, previousCollection);
         return storage_1.default.multiSet(keyValuePairs)
             .catch((error) => OnyxUtils_1.default.evictStorageAndRetry(error, setCollection, collectionKey, collection))
             .then(() => {
diff --git a/node_modules/react-native-onyx/dist/OnyxKeyUtils.d.ts b/node_modules/react-native-onyx/dist/OnyxKeyUtils.d.ts
new file mode 100644
index 0000000..3286456
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/OnyxKeyUtils.d.ts
@@ -0,0 +1,40 @@
+import type { OnyxKey } from './types';
+/**
+ * Utility functions for safely creating and validating Onyx keys
+ */
+/**
+ * Safely creates a collection member key, returning null if any part is undefined/null
+ * This prevents accidental creation of keys like "report_undefined"
+ *
+ * @param collectionKey - The base collection key (e.g., 'report_')
+ * @param memberID - The member ID to append
+ * @returns The complete key or null if memberID is undefined/null
+ */
+export declare function safeCollectionMemberKey<T extends string>(collectionKey: T, memberID: string | number | undefined | null): (T extends `${infer Base}_` ? `${Base}_${string}` : never) | null;
+/**
+ * Creates a collection member key with a fallback
+ *
+ * @param collectionKey - The base collection key
+ * @param memberID - The member ID to append
+ * @param fallbackKey - Key to return if memberID is invalid
+ * @returns The complete key or fallback key
+ */
+export declare function collectionMemberKeyWithFallback<T extends string, F extends OnyxKey>(collectionKey: T, memberID: string | number | undefined | null, fallbackKey: F): (T extends `${infer Base}_` ? `${Base}_${string}` : never) | F;
+/**
+ * Validates if a key is safe (doesn't contain undefined/null interpolations)
+ *
+ * @param key - The key to validate
+ * @returns true if key is safe to use
+ */
+export declare function isValidOnyxKey(key: string | undefined | null): key is string;
+/**
+ * Sanitizes a potential key value by removing/replacing problematic parts
+ *
+ * @param key - The key to sanitize
+ * @returns Sanitized key or null if unsalvageable
+ */
+export declare function sanitizeOnyxKey(key: string | undefined | null): string | null;
+/**
+ * Type guard to check if a value can be used as a collection member ID
+ */
+export declare function isValidMemberID(value: unknown): value is string | number;
diff --git a/node_modules/react-native-onyx/dist/OnyxKeyUtils.js b/node_modules/react-native-onyx/dist/OnyxKeyUtils.js
new file mode 100644
index 0000000..f583cdb
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/OnyxKeyUtils.js
@@ -0,0 +1,84 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.isValidMemberID = exports.sanitizeOnyxKey = exports.isValidOnyxKey = exports.collectionMemberKeyWithFallback = exports.safeCollectionMemberKey = void 0;
+/**
+ * Utility functions for safely creating and validating Onyx keys
+ */
+/**
+ * Safely creates a collection member key, returning null if any part is undefined/null
+ * This prevents accidental creation of keys like "report_undefined"
+ *
+ * @param collectionKey - The base collection key (e.g., 'report_')
+ * @param memberID - The member ID to append
+ * @returns The complete key or null if memberID is undefined/null
+ */
+function safeCollectionMemberKey(collectionKey, memberID) {
+    if (memberID === undefined || memberID === null || memberID === '') {
+        return null;
+    }
+    // Convert to string and validate it doesn't contain problematic values
+    const memberStr = String(memberID);
+    if (memberStr === 'undefined' || memberStr === 'null') {
+        return null;
+    }
+    return `${collectionKey}${memberStr}`;
+}
+exports.safeCollectionMemberKey = safeCollectionMemberKey;
+/**
+ * Creates a collection member key with a fallback
+ *
+ * @param collectionKey - The base collection key
+ * @param memberID - The member ID to append
+ * @param fallbackKey - Key to return if memberID is invalid
+ * @returns The complete key or fallback key
+ */
+function collectionMemberKeyWithFallback(collectionKey, memberID, fallbackKey) {
+    const safeKey = safeCollectionMemberKey(collectionKey, memberID);
+    return safeKey !== null && safeKey !== void 0 ? safeKey : fallbackKey;
+}
+exports.collectionMemberKeyWithFallback = collectionMemberKeyWithFallback;
+/**
+ * Validates if a key is safe (doesn't contain undefined/null interpolations)
+ *
+ * @param key - The key to validate
+ * @returns true if key is safe to use
+ */
+function isValidOnyxKey(key) {
+    if (!key || typeof key !== 'string') {
+        return false;
+    }
+    // Check for common problematic patterns
+    return !key.includes('undefined') && !key.includes('null');
+}
+exports.isValidOnyxKey = isValidOnyxKey;
+/**
+ * Sanitizes a potential key value by removing/replacing problematic parts
+ *
+ * @param key - The key to sanitize
+ * @returns Sanitized key or null if unsalvageable
+ */
+function sanitizeOnyxKey(key) {
+    if (!key || typeof key !== 'string') {
+        return null;
+    }
+    // Replace problematic values
+    let sanitized = key
+        .replace(/undefined/g, '')
+        .replace(/null/g, '')
+        .replace(/_+/g, '_') // Replace multiple underscores with single
+        .replace(/^_|_$/g, ''); // Remove leading/trailing underscores
+    // Return null if nothing meaningful remains
+    if (!sanitized || sanitized.length === 0) {
+        return null;
+    }
+    return sanitized;
+}
+exports.sanitizeOnyxKey = sanitizeOnyxKey;
+/**
+ * Type guard to check if a value can be used as a collection member ID
+ */
+function isValidMemberID(value) {
+    return (typeof value === 'string' && value.length > 0 && value !== 'undefined' && value !== 'null') ||
+        (typeof value === 'number' && !isNaN(value));
+}
+exports.isValidMemberID = isValidMemberID;
diff --git a/node_modules/react-native-onyx/dist/OnyxSubscriptionIndex.d.ts b/node_modules/react-native-onyx/dist/OnyxSubscriptionIndex.d.ts
new file mode 100644
index 0000000..e44ab7a
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/OnyxSubscriptionIndex.d.ts
@@ -0,0 +1,58 @@
+import type { OnyxKey } from './types';
+/**
+ * Optimized subscription indexing system for fast subscriber lookups.
+ * Replaces the O(n) linear search with O(1) hash-based lookups.
+ */
+declare class OnyxSubscriptionIndex {
+    /** Set of valid collection keys for validation */
+    private collectionKeys;
+    /** Direct key to subscription IDs mapping for exact matches - O(1) lookup */
+    private exactKeyMap;
+    /** Collection prefix to subscription IDs mapping for collection subscribers - O(1) lookup */
+    private collectionKeyMap;
+    /** Cache for collection key derivations to avoid repeated string operations */
+    private collectionKeyCache;
+    constructor();
+    /**
+     * Adds a subscriber to the index
+     * The key is the subscription key (what the subscriber registered for)
+     */
+    addSubscriber(key: OnyxKey, subscriptionID: number): void;
+    /**
+     * Removes a subscriber from the index
+     */
+    removeSubscriber(key: OnyxKey, subscriptionID: number): void;
+    /**
+     * Gets all subscriber IDs for a given key change - O(1) lookup
+     * Returns both exact matches and collection matches
+     */
+    getSubscriberIDs(key: OnyxKey): number[];
+    /**
+     * Sets the collection keys that are valid - must match OnyxUtils behavior
+     */
+    setCollectionKeys(collectionKeys: Set<OnyxKey>): void;
+    /**
+     * Efficiently extracts collection key from a member key with caching
+     * Uses the same logic as OnyxUtils.getCollectionKey() for consistency
+     */
+    private getCollectionKey;
+    /**
+     * Clears all cached collection key derivations
+     * Call this when collection structure changes
+     */
+    clearCollectionKeyCache(): void;
+    /**
+     * Gets statistics about the index for debugging/monitoring
+     */
+    getStats(): {
+        exactKeyCount: number;
+        collectionKeyCount: number;
+        totalSubscribers: number;
+        cacheSize: number;
+    };
+    /**
+     * Clears all subscriptions (used during Onyx.clear())
+     */
+    clear(): void;
+}
+export default OnyxSubscriptionIndex;
diff --git a/node_modules/react-native-onyx/dist/OnyxSubscriptionIndex.js b/node_modules/react-native-onyx/dist/OnyxSubscriptionIndex.js
new file mode 100644
index 0000000..231bdbd
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/OnyxSubscriptionIndex.js
@@ -0,0 +1,185 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/**
+ * Optimized subscription indexing system for fast subscriber lookups.
+ * Replaces the O(n) linear search with O(1) hash-based lookups.
+ */
+class OnyxSubscriptionIndex {
+    constructor() {
+        /** Set of valid collection keys for validation */
+        this.collectionKeys = new Set();
+        this.exactKeyMap = new Map();
+        this.collectionKeyMap = new Map();
+        this.collectionKeyCache = new Map();
+    }
+    /**
+     * Adds a subscriber to the index
+     * The key is the subscription key (what the subscriber registered for)
+     */
+    addSubscriber(key, subscriptionID) {
+        // DEBUG: Log what we're adding - special focus on report_ collection
+        if (key === 'report_' || key.startsWith('report_')) {
+            console.log(`[REPORT COLLECTION DEBUG] Adding subscriber:`, {
+                key,
+                subscriptionID,
+                isCollectionKey: this.collectionKeys.has(key),
+                collectionKeysHasReport: this.collectionKeys.has('report_'),
+                collectionKeysSize: this.collectionKeys.size,
+                firstFewCollectionKeys: Array.from(this.collectionKeys).slice(0, 10)
+            });
+        }
+        else {
+            console.log(`[Subscription Debug] Adding subscriber:`, {
+                key,
+                subscriptionID,
+                isCollectionKey: this.collectionKeys.has(key)
+            });
+        }
+        // Add to exact key mapping (every key gets stored exactly as registered)
+        if (!this.exactKeyMap.has(key)) {
+            this.exactKeyMap.set(key, new Set());
+        }
+        this.exactKeyMap.get(key).add(subscriptionID);
+        // Only add to collection mapping if this IS a collection key
+        // (e.g., "report_" not "report_123")
+        if (this.collectionKeys.has(key)) {
+            if (!this.collectionKeyMap.has(key)) {
+                this.collectionKeyMap.set(key, new Set());
+            }
+            this.collectionKeyMap.get(key).add(subscriptionID);
+        }
+    }
+    /**
+     * Removes a subscriber from the index
+     */
+    removeSubscriber(key, subscriptionID) {
+        // Remove from exact key mapping
+        const exactSubscribers = this.exactKeyMap.get(key);
+        if (exactSubscribers) {
+            exactSubscribers.delete(subscriptionID);
+            if (exactSubscribers.size === 0) {
+                this.exactKeyMap.delete(key);
+            }
+        }
+        // Remove from collection key mapping only if this IS a collection key
+        if (this.collectionKeys.has(key)) {
+            const collectionSubscribers = this.collectionKeyMap.get(key);
+            if (collectionSubscribers) {
+                collectionSubscribers.delete(subscriptionID);
+                if (collectionSubscribers.size === 0) {
+                    this.collectionKeyMap.delete(key);
+                }
+            }
+        }
+    }
+    /**
+     * Gets all subscriber IDs for a given key change - O(1) lookup
+     * Returns both exact matches and collection matches
+     */
+    getSubscriberIDs(key) {
+        const uniqueSubscribers = new Set();
+        // Get exact key subscribers - O(1)
+        const exactSubscribers = this.exactKeyMap.get(key);
+        if (exactSubscribers) {
+            exactSubscribers.forEach((id) => uniqueSubscribers.add(id));
+        }
+        // Get collection subscribers - O(1)
+        // Use try/catch to match original behavior
+        let collectionKey = null;
+        try {
+            collectionKey = this.getCollectionKey(key);
+        }
+        catch (e) {
+            // If getCollectionKey throws, just continue with exact matches only
+            collectionKey = null;
+        }
+        if (collectionKey) {
+            const collectionSubscribers = this.collectionKeyMap.get(collectionKey);
+            if (collectionSubscribers) {
+                collectionSubscribers.forEach((id) => uniqueSubscribers.add(id));
+            }
+        }
+        // DEBUG: Log what we found
+        const result = Array.from(uniqueSubscribers);
+        console.log(`[Subscription Debug] Lookup for key: "${key}"`, {
+            exactSubscribers: exactSubscribers ? Array.from(exactSubscribers) : [],
+            collectionKey,
+            collectionSubscribers: collectionKey ? (this.collectionKeyMap.get(collectionKey) ? Array.from(this.collectionKeyMap.get(collectionKey)) : []) : [],
+            finalResult: result,
+            exactKeyMapSize: this.exactKeyMap.size,
+            collectionKeyMapSize: this.collectionKeyMap.size
+        });
+        return result;
+    }
+    /**
+     * Sets the collection keys that are valid - must match OnyxUtils behavior
+     */
+    setCollectionKeys(collectionKeys) {
+        console.log(`[COLLECTION KEYS DEBUG] Setting collection keys:`, {
+            count: collectionKeys.size,
+            hasReportCollection: collectionKeys.has('report_'),
+            allKeys: Array.from(collectionKeys)
+        });
+        this.collectionKeys = collectionKeys;
+        this.clearCollectionKeyCache(); // Clear cache when collection keys change
+    }
+    /**
+     * Efficiently extracts collection key from a member key with caching
+     * Uses the same logic as OnyxUtils.getCollectionKey() for consistency
+     */
+    getCollectionKey(key) {
+        // Check cache first
+        if (this.collectionKeyCache.has(key)) {
+            return this.collectionKeyCache.get(key);
+        }
+        let collectionKey = null;
+        // Use the same algorithm as OnyxUtils.getCollectionKey()
+        let lastUnderscoreIndex = key.lastIndexOf('_');
+        // Iterate backwards to find the longest key that ends with '_'
+        while (lastUnderscoreIndex > 0) {
+            const possibleKey = key.slice(0, lastUnderscoreIndex + 1);
+            // Check if the substring is a valid collection key
+            if (this.collectionKeys.has(possibleKey)) {
+                collectionKey = possibleKey;
+                break;
+            }
+            // Move to the next underscore to check smaller possible keys
+            lastUnderscoreIndex = key.lastIndexOf('_', lastUnderscoreIndex - 1);
+        }
+        // Cache the result
+        this.collectionKeyCache.set(key, collectionKey);
+        return collectionKey;
+    }
+    /**
+     * Clears all cached collection key derivations
+     * Call this when collection structure changes
+     */
+    clearCollectionKeyCache() {
+        this.collectionKeyCache.clear();
+    }
+    /**
+     * Gets statistics about the index for debugging/monitoring
+     */
+    getStats() {
+        let totalSubscribers = 0;
+        this.exactKeyMap.forEach((subscribers) => {
+            totalSubscribers += subscribers.size;
+        });
+        return {
+            exactKeyCount: this.exactKeyMap.size,
+            collectionKeyCount: this.collectionKeyMap.size,
+            totalSubscribers,
+            cacheSize: this.collectionKeyCache.size,
+        };
+    }
+    /**
+     * Clears all subscriptions (used during Onyx.clear())
+     */
+    clear() {
+        this.exactKeyMap.clear();
+        this.collectionKeyMap.clear();
+        this.collectionKeyCache.clear();
+        this.collectionKeys.clear(); // Clear collection keys to avoid stale references
+    }
+}
+exports.default = OnyxSubscriptionIndex;
diff --git a/node_modules/react-native-onyx/dist/OnyxUtils.js b/node_modules/react-native-onyx/dist/OnyxUtils.js
index c8c79a7..9649e12 100644
--- a/node_modules/react-native-onyx/dist/OnyxUtils.js
+++ b/node_modules/react-native-onyx/dist/OnyxUtils.js
@@ -1094,10 +1094,31 @@ function mergeCollectionWithPatches(collectionKey, collection, mergeReplaceNullP
         // finalMergedCollection contains all the keys that were merged, without the keys of incompatible updates
         const finalMergedCollection = Object.assign(Object.assign({}, existingKeyCollection), newCollection);
         // Prefill cache if necessary by calling get() on any existing keys and then merge original data to cache
-        // and update all subscribers
+        // and update all subscribers with reference preservation for unchanged items
         const promiseUpdate = previousCollectionPromise.then((previousCollection) => {
+            const preservedCollection = {};
+            // Capture the original cached values before merging
+            const originalCachedValues = {};
+            Object.keys(finalMergedCollection).forEach((key) => {
+                originalCachedValues[key] = OnyxCache_1.default.get(key, false);
+            });
+            // Then merge all the data into cache as normal
             OnyxCache_1.default.merge(finalMergedCollection);
-            return scheduleNotifyCollectionSubscribers(collectionKey, finalMergedCollection, previousCollection);
+            // Finally, preserve references for items that didn't actually change
+            Object.keys(finalMergedCollection).forEach((key) => {
+                const newMergedValue = OnyxCache_1.default.get(key, false);
+                const originalValue = originalCachedValues[key];
+                // Use deep equality check to preserve references for unchanged items
+                if (originalValue !== undefined && (0, fast_equals_1.deepEqual)(newMergedValue, originalValue)) {
+                    // Keep the existing reference and update cache
+                    preservedCollection[key] = originalValue;
+                    OnyxCache_1.default.set(key, originalValue);
+                }
+                else {
+                    preservedCollection[key] = newMergedValue;
+                }
+            });
+            return scheduleNotifyCollectionSubscribers(collectionKey, preservedCollection, previousCollection);
         });
         return Promise.all(promises)
             .catch((error) => evictStorageAndRetry(error, mergeCollectionWithPatches, collectionKey, resultCollection))
@@ -1145,8 +1166,22 @@ function partialSetCollection(collectionKey, collection) {
         const existingKeys = resultCollectionKeys.filter((key) => persistedKeys.has(key));
         const previousCollection = getCachedCollection(collectionKey, existingKeys);
         const keyValuePairs = prepareKeyValuePairsForStorage(mutableCollection, true, undefined, true);
-        keyValuePairs.forEach(([key, value]) => OnyxCache_1.default.set(key, value));
-        const updatePromise = scheduleNotifyCollectionSubscribers(collectionKey, mutableCollection, previousCollection);
+        // Preserve references for unchanged items in partialSetCollection
+        const preservedCollection = {};
+        keyValuePairs.forEach(([key, value]) => {
+            const cachedValue = OnyxCache_1.default.get(key, false);
+            // Use deep equality check to preserve references for unchanged items
+            if (cachedValue !== undefined && (0, fast_equals_1.deepEqual)(value, cachedValue)) {
+                // Keep the existing reference
+                preservedCollection[key] = cachedValue;
+            }
+            else {
+                // Update cache only for changed items
+                OnyxCache_1.default.set(key, value);
+                preservedCollection[key] = value;
+            }
+        });
+        const updatePromise = scheduleNotifyCollectionSubscribers(collectionKey, preservedCollection, previousCollection);
         return storage_1.default.multiSet(keyValuePairs)
             .catch((error) => evictStorageAndRetry(error, partialSetCollection, collectionKey, collection))
             .then(() => {
diff --git a/node_modules/react-native-onyx/dist/PerformanceUtils.d.ts b/node_modules/react-native-onyx/dist/PerformanceUtils.d.ts
new file mode 100644
index 0000000..f02e7fd
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/PerformanceUtils.d.ts
@@ -0,0 +1,8 @@
+import type { OnyxKey } from './types';
+import type { Mapping } from './Onyx';
+declare function setShouldDebugSetState(debug: boolean): void;
+/**
+ * Provide insights into why a setState() call occurred by diffing the before and after values.
+ */
+declare function logSetStateCall<TKey extends OnyxKey>(mapping: Mapping<TKey>, previousValue: unknown, newValue: unknown, caller: string, keyThatChanged?: string): void;
+export { logSetStateCall, setShouldDebugSetState };
diff --git a/node_modules/react-native-onyx/dist/PerformanceUtils.js b/node_modules/react-native-onyx/dist/PerformanceUtils.js
new file mode 100644
index 0000000..50cd3fe
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/PerformanceUtils.js
@@ -0,0 +1,52 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.logSetStateCall = logSetStateCall;
+exports.setShouldDebugSetState = setShouldDebugSetState;
+const transform_1 = __importDefault(require("lodash/transform"));
+const fast_equals_1 = require("fast-equals");
+let debugSetState = false;
+function setShouldDebugSetState(debug) {
+    debugSetState = debug;
+}
+/**
+ * Deep diff between two objects. Useful for figuring out what changed about an object from one render to the next so
+ * that state and props updates can be optimized.
+ */
+function diffObject(object, base) {
+    return (0, transform_1.default)(object, (result, value, key) => {
+        if ((0, fast_equals_1.deepEqual)(value, base[key])) {
+            return;
+        }
+        if (typeof value === 'object' && typeof base[key] === 'object') {
+            // eslint-disable-next-line no-param-reassign
+            result[key] = diffObject(value, base[key]);
+        }
+        else {
+            // eslint-disable-next-line no-param-reassign
+            result[key] = value;
+        }
+    });
+}
+/**
+ * Provide insights into why a setState() call occurred by diffing the before and after values.
+ */
+function logSetStateCall(mapping, previousValue, newValue, caller, keyThatChanged) {
+    if (!debugSetState) {
+        return;
+    }
+    const logParams = {};
+    if (keyThatChanged) {
+        logParams.keyThatChanged = keyThatChanged;
+    }
+    if (newValue && previousValue && typeof newValue === 'object' && typeof previousValue === 'object') {
+        logParams.difference = diffObject(previousValue, newValue);
+    }
+    else {
+        logParams.previousValue = previousValue;
+        logParams.newValue = newValue;
+    }
+    console.debug(`[Onyx-Debug] ${'displayName' in mapping && mapping.displayName} setState() called. Subscribed to key '${mapping.key}' (${caller})`, logParams);
+}
diff --git a/node_modules/react-native-onyx/dist/StateProvider.d.ts b/node_modules/react-native-onyx/dist/StateProvider.d.ts
new file mode 100644
index 0000000..f53c6c3
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/StateProvider.d.ts
@@ -0,0 +1,30 @@
+import type { OnyxInputKeyValueMapping } from './types';
+type StateSubscriber = () => void;
+declare class StateProvider {
+    private subscribers;
+    private isInitialized;
+    private originalKeyChanged;
+    /**
+     * Initialize the state provider by hooking into Onyx's change notification system
+     */
+    init(): void;
+    /**
+     * Subscribe to the entire state changes
+     */
+    subscribe(callback: StateSubscriber): () => void;
+    /**
+     * Get the current entire state snapshot
+     */
+    getState(): Partial<OnyxInputKeyValueMapping>;
+    /**
+     * Notify all subscribers of state changes
+     */
+    private notifySubscribers;
+    /**
+     * Clean up the monkey patch
+     */
+    cleanup(): void;
+}
+declare const stateProvider: StateProvider;
+export default stateProvider;
+export type { StateSubscriber };
diff --git a/node_modules/react-native-onyx/dist/StateProvider.js b/node_modules/react-native-onyx/dist/StateProvider.js
new file mode 100644
index 0000000..6ae1762
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/StateProvider.js
@@ -0,0 +1,68 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const OnyxCache_1 = __importDefault(require("./OnyxCache"));
+const OnyxUtils_1 = __importDefault(require("./OnyxUtils"));
+class StateProvider {
+    constructor() {
+        this.subscribers = new Set();
+        this.isInitialized = false;
+        this.originalKeyChanged = null;
+    }
+    /**
+     * Initialize the state provider by hooking into Onyx's change notification system
+     */
+    init() {
+        if (this.isInitialized) {
+            return;
+        }
+        this.originalKeyChanged = OnyxUtils_1.default.keyChanged.bind(OnyxUtils_1.default);
+        OnyxUtils_1.default.keyChanged = (key, value, previousValue, canUpdateSubscriber, notifyConnectSubscribers, notifyWithOnyxSubscribers, notifyUseOnyxHookSubscribers) => {
+            const result = this.originalKeyChanged(key, value, previousValue, canUpdateSubscriber, notifyConnectSubscribers, notifyWithOnyxSubscribers, notifyUseOnyxHookSubscribers);
+            this.notifySubscribers();
+            return result;
+        };
+        this.isInitialized = true;
+    }
+    /**
+     * Subscribe to the entire state changes
+     */
+    subscribe(callback) {
+        if (!this.isInitialized) {
+            this.init();
+        }
+        this.subscribers.add(callback);
+        return () => {
+            this.subscribers.delete(callback);
+        };
+    }
+    /**
+     * Get the current entire state snapshot
+     */
+    getState() {
+        return OnyxCache_1.default.getStorageMap();
+    }
+    /**
+     * Notify all subscribers of state changes
+     */
+    notifySubscribers() {
+        this.subscribers.forEach((callback) => {
+            callback();
+        });
+    }
+    /**
+     * Clean up the monkey patch
+     */
+    cleanup() {
+        if (this.originalKeyChanged) {
+            OnyxUtils_1.default.keyChanged = this.originalKeyChanged;
+            this.originalKeyChanged = null;
+        }
+        this.subscribers.clear();
+        this.isInitialized = false;
+    }
+}
+const stateProvider = new StateProvider();
+exports.default = stateProvider;
diff --git a/node_modules/react-native-onyx/dist/storage-eviction/index.d.ts b/node_modules/react-native-onyx/dist/storage-eviction/index.d.ts
new file mode 100644
index 0000000..f3a6d78
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/storage-eviction/index.d.ts
@@ -0,0 +1,49 @@
+import type { OnyxKey } from '../types';
+import type { StorageUsageConfig } from './types';
+import { DEFAULT_STORAGE_CONFIG } from './types';
+type StorageManagerConfig = Partial<StorageUsageConfig>;
+type StorageCleanupResult = {
+    cleanedKeys: OnyxKey[];
+    timeElapsed: number;
+    errors: string[];
+};
+declare class StorageManager {
+    private keyInfoMap;
+    private config;
+    private evictableKeys;
+    private lastCleanup;
+    private isInitialized;
+    private monitoringInterval;
+    private isMonitoring;
+    private lastStatusLog;
+    constructor(config?: Partial<StorageUsageConfig>);
+    initialize(): Promise<void>;
+    private initializeTracking;
+    private trackExistingKeys;
+    private initializeKeyTracking;
+    trackKeySet(key: OnyxKey): void;
+    private updateExistingKey;
+    private createNewKeyInfo;
+    private saveMetadataAsync;
+    trackKeyRemoval(key: OnyxKey): void;
+    setEvictableKeys(keys: string[]): void;
+    private isKeyEvictable;
+    private getEvictableKeysCount;
+    private getMetadataKey;
+    private saveMetadata;
+    private loadMetadata;
+    shouldPerformCleanup(): boolean;
+    private isKeyExpired;
+    markCleanupPerformed(): void;
+    private startMonitoring;
+    private stopMonitoring;
+    private performInitialCleanupIfNeeded;
+    shutdown(): void;
+    performCleanup(): Promise<StorageCleanupResult>;
+    private shouldEvictKey;
+    private executeCleanup;
+}
+declare function createStorageManager(config?: StorageManagerConfig | false): StorageManager | null;
+declare function getStorageManager(): StorageManager | null;
+declare function cleanupStorageManager(): void;
+export { StorageManager, createStorageManager, getStorageManager, cleanupStorageManager, DEFAULT_STORAGE_CONFIG };
diff --git a/node_modules/react-native-onyx/dist/storage-eviction/index.js b/node_modules/react-native-onyx/dist/storage-eviction/index.js
new file mode 100644
index 0000000..b19f7ff
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/storage-eviction/index.js
@@ -0,0 +1,443 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DEFAULT_STORAGE_CONFIG = exports.cleanupStorageManager = exports.getStorageManager = exports.createStorageManager = exports.StorageManager = void 0;
+const storage_1 = __importDefault(require("../storage"));
+const Logger = __importStar(require("../Logger"));
+const types_1 = require("./types");
+Object.defineProperty(exports, "DEFAULT_STORAGE_CONFIG", { enumerable: true, get: function () { return types_1.DEFAULT_STORAGE_CONFIG; } });
+const MILLISECONDS_PER_DAY = 1000 * 60 * 60 * 24;
+class StorageManager {
+    constructor(config = {}) {
+        this.keyInfoMap = new Map();
+        this.evictableKeys = new Set();
+        this.lastCleanup = 0;
+        this.isInitialized = false;
+        this.monitoringInterval = null;
+        this.isMonitoring = false;
+        this.lastStatusLog = 0;
+        this.config = Object.assign(Object.assign({}, types_1.DEFAULT_STORAGE_CONFIG), config);
+        console.log(`[StorageManager] Initialized with config:`, this.config);
+        this.setEvictableKeys(this.config.evictableKeys);
+    }
+    initialize() {
+        if (this.isInitialized) {
+            Logger.logInfo('StorageManager already initialized');
+            return Promise.resolve();
+        }
+        Logger.logInfo('Initializing StorageManager...');
+        return this.initializeTracking()
+            .then(() => this.startMonitoring())
+            .then(() => this.performInitialCleanupIfNeeded())
+            .then(() => {
+            this.isInitialized = true;
+            Logger.logInfo('StorageManager initialized successfully');
+        })
+            .catch((error) => {
+            Logger.logAlert(`Failed to initialize StorageManager: ${error}`);
+            throw error;
+        });
+    }
+    initializeTracking() {
+        Logger.logInfo('Initializing storage usage tracking...');
+        return storage_1.default.getAllKeys()
+            .then((allKeys) => {
+            Logger.logInfo(`Found ${allKeys.length} keys in storage`);
+            return this.trackExistingKeys(allKeys);
+        })
+            .catch((error) => {
+            Logger.logAlert(`Failed to initialize storage tracking: ${error}`);
+        });
+    }
+    trackExistingKeys(keys) {
+        const dataKeys = keys.filter((key) => !key.startsWith('__onyx_meta_'));
+        const evictableDataKeys = dataKeys.filter((key) => this.isKeyEvictable(key));
+        console.log(`[StorageManager] Filtering keys: ${dataKeys.length} total, ${evictableDataKeys.length} evictable`);
+        const trackingPromises = evictableDataKeys.map((key) => this.initializeKeyTracking(key));
+        return Promise.all(trackingPromises);
+    }
+    initializeKeyTracking(key) {
+        const now = Date.now();
+        return this.loadMetadata(key)
+            .then((metadata) => {
+            const keyInfo = {
+                key,
+                lastAccessed: (metadata === null || metadata === void 0 ? void 0 : metadata.lastAccessed) || now,
+                accessCount: (metadata === null || metadata === void 0 ? void 0 : metadata.accessCount) || 1,
+                createdAt: (metadata === null || metadata === void 0 ? void 0 : metadata.createdAt) || now,
+                isEvictable: true,
+            };
+            this.keyInfoMap.set(key, keyInfo);
+            if (!metadata) {
+                console.log(`[StorageManager] Creating metadata for key: ${key}`, {
+                    lastAccessed: now,
+                    accessCount: 1,
+                    createdAt: now,
+                    version: 1,
+                });
+                return this.saveMetadata(key, {
+                    lastAccessed: now,
+                    accessCount: 1,
+                    createdAt: now,
+                    version: 1,
+                }).catch((error) => {
+                    Logger.logInfo(`Failed to create initial metadata for ${key}: ${error}`);
+                });
+            }
+            return Promise.resolve();
+        })
+            .catch((error) => {
+            Logger.logInfo(`Failed to initialize tracking for key ${key}: ${error}`);
+        });
+    }
+    trackKeySet(key) {
+        if (!this.isInitialized)
+            return;
+        const isEvictable = this.isKeyEvictable(key);
+        const now = Date.now();
+        const existing = this.keyInfoMap.get(key);
+        if (existing) {
+            this.updateExistingKey(existing, now, isEvictable);
+        }
+        else {
+            this.createNewKeyInfo(key, now, isEvictable);
+        }
+    }
+    updateExistingKey(keyInfo, now, isEvictable) {
+        const updatedKeyInfo = Object.assign(Object.assign({}, keyInfo), { lastAccessed: now, accessCount: keyInfo.accessCount + 1, isEvictable });
+        this.keyInfoMap.set(keyInfo.key, updatedKeyInfo);
+        if (isEvictable) {
+            console.log(`[StorageManager] Updating metadata for key: ${updatedKeyInfo.key}`, {
+                lastAccessed: now,
+                accessCount: updatedKeyInfo.accessCount,
+                createdAt: updatedKeyInfo.createdAt,
+                version: 1,
+            });
+            this.saveMetadataAsync(updatedKeyInfo.key, {
+                lastAccessed: now,
+                accessCount: updatedKeyInfo.accessCount,
+                createdAt: updatedKeyInfo.createdAt,
+                version: 1,
+            });
+        }
+    }
+    createNewKeyInfo(key, now, isEvictable) {
+        const keyInfo = {
+            key,
+            lastAccessed: now,
+            accessCount: 1,
+            createdAt: now,
+            isEvictable,
+        };
+        this.keyInfoMap.set(key, keyInfo);
+        if (isEvictable) {
+            console.log(`[StorageManager] Creating metadata for new key: ${key}`, {
+                lastAccessed: now,
+                accessCount: 1,
+                createdAt: now,
+                version: 1,
+            });
+            this.saveMetadataAsync(key, {
+                lastAccessed: now,
+                accessCount: 1,
+                createdAt: now,
+                version: 1,
+            });
+        }
+    }
+    saveMetadataAsync(key, metadata) {
+        this.saveMetadata(key, metadata).catch((error) => {
+            Logger.logInfo(`Non-blocking metadata save failed for ${key}: ${error}`);
+        });
+    }
+    trackKeyRemoval(key) {
+        if (!this.isInitialized)
+            return;
+        this.keyInfoMap.delete(key);
+        const removedKeyInfo = this.keyInfoMap.get(key);
+        if (removedKeyInfo === null || removedKeyInfo === void 0 ? void 0 : removedKeyInfo.isEvictable) {
+            const metadataKey = this.getMetadataKey(key);
+            storage_1.default.removeItem(metadataKey).catch((error) => {
+                Logger.logInfo(`Failed to remove metadata for ${key}: ${error}`);
+            });
+        }
+    }
+    setEvictableKeys(keys) {
+        this.evictableKeys = new Set(keys);
+        for (const keyInfo of this.keyInfoMap.values()) {
+            const isEvictable = this.isKeyEvictable(keyInfo.key);
+            keyInfo.isEvictable = isEvictable;
+        }
+        console.log(`[StorageManager] Updated evictable keys: ${this.getEvictableKeysCount()} evictable out of ${this.keyInfoMap.size} total`);
+    }
+    isKeyEvictable(key) {
+        return Array.from(this.evictableKeys).some((pattern) => {
+            if (pattern.endsWith('_')) {
+                return key.startsWith(pattern);
+            }
+            return key === pattern;
+        });
+    }
+    getEvictableKeysCount() {
+        let count = 0;
+        for (const keyInfo of this.keyInfoMap.values()) {
+            if (keyInfo.isEvictable) {
+                count++;
+            }
+        }
+        return count;
+    }
+    getMetadataKey(key) {
+        return `__onyx_meta_${key}`;
+    }
+    saveMetadata(key, metadata) {
+        const metadataKey = this.getMetadataKey(key);
+        return storage_1.default.setItem(metadataKey, metadata).catch((error) => {
+            Logger.logInfo(`Failed to save metadata for ${key}: ${error}`);
+            throw error;
+        });
+    }
+    loadMetadata(key) {
+        const metadataKey = this.getMetadataKey(key);
+        return storage_1.default.getItem(metadataKey)
+            .then((metadata) => {
+            return metadata;
+        })
+            .catch((error) => {
+            Logger.logInfo(`Failed to load metadata for ${key}: ${error}`);
+            return null;
+        });
+    }
+    shouldPerformCleanup() {
+        const now = Date.now();
+        if (now - this.lastCleanup < this.config.cleanupInterval) {
+            return false;
+        }
+        if (!this.config.enabled) {
+            return false;
+        }
+        if (this.getEvictableKeysCount() === 0) {
+            return false;
+        }
+        for (const keyInfo of this.keyInfoMap.values()) {
+            if (keyInfo.isEvictable && this.isKeyExpired(keyInfo, now)) {
+                Logger.logInfo('Found expired keys, cleanup needed');
+                return true;
+            }
+        }
+        return false;
+    }
+    isKeyExpired(keyInfo, now) {
+        const daysSinceAccess = (now - keyInfo.lastAccessed) / MILLISECONDS_PER_DAY;
+        const ageInDays = (now - keyInfo.createdAt) / MILLISECONDS_PER_DAY;
+        return daysSinceAccess > this.config.maxIdleDays || ageInDays > this.config.maxAgeDays;
+    }
+    markCleanupPerformed() {
+        this.lastCleanup = Date.now();
+    }
+    startMonitoring() {
+        if (this.isMonitoring) {
+            return;
+        }
+        this.isMonitoring = true;
+        Logger.logInfo('Storage monitoring started');
+        this.monitoringInterval = setInterval(() => {
+            try {
+                if (this.shouldPerformCleanup()) {
+                    Logger.logInfo('Automatic cleanup triggered', {
+                        evictableKeys: this.getEvictableKeysCount(),
+                    });
+                    this.performCleanup()
+                        .then((result) => {
+                        Logger.logInfo('Cleanup completed', {
+                            cleanedKeys: result.cleanedKeys,
+                            timeElapsed: `${result.timeElapsed}ms`,
+                            errors: result.errors.length > 0 ? result.errors : 'None',
+                        });
+                    })
+                        .catch((error) => {
+                        Logger.logAlert(`Monitor cleanup failed: ${error}`);
+                    });
+                }
+                else {
+                    const now = Date.now();
+                    if (!this.lastStatusLog || now - this.lastStatusLog > 5 * 60 * 1000) {
+                        Logger.logInfo('Status check', {
+                            totalKeys: this.keyInfoMap.size,
+                            evictableKeys: this.getEvictableKeysCount(),
+                        });
+                        this.lastStatusLog = now;
+                    }
+                }
+            }
+            catch (error) {
+                Logger.logInfo(`Storage monitoring error: ${error}`);
+            }
+        }, this.config.cleanupInterval);
+    }
+    stopMonitoring() {
+        if (this.monitoringInterval) {
+            clearInterval(this.monitoringInterval);
+            this.monitoringInterval = null;
+        }
+        this.isMonitoring = false;
+        Logger.logInfo('Storage monitoring stopped');
+    }
+    performInitialCleanupIfNeeded() {
+        if (!this.shouldPerformCleanup()) {
+            return Promise.resolve();
+        }
+        Logger.logInfo('Performing initial storage cleanup');
+        return this.performCleanup();
+    }
+    shutdown() {
+        this.stopMonitoring();
+        this.isInitialized = false;
+        Logger.logInfo('StorageManager shutdown completed');
+    }
+    performCleanup() {
+        if (!this.config.enabled) {
+            return Promise.resolve({
+                cleanedKeys: [],
+                timeElapsed: 0,
+                errors: ['Storage eviction is disabled'],
+            });
+        }
+        const startTime = Date.now();
+        const cleanedKeys = [];
+        const errors = [];
+        Logger.logInfo('Starting storage cleanup');
+        Logger.logInfo(`Storage usage: ${this.keyInfoMap.size} keys, ${this.getEvictableKeysCount()} evictable`);
+        const keysToEvict = [];
+        const now = Date.now();
+        for (const keyInfo of this.keyInfoMap.values()) {
+            if (keyInfo.isEvictable && this.shouldEvictKey(keyInfo)) {
+                keysToEvict.push(keyInfo);
+            }
+        }
+        console.log(`[StorageManager] Cleanup candidates found:`, {
+            totalEvictable: this.getEvictableKeysCount(),
+            keysToEvict: keysToEvict.map((k) => k.key),
+            candidateData: keysToEvict.map((k) => ({
+                key: k.key,
+                lastAccessed: new Date(k.lastAccessed).toISOString(),
+                ageInDays: Math.floor((now - k.createdAt) / MILLISECONDS_PER_DAY),
+                idleDays: Math.floor((now - k.lastAccessed) / MILLISECONDS_PER_DAY),
+                accessCount: k.accessCount,
+            })),
+        });
+        Logger.logInfo(`Found ${keysToEvict.length} keys to evict`);
+        if (keysToEvict.length === 0) {
+            return Promise.resolve({
+                cleanedKeys: [],
+                timeElapsed: Date.now() - startTime,
+                errors: ['No evictable keys found'],
+            });
+        }
+        return this.executeCleanup(keysToEvict).then(({ successfulKeys, failedKeys }) => {
+            cleanedKeys.push(...successfulKeys);
+            console.log(`[StorageManager] Cleanup completed:`, {
+                successfulKeys,
+                failedKeys,
+                totalCleaned: successfulKeys.length,
+                totalFailed: failedKeys.length,
+                timeElapsed: `${Date.now() - startTime}ms`,
+            });
+            if (failedKeys.length > 0) {
+                errors.push(`Failed to clean ${failedKeys.length} keys: ${failedKeys.join(', ')}`);
+            }
+            const successfulKeysSet = new Set(successfulKeys);
+            for (const key of successfulKeysSet) {
+                this.trackKeyRemoval(key);
+            }
+            this.markCleanupPerformed();
+            Logger.logInfo(`Storage cleanup completed: cleaned ${cleanedKeys.length} keys`);
+            return {
+                cleanedKeys,
+                timeElapsed: Date.now() - startTime,
+                errors,
+            };
+        });
+    }
+    shouldEvictKey(keyInfo) {
+        if (!this.config.enabled)
+            return false;
+        const now = Date.now();
+        const daysSinceAccess = (now - keyInfo.lastAccessed) / MILLISECONDS_PER_DAY;
+        const ageInDays = (now - keyInfo.createdAt) / MILLISECONDS_PER_DAY;
+        // Check idle time (most common reason for eviction)
+        if (daysSinceAccess > this.config.maxIdleDays) {
+            return true;
+        }
+        // Check maximum age (evict old keys regardless of usage)
+        if (ageInDays > this.config.maxAgeDays) {
+            return true;
+        }
+        return false;
+    }
+    executeCleanup(keysToEvict) {
+        const successfulKeys = [];
+        const failedKeys = [];
+        const cleanupPromises = keysToEvict.map((keyInfo) => {
+            return storage_1.default.removeItem(keyInfo.key)
+                .then(() => {
+                successfulKeys.push(keyInfo.key);
+            })
+                .catch((error) => {
+                Logger.logInfo(`Failed to remove key ${keyInfo.key}: ${error}`);
+                failedKeys.push(keyInfo.key);
+            });
+        });
+        return Promise.all(cleanupPromises).then(() => ({ successfulKeys, failedKeys }));
+    }
+}
+exports.StorageManager = StorageManager;
+let storageManagerInstance = null;
+function createStorageManager(config = {}) {
+    if (config === false) {
+        return null;
+    }
+    if (storageManagerInstance) {
+        storageManagerInstance.shutdown();
+    }
+    storageManagerInstance = new StorageManager(config);
+    return storageManagerInstance;
+}
+exports.createStorageManager = createStorageManager;
+function getStorageManager() {
+    return storageManagerInstance;
+}
+exports.getStorageManager = getStorageManager;
+function cleanupStorageManager() {
+    if (!storageManagerInstance) {
+        return;
+    }
+    storageManagerInstance.shutdown();
+    storageManagerInstance = null;
+}
+exports.cleanupStorageManager = cleanupStorageManager;
diff --git a/node_modules/react-native-onyx/dist/storage-eviction/types.d.ts b/node_modules/react-native-onyx/dist/storage-eviction/types.d.ts
new file mode 100644
index 0000000..dc9a852
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/storage-eviction/types.d.ts
@@ -0,0 +1,25 @@
+import type { OnyxKey } from '../types';
+interface StorageUsageConfig {
+    enabled: boolean;
+    accessTrackingEnabled: boolean;
+    cleanupInterval: number;
+    maxIdleDays: number;
+    maxAgeDays: number;
+    evictableKeys: string[];
+}
+interface StorageKeyInfo {
+    key: OnyxKey;
+    lastAccessed: number;
+    accessCount: number;
+    createdAt: number;
+    isEvictable: boolean;
+}
+interface StorageMetadata {
+    lastAccessed: number;
+    accessCount: number;
+    createdAt: number;
+    version: number;
+}
+declare const DEFAULT_STORAGE_CONFIG: StorageUsageConfig;
+export type { StorageUsageConfig, StorageKeyInfo, StorageMetadata };
+export { DEFAULT_STORAGE_CONFIG };
diff --git a/node_modules/react-native-onyx/dist/storage-eviction/types.js b/node_modules/react-native-onyx/dist/storage-eviction/types.js
new file mode 100644
index 0000000..27c4e66
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/storage-eviction/types.js
@@ -0,0 +1,12 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DEFAULT_STORAGE_CONFIG = void 0;
+const DEFAULT_STORAGE_CONFIG = {
+    enabled: true, // Storage eviction is enabled by default
+    accessTrackingEnabled: true,
+    cleanupInterval: 5 * 60 * 1000, // 5 minutes
+    maxIdleDays: 7, // Evict keys unused for 7 days
+    maxAgeDays: 30, // Evict keys older than 30 days regardless of usage
+    evictableKeys: [],
+};
+exports.DEFAULT_STORAGE_CONFIG = DEFAULT_STORAGE_CONFIG;
diff --git a/node_modules/react-native-onyx/dist/storage/providers/IDBKeyValProvider.d.ts b/node_modules/react-native-onyx/dist/storage/providers/IDBKeyValProvider.d.ts
new file mode 100644
index 0000000..e1e8344
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/storage/providers/IDBKeyValProvider.d.ts
@@ -0,0 +1,3 @@
+import type StorageProvider from './types';
+declare const provider: StorageProvider;
+export default provider;
diff --git a/node_modules/react-native-onyx/dist/storage/providers/IDBKeyValProvider.js b/node_modules/react-native-onyx/dist/storage/providers/IDBKeyValProvider.js
new file mode 100644
index 0000000..191188b
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/storage/providers/IDBKeyValProvider.js
@@ -0,0 +1,94 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const idb_keyval_1 = require("idb-keyval");
+const utils_1 = __importDefault(require("../../utils"));
+// We don't want to initialize the store while the JS bundle loads as idb-keyval will try to use global.indexedDB
+// which might not be available in certain environments that load the bundle (e.g. electron main process).
+let idbKeyValStore;
+const provider = {
+    /**
+     * The name of the provider that can be printed to the logs
+     */
+    name: 'IDBKeyValProvider',
+    /**
+     * Initializes the storage provider
+     */
+    init() {
+        const newIdbKeyValStore = (0, idb_keyval_1.createStore)('OnyxDB', 'keyvaluepairs');
+        if (newIdbKeyValStore == null)
+            throw Error('IDBKeyVal store could not be created');
+        idbKeyValStore = newIdbKeyValStore;
+    },
+    setItem: (key, value) => {
+        if (value === null) {
+            provider.removeItem(key);
+        }
+        return (0, idb_keyval_1.set)(key, value, idbKeyValStore);
+    },
+    multiGet: (keysParam) => (0, idb_keyval_1.getMany)(keysParam, idbKeyValStore).then((values) => values.map((value, index) => [keysParam[index], value])),
+    multiMerge: (pairs) => idbKeyValStore('readwrite', (store) => {
+        // Note: we are using the manual store transaction here, to fit the read and update
+        // of the items in one transaction to achieve best performance.
+        const getValues = Promise.all(pairs.map(([key]) => (0, idb_keyval_1.promisifyRequest)(store.get(key))));
+        return getValues.then((values) => {
+            const pairsWithoutNull = pairs.filter(([key, value]) => {
+                if (value === null) {
+                    provider.removeItem(key);
+                    return false;
+                }
+                return true;
+            });
+            const upsertMany = pairsWithoutNull.map(([key, value], index) => {
+                const prev = values[index];
+                const newValue = utils_1.default.fastMerge(prev, value, {
+                    shouldRemoveNestedNulls: true,
+                    objectRemovalMode: 'replace',
+                }).result;
+                return (0, idb_keyval_1.promisifyRequest)(store.put(newValue, key));
+            });
+            return Promise.all(upsertMany).then(() => undefined);
+        });
+    }),
+    mergeItem(key, change) {
+        // Since Onyx already merged the existing value with the changes, we can just set the value directly.
+        return provider.multiMerge([[key, change]]);
+    },
+    multiSet: (pairs) => {
+        const pairsWithoutNull = pairs.filter(([key, value]) => {
+            if (value === null) {
+                provider.removeItem(key);
+                return false;
+            }
+            return true;
+        });
+        return (0, idb_keyval_1.setMany)(pairsWithoutNull, idbKeyValStore);
+    },
+    clear: () => (0, idb_keyval_1.clear)(idbKeyValStore),
+    getAllKeys: () => (0, idb_keyval_1.keys)(idbKeyValStore),
+    getItem: (key) => (0, idb_keyval_1.get)(key, idbKeyValStore)
+        // idb-keyval returns undefined for missing items, but this needs to return null so that idb-keyval does the same thing as SQLiteStorage.
+        .then((val) => (val === undefined ? null : val)),
+    removeItem: (key) => (0, idb_keyval_1.del)(key, idbKeyValStore),
+    removeItems: (keysParam) => (0, idb_keyval_1.delMany)(keysParam, idbKeyValStore),
+    getDatabaseSize() {
+        if (!window.navigator || !window.navigator.storage) {
+            throw new Error('StorageManager browser API unavailable');
+        }
+        return window.navigator.storage
+            .estimate()
+            .then((value) => {
+            var _a, _b, _c;
+            return ({
+                bytesUsed: (_a = value.usage) !== null && _a !== void 0 ? _a : 0,
+                bytesRemaining: ((_b = value.quota) !== null && _b !== void 0 ? _b : 0) - ((_c = value.usage) !== null && _c !== void 0 ? _c : 0),
+            });
+        })
+            .catch((error) => {
+            throw new Error(`Unable to estimate web storage quota. Original error: ${error}`);
+        });
+    },
+};
+exports.default = provider;
diff --git a/node_modules/react-native-onyx/dist/structuralSharing.d.ts b/node_modules/react-native-onyx/dist/structuralSharing.d.ts
new file mode 100644
index 0000000..4f41c1e
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/structuralSharing.d.ts
@@ -0,0 +1,77 @@
+/**
+ * Structural sharing utilities for efficient immutable data updates.
+ *
+ * This module provides functions for updating nested data structures while
+ * preserving references to unchanged parts, reducing memory usage and
+ * enabling fast equality checks.
+ *
+ * Based on the concepts from: https://blog.klipse.tech/javascript/2021/02/26/structural-sharing-in-javascript.html
+ */
+type Path = (string | number)[];
+type UpdateFunction<T> = (value: T) => T;
+/**
+ * Sets a value at the given path in an object, using structural sharing.
+ * Only creates new objects for the parts of the structure that actually change.
+ *
+ * @param obj - The source object
+ * @param path - Array of keys/indices defining the path to update
+ * @param value - The new value to set
+ * @returns New object with the updated value, sharing structure where unchanged
+ */
+declare function setIn<T>(obj: T, path: Path, value: unknown): T;
+/**
+ * Updates a value at the given path using an update function.
+ * Uses structural sharing to preserve unchanged parts.
+ *
+ * @param obj - The source object
+ * @param path - Array of keys/indices defining the path to update
+ * @param updater - Function that receives the current value and returns the new value
+ * @returns New object with the updated value, sharing structure where unchanged
+ */
+declare function updateIn<T>(obj: T, path: Path, updater: UpdateFunction<unknown>): T;
+/**
+ * Gets a value at the given path in an object.
+ *
+ * @param obj - The source object
+ * @param path - Array of keys/indices defining the path to get
+ * @returns The value at the path, or undefined if not found
+ */
+declare function getIn(obj: unknown, path: Path): unknown;
+/**
+ * Merges two objects using structural sharing.
+ * Only creates new objects where values actually differ.
+ *
+ * @param target - The target object to merge into
+ * @param source - The source object to merge from
+ * @returns New merged object with structural sharing
+ */
+declare function mergeWithSharing<T>(target: T, source: Partial<T>): T;
+/**
+ * Creates a version of an object with structural sharing enabled.
+ * This wraps the object with metadata to track sharing.
+ *
+ * @param obj - The object to enable sharing for
+ * @returns The same object (structural sharing is transparent)
+ */
+declare function enableSharing<T>(obj: T): T;
+/**
+ * Checks if two values are referentially equal (fast equality check).
+ * This is the main benefit of structural sharing - fast change detection.
+ *
+ * @param a - First value
+ * @param b - Second value
+ * @returns true if values are referentially equal
+ */
+declare function isEqual(a: unknown, b: unknown): boolean;
+/**
+ * Optimized merge function for Onyx that uses structural sharing principles.
+ * This replaces the current fastMerge in scenarios where we want to preserve
+ * object references for unchanged parts.
+ *
+ * @param target - Target object to merge into
+ * @param source - Source object to merge from
+ * @returns Merged object with structural sharing
+ */
+declare function onyxMergeWithSharing<T>(target: T, source: T): T;
+export { setIn, updateIn, getIn, mergeWithSharing, enableSharing, isEqual, onyxMergeWithSharing, };
+export type { Path, UpdateFunction, };
diff --git a/node_modules/react-native-onyx/dist/structuralSharing.js b/node_modules/react-native-onyx/dist/structuralSharing.js
new file mode 100644
index 0000000..b237cc9
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/structuralSharing.js
@@ -0,0 +1,234 @@
+"use strict";
+/**
+ * Structural sharing utilities for efficient immutable data updates.
+ *
+ * This module provides functions for updating nested data structures while
+ * preserving references to unchanged parts, reducing memory usage and
+ * enabling fast equality checks.
+ *
+ * Based on the concepts from: https://blog.klipse.tech/javascript/2021/02/26/structural-sharing-in-javascript.html
+ */
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.setIn = setIn;
+exports.updateIn = updateIn;
+exports.getIn = getIn;
+exports.mergeWithSharing = mergeWithSharing;
+exports.enableSharing = enableSharing;
+exports.isEqual = isEqual;
+exports.onyxMergeWithSharing = onyxMergeWithSharing;
+/**
+ * Sets a value at the given path in an object, using structural sharing.
+ * Only creates new objects for the parts of the structure that actually change.
+ *
+ * @param obj - The source object
+ * @param path - Array of keys/indices defining the path to update
+ * @param value - The new value to set
+ * @returns New object with the updated value, sharing structure where unchanged
+ */
+function setIn(obj, path, value) {
+    if (path.length === 0) {
+        return value;
+    }
+    if (obj === null || obj === undefined) {
+        // Create new object structure from scratch
+        return setIn({}, path, value);
+    }
+    const [key, ...restPath] = path;
+    if (Array.isArray(obj)) {
+        const index = Number(key);
+        if (restPath.length === 0) {
+            // Base case: setting array element
+            if (obj[index] === value) {
+                return obj; // No change, return original
+            }
+            const newArray = [...obj];
+            newArray[index] = value;
+            return newArray;
+        }
+        // Recursive case: updating nested value in array
+        const newValue = setIn(obj[index], restPath, value);
+        if (obj[index] === newValue) {
+            return obj; // No change in nested structure
+        }
+        const newArray = [...obj];
+        newArray[index] = newValue;
+        return newArray;
+    }
+    if (typeof obj === 'object') {
+        const objRecord = obj;
+        if (restPath.length === 0) {
+            // Base case: setting object property
+            if (objRecord[key] === value) {
+                return obj; // No change, return original
+            }
+            return Object.assign(Object.assign({}, objRecord), { [key]: value });
+        }
+        // Recursive case: updating nested value in object
+        const newValue = setIn(objRecord[key], restPath, value);
+        if (objRecord[key] === newValue) {
+            return obj; // No change in nested structure
+        }
+        return Object.assign(Object.assign({}, objRecord), { [key]: newValue });
+    }
+    // For primitive values, we can't set nested paths
+    throw new Error(`Cannot set path [${path.join('.')}] on primitive value: ${obj}`);
+}
+/**
+ * Updates a value at the given path using an update function.
+ * Uses structural sharing to preserve unchanged parts.
+ *
+ * @param obj - The source object
+ * @param path - Array of keys/indices defining the path to update
+ * @param updater - Function that receives the current value and returns the new value
+ * @returns New object with the updated value, sharing structure where unchanged
+ */
+function updateIn(obj, path, updater) {
+    if (path.length === 0) {
+        const newValue = updater(obj);
+        return newValue === obj ? obj : newValue;
+    }
+    const currentValue = getIn(obj, path);
+    const newValue = updater(currentValue);
+    if (currentValue === newValue) {
+        return obj; // No change
+    }
+    return setIn(obj, path, newValue);
+}
+/**
+ * Gets a value at the given path in an object.
+ *
+ * @param obj - The source object
+ * @param path - Array of keys/indices defining the path to get
+ * @returns The value at the path, or undefined if not found
+ */
+function getIn(obj, path) {
+    if (path.length === 0) {
+        return obj;
+    }
+    if (obj === null || obj === undefined) {
+        return undefined;
+    }
+    const [key, ...restPath] = path;
+    if (Array.isArray(obj)) {
+        const index = Number(key);
+        return getIn(obj[index], restPath);
+    }
+    if (typeof obj === 'object') {
+        const objRecord = obj;
+        return getIn(objRecord[key], restPath);
+    }
+    return undefined;
+}
+/**
+ * Merges two objects using structural sharing.
+ * Only creates new objects where values actually differ.
+ *
+ * @param target - The target object to merge into
+ * @param source - The source object to merge from
+ * @returns New merged object with structural sharing
+ */
+function mergeWithSharing(target, source) {
+    if (source === null || source === undefined) {
+        return target;
+    }
+    if (target === null || target === undefined) {
+        return source;
+    }
+    // For non-objects, just return the source
+    if (typeof target !== 'object' || typeof source !== 'object') {
+        return source;
+    }
+    // Handle arrays - replace entirely for simplicity
+    if (Array.isArray(source)) {
+        return source;
+    }
+    if (!Array.isArray(target) && !Array.isArray(source)) {
+        const targetRecord = target;
+        const sourceRecord = source;
+        let hasChanges = false;
+        const result = {};
+        // Copy all target properties first
+        for (const key in targetRecord) {
+            if (Object.prototype.hasOwnProperty.call(targetRecord, key)) {
+                result[key] = targetRecord[key];
+            }
+        }
+        // Merge source properties
+        for (const key in sourceRecord) {
+            if (Object.prototype.hasOwnProperty.call(sourceRecord, key)) {
+                const sourceValue = sourceRecord[key];
+                const targetValue = targetRecord[key];
+                if (sourceValue === null) {
+                    // Remove property
+                    if (key in targetRecord) {
+                        delete result[key];
+                        hasChanges = true;
+                    }
+                }
+                else if (typeof sourceValue === 'object' && typeof targetValue === 'object' &&
+                    !Array.isArray(sourceValue) && !Array.isArray(targetValue)) {
+                    // Recursively merge objects
+                    const merged = mergeWithSharing(targetValue, sourceValue);
+                    if (merged !== targetValue) {
+                        result[key] = merged;
+                        hasChanges = true;
+                    }
+                }
+                else if (sourceValue !== targetValue) {
+                    // Direct assignment for different values
+                    result[key] = sourceValue;
+                    hasChanges = true;
+                }
+            }
+        }
+        return hasChanges ? result : target;
+    }
+    return source;
+}
+/**
+ * Creates a version of an object with structural sharing enabled.
+ * This wraps the object with metadata to track sharing.
+ *
+ * @param obj - The object to enable sharing for
+ * @returns The same object (structural sharing is transparent)
+ */
+function enableSharing(obj) {
+    // In this implementation, structural sharing is transparent
+    // We don't need to wrap objects, just use the sharing functions
+    return obj;
+}
+/**
+ * Checks if two values are referentially equal (fast equality check).
+ * This is the main benefit of structural sharing - fast change detection.
+ *
+ * @param a - First value
+ * @param b - Second value
+ * @returns true if values are referentially equal
+ */
+function isEqual(a, b) {
+    return a === b;
+}
+/**
+ * Optimized merge function for Onyx that uses structural sharing principles.
+ * This replaces the current fastMerge in scenarios where we want to preserve
+ * object references for unchanged parts.
+ *
+ * @param target - Target object to merge into
+ * @param source - Source object to merge from
+ * @returns Merged object with structural sharing
+ */
+function onyxMergeWithSharing(target, source) {
+    // Handle null/undefined cases
+    if (source === null || source === undefined) {
+        return target;
+    }
+    if (target === null || target === undefined) {
+        return source;
+    }
+    // For primitive values or arrays, replace entirely
+    if (typeof target !== 'object' || Array.isArray(source)) {
+        return source;
+    }
+    // Use our structural sharing merge
+    return mergeWithSharing(target, source);
+}
diff --git a/node_modules/react-native-onyx/dist/types.d.ts b/node_modules/react-native-onyx/dist/types.d.ts
index ffa23f7..07ff251 100644
--- a/node_modules/react-native-onyx/dist/types.d.ts
+++ b/node_modules/react-native-onyx/dist/types.d.ts
@@ -337,6 +337,12 @@ type InitOptions = {
      * @default false
      */
     enablePerformanceMetrics?: boolean;
+    /**
+     * If enabled, it will connect to Redux DevTools Extension for debugging.
+     * This allows you to see all Onyx state changes in the Redux DevTools.
+     * @default true
+     */
+    enableDevTools?: boolean;
     /**
      * Array of collection member IDs which updates will be ignored when using Onyx methods.
      * Additionally, any subscribers from these keys to won't receive any data from Onyx.
diff --git a/node_modules/react-native-onyx/dist/useBatchedOnyx.d.ts b/node_modules/react-native-onyx/dist/useBatchedOnyx.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useBatchedOnyx.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/react-native-onyx/dist/useBatchedOnyx.js b/node_modules/react-native-onyx/dist/useBatchedOnyx.js
new file mode 100644
index 0000000..7ec5754
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useBatchedOnyx.js
@@ -0,0 +1,48 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const react_1 = require("react");
+nimport;
+type;
+{
+    DependencyList;
+}
+from;
+'react';
+nimport;
+type;
+{
+    OnyxKey, OnyxValue;
+}
+from;
+'./types';
+nimport;
+useOnyx;
+from;
+'./useOnyx';
+nimport;
+type;
+{
+    UseOnyxOptions, UseOnyxResult;
+}
+from;
+'./useOnyx';
+n;
+ntype;
+BatchedOnyxRequest < TKey;
+OnyxKey, TReturnValue = OnyxValue < TKey >> ;
+{
+    n;
+    key: TKey;
+    n;
+    options ?  : UseOnyxOptions;
+    n;
+}
+;
+n;
+ntype;
+(BatchedOnyxResults) = { n, [K in keyof]: T, T, [K]: , extends: (BatchedOnyxRequest) ? UseOnyxResult : never, n };
+n;
+n; /**\n * Hook for batching multiple useOnyx calls to improve performance when you have many connections.\n * This is especially useful when opening screens with hundreds of useOnyx hooks.\n * \n * Instead of creating all connections immediately, this hook creates them in small batches\n * over multiple frames to avoid blocking the main thread.\n * \n * @param requests Array of useOnyx requests to batch\n * @param dependencies Dependency array for when to recreate the batch\n * @param batchSize Number of connections to create per batch (default: 20)\n * @returns Array of useOnyx results in the same order as requests\n */
+nfunction;
+useBatchedOnyx(n, requests, T, n, dependencies, DependencyList = [], n, batchSize, number = 20, n);
+BatchedOnyxResults < T > { n, const: [currentBatch, setCurrentBatch] = React.useState(0), n, const: batchTimerRef = (0, react_1.useRef)(null), n, const: totalBatches = Math.ceil(requests.length / batchSize), n, n }; // Reset batching when dependencies change\n    useEffect(() => {\n        setCurrentBatch(0);\n        if (batchTimerRef.current) {\n            clearTimeout(batchTimerRef.current);\n        }\n    }, dependencies);\n    \n    // Schedule next batch\n    useEffect(() => {\n        if (currentBatch < totalBatches - 1) {\n            batchTimerRef.current = setTimeout(() => {\n                setCurrentBatch(prev => prev + 1);\n            }, 16); // One frame delay\n        }\n        \n        return () => {\n            if (batchTimerRef.current) {\n                clearTimeout(batchTimerRef.current);\n            }\n        };\n    }, [currentBatch, totalBatches]);\n    \n    // Create hooks for current batches\n    const results = useMemo(() => {\n        const activeRequests = requests.slice(0, (currentBatch + 1) * batchSize);\n        const results: any[] = new Array(requests.length);\n        \n        // Fill in results for active requests\n        activeRequests.forEach((request, index) => {\n            results[index] = {\n                key: request.key,\n                options: request.options\n            };\n        });\n        \n        return results;\n    }, [requests, currentBatch, batchSize]);\n    \n    // This is a simplified version - in practice you'd need to carefully manage\n    // the individual useOnyx hooks to avoid React rules violations\n    return results as BatchedOnyxResults<T>;\n}\n\n/**\n * Alternative approach: Pre-warm connections for keys you know you'll need\n * This creates connections early but doesn't return data until you actually need it\n */\nfunction useOnyxPrewarm(keys: OnyxKey[]): void {\n    const connectionsRef = useRef<Set<OnyxKey>>(new Set());\n    \n    useEffect(() => {\n        // Create connections for keys we haven't seen before\n        keys.forEach(key => {\n            if (!connectionsRef.current.has(key)) {\n                connectionsRef.current.add(key);\n                // Pre-create connection by calling useOnyx with minimal options\n                // This warms up the connection for later use\n            }\n        });\n    }, [keys]);\n}\n\nexport {useBatchedOnyx, useOnyxPrewarm};\nexport type {BatchedOnyxRequest, BatchedOnyxResults};
diff --git a/node_modules/react-native-onyx/dist/useOnyx-optimized.d.ts b/node_modules/react-native-onyx/dist/useOnyx-optimized.d.ts
new file mode 100644
index 0000000..403e61d
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx-optimized.d.ts
@@ -0,0 +1,21 @@
+import type { DependencyList } from 'react';
+import type { OnyxKey, OnyxValue } from './types';
+type UseOnyxSelector<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>> = (data: OnyxValue<TKey> | undefined) => TReturnValue;
+type UseOnyxOptions<TKey extends OnyxKey, TReturnValue> = {
+    canEvict?: boolean;
+    initWithStoredValues?: boolean;
+    allowStaleData?: boolean;
+    reuseConnection?: boolean;
+    allowDynamicKey?: boolean;
+    canBeMissing?: boolean;
+    selector?: UseOnyxSelector<TKey, TReturnValue>;
+};
+type FetchStatus = 'loading' | 'loaded';
+type ResultMetadata<TValue> = {
+    status: FetchStatus;
+    sourceValue?: NonNullable<TValue> | undefined;
+};
+type UseOnyxResult<TValue> = [NonNullable<TValue> | undefined, ResultMetadata<TValue>];
+declare function useOnyx<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>>(key: TKey, options?: UseOnyxOptions<TKey, TReturnValue>, dependencies?: DependencyList): UseOnyxResult<TReturnValue>;
+export default useOnyx;
+export type { FetchStatus, ResultMetadata, UseOnyxResult, UseOnyxOptions };
diff --git a/node_modules/react-native-onyx/dist/useOnyx-optimized.js b/node_modules/react-native-onyx/dist/useOnyx-optimized.js
new file mode 100644
index 0000000..9e598e4
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx-optimized.js
@@ -0,0 +1,169 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const fast_equals_1 = require("fast-equals");
+const react_1 = require("react");
+const OnyxCache_1 = __importStar(require("./OnyxCache"));
+const OnyxConnectionManager_1 = __importDefault(require("./OnyxConnectionManager"));
+const OnyxUtils_1 = __importDefault(require("./OnyxUtils"));
+const Logger = __importStar(require("./Logger"));
+// Optimized selector cache - single WeakMap for all selectors
+const selectorCache = new WeakMap();
+function createMemoizedSelector(selector) {
+    let cache = selectorCache.get(selector);
+    if (!cache) {
+        cache = new Map();
+        selectorCache.set(selector, cache);
+    }
+    return (input) => {
+        if (cache.has(input)) {
+            return cache.get(input);
+        }
+        const result = selector(input);
+        cache.set(input, result);
+        return result;
+    };
+}
+function useOnyx(key, options, dependencies = []) {
+    var _a;
+    // Single state object to minimize refs
+    const stateRef = (0, react_1.useRef)({
+        connection: null,
+        previousKey: key,
+        currentValue: undefined,
+        sourceValue: undefined,
+        isFirstConnection: true,
+        isConnecting: false,
+        onStoreChange: null,
+        memoizedSelector: (options === null || options === void 0 ? void 0 : options.selector) ? createMemoizedSelector(options.selector) : null,
+        dependencyHash: JSON.stringify(dependencies), // Simple hash for deps
+    });
+    const state = stateRef.current;
+    // Update memoized selector only when selector changes
+    if ((options === null || options === void 0 ? void 0 : options.selector) !== ((_a = state.memoizedSelector) === null || _a === void 0 ? void 0 : _a.__original)) {
+        state.memoizedSelector = (options === null || options === void 0 ? void 0 : options.selector) ? createMemoizedSelector(options.selector) : null;
+        if (state.memoizedSelector) {
+            state.memoizedSelector.__original = options.selector;
+        }
+    }
+    // Handle key changes efficiently
+    if (state.previousKey !== key && !(options === null || options === void 0 ? void 0 : options.allowDynamicKey)) {
+        if (!OnyxUtils_1.default.isCollectionMemberKey(state.previousKey, state.previousKey) ||
+            !OnyxUtils_1.default.isCollectionMemberKey(key, key) ||
+            OnyxUtils_1.default.splitCollectionMemberKey(state.previousKey)[0] !== OnyxUtils_1.default.splitCollectionMemberKey(key)[0]) {
+            throw new Error(`Key cannot be changed from '${state.previousKey}' to '${key}' without allowDynamicKey`);
+        }
+        state.previousKey = key;
+    }
+    const getSnapshot = (0, react_1.useCallback)(() => {
+        // Fast path: return immediately if initWithStoredValues is false on first connection
+        if (state.isFirstConnection && (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false) {
+            return [undefined, { status: 'loaded' }];
+        }
+        // Get value from cache
+        const rawValue = OnyxUtils_1.default.tryGetCachedValue(key);
+        const selectedValue = state.memoizedSelector
+            ? state.memoizedSelector(rawValue)
+            : rawValue;
+        const normalizedValue = (selectedValue !== null && selectedValue !== void 0 ? selectedValue : undefined);
+        // Handle pending merges
+        const shouldShowLoading = state.isFirstConnection &&
+            OnyxUtils_1.default.hasPendingMergeForKey(key) &&
+            !(options === null || options === void 0 ? void 0 : options.allowStaleData);
+        const finalValue = shouldShowLoading ? undefined : normalizedValue;
+        const status = shouldShowLoading ? 'loading' : 'loaded';
+        // Optimized equality check
+        const hasChanged = state.memoizedSelector
+            ? state.currentValue !== finalValue // Reference equality for memoized selectors
+            : !(0, fast_equals_1.shallowEqual)(state.currentValue, finalValue);
+        if (hasChanged || state.currentValue === null) {
+            state.currentValue = finalValue;
+            // Log missing data warning
+            if ((options === null || options === void 0 ? void 0 : options.canBeMissing) === false &&
+                status === 'loaded' &&
+                rawValue == null &&
+                !OnyxCache_1.default.hasPendingTask(OnyxCache_1.TASK.CLEAR)) {
+                Logger.logAlert(`useOnyx: missing data for key ${key}`, { showAlert: true });
+            }
+        }
+        return [
+            state.currentValue,
+            {
+                status,
+                sourceValue: state.sourceValue,
+            }
+        ];
+    }, [key, options === null || options === void 0 ? void 0 : options.initWithStoredValues, options === null || options === void 0 ? void 0 : options.allowStaleData, options === null || options === void 0 ? void 0 : options.canBeMissing]);
+    const subscribe = (0, react_1.useCallback)((onStoreChange) => {
+        state.isConnecting = true;
+        state.onStoreChange = onStoreChange;
+        state.connection = OnyxConnectionManager_1.default.connect({
+            key,
+            callback: (value, callbackKey, sourceValue) => {
+                state.isConnecting = false;
+                state.isFirstConnection = false;
+                state.sourceValue = sourceValue;
+                onStoreChange();
+            },
+            initWithStoredValues: options === null || options === void 0 ? void 0 : options.initWithStoredValues,
+            waitForCollectionCallback: OnyxUtils_1.default.isCollectionKey(key),
+            reuseConnection: options === null || options === void 0 ? void 0 : options.reuseConnection,
+        });
+        // Handle eviction
+        if ((options === null || options === void 0 ? void 0 : options.canEvict) !== undefined && OnyxCache_1.default.isEvictableKey(key)) {
+            if (options.canEvict) {
+                OnyxConnectionManager_1.default.removeFromEvictionBlockList(state.connection);
+            }
+            else {
+                OnyxConnectionManager_1.default.addToEvictionBlockList(state.connection);
+            }
+        }
+        return () => {
+            if (state.connection) {
+                OnyxConnectionManager_1.default.disconnect(state.connection);
+                state.connection = null;
+                state.isFirstConnection = false;
+                state.isConnecting = false;
+                state.onStoreChange = null;
+            }
+        };
+    }, [key, options === null || options === void 0 ? void 0 : options.initWithStoredValues, options === null || options === void 0 ? void 0 : options.reuseConnection, options === null || options === void 0 ? void 0 : options.canEvict]);
+    // Handle dependency changes efficiently
+    const currentDepHash = JSON.stringify(dependencies);
+    if (state.dependencyHash !== currentDepHash && state.onStoreChange && !state.isConnecting) {
+        state.dependencyHash = currentDepHash;
+        // Trigger update on next tick to avoid issues during render
+        Promise.resolve().then(() => {
+            if (state.onStoreChange) {
+                state.onStoreChange();
+            }
+        });
+    }
+    return (0, react_1.useSyncExternalStore)(subscribe, getSnapshot);
+}
+exports.default = useOnyx;
diff --git a/node_modules/react-native-onyx/dist/useOnyx/SnapshotCache.d.ts b/node_modules/react-native-onyx/dist/useOnyx/SnapshotCache.d.ts
new file mode 100644
index 0000000..67538fe
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx/SnapshotCache.d.ts
@@ -0,0 +1,90 @@
+import type { UseOnyxSelector } from '.';
+import type { OnyxKey } from '../types';
+/**
+ * Global snapshot cache for ultimate performance - separate cache per Onyx key
+ * This cache stores computed getSnapshot results to avoid redundant computations
+ * across multiple useOnyx instances with identical configurations.
+ */
+declare class SnapshotCache {
+    private cache;
+    private selectorIdMap;
+    private selectorCounter;
+    /**
+     * Generate unique ID for selector functions based on their string representation
+     */
+    private getSelectorId;
+    /**
+     * Simple hash function for input data
+     */
+    private hashInput;
+    /**
+     * Fast cache key generation for selector/options combination
+     * For selectors, we cache based on selector function + input data hash for better sharing
+     */
+    generateCacheKey<TKey extends OnyxKey, TReturnValue>(options?: {
+        selector?: UseOnyxSelector<any, any>;
+        initWithStoredValues?: boolean;
+        allowStaleData?: boolean;
+        canBeMissing?: boolean;
+    }, memoizedSelector?: ((input: any) => TReturnValue) | null, hookInstanceId?: string, inputData?: any): string;
+    /**
+     * Get cached result for a specific key and cache key combination
+     */
+    get(onyxKey: string, cacheKey: string): any;
+    /**
+     * Set cached result for a specific key and cache key combination
+     */
+    set(onyxKey: string, cacheKey: string, result: any): void;
+    /**
+     * Check if there's a cached result for a specific key and cache key combination
+     */
+    has(onyxKey: string, cacheKey: string): boolean;
+    /**
+     * O(1) cache invalidation - delete the entire cache for this key
+     */
+    invalidateKey(onyxKey: string): void;
+    /**
+     * Clear all caches (useful for testing)
+     */
+    clear(): void;
+    /**
+     * Clear selector ID map (useful for testing)
+     */
+    clearSelectorIds(): void;
+    /**
+     * Log current cache statistics to console
+     */
+    logStats(): void;
+    private hits;
+    private misses;
+    private skips;
+    /**
+     * Record cache hit
+     */
+    recordHit(): void;
+    /**
+     * Record cache miss
+     */
+    recordMiss(): void;
+    /**
+     * Record cache skip (when cache is intentionally bypassed)
+     */
+    recordSkip(): void;
+    /**
+     * Get cache statistics for debugging
+     */
+    getStats(): {
+        totalKeys: number;
+        totalEntries: number;
+        hits: number;
+        misses: number;
+        skips: number;
+        hitRate: string;
+    };
+    /**
+     * Reset cache statistics
+     */
+    resetStats(): void;
+}
+declare const _default: SnapshotCache;
+export default _default;
diff --git a/node_modules/react-native-onyx/dist/useOnyx/SnapshotCache.js b/node_modules/react-native-onyx/dist/useOnyx/SnapshotCache.js
new file mode 100644
index 0000000..c044ea4
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx/SnapshotCache.js
@@ -0,0 +1,184 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+/**
+ * Global snapshot cache for ultimate performance - separate cache per Onyx key
+ * This cache stores computed getSnapshot results to avoid redundant computations
+ * across multiple useOnyx instances with identical configurations.
+ */
+class SnapshotCache {
+    constructor() {
+        this.cache = new Map();
+        this.selectorIdMap = new Map();
+        this.selectorCounter = 0;
+        this.hits = 0;
+        this.misses = 0;
+        this.skips = 0;
+    }
+    /**
+     * Generate unique ID for selector functions based on their string representation
+     */
+    getSelectorId(selector) {
+        if (!this.selectorIdMap.has(selector)) {
+            // Use function string representation for consistent IDs across identical selectors
+            const selectorString = selector.toString();
+            this.selectorIdMap.set(selector, `selector_${selectorString.length}_${selectorString.slice(0, 50)}`);
+        }
+        return this.selectorIdMap.get(selector);
+    }
+    /**
+     * Simple hash function for input data
+     */
+    hashInput(input) {
+        if (input === null || input === undefined) {
+            return 'null';
+        }
+        if (typeof input === 'string' || typeof input === 'number' || typeof input === 'boolean') {
+            return String(input);
+        }
+        // For objects, create a simple hash based on JSON representation
+        try {
+            const str = JSON.stringify(input);
+            let hash = 0;
+            for (let i = 0; i < str.length; i++) {
+                const char = str.charCodeAt(i);
+                hash = (hash << 5) - hash + char;
+                hash = hash & hash; // Convert to 32-bit integer
+            }
+            return Math.abs(hash).toString(36);
+        }
+        catch (_a) {
+            return 'unhashable';
+        }
+    }
+    /**
+     * Fast cache key generation for selector/options combination
+     * For selectors, we cache based on selector function + input data hash for better sharing
+     */
+    generateCacheKey(options, memoizedSelector, hookInstanceId, inputData) {
+        var _a, _b, _c;
+        // For selectors, use selector function + input data hash for optimal sharing
+        let selectorId;
+        if ((options === null || options === void 0 ? void 0 : options.selector) && inputData !== undefined) {
+            const baseSelectorId = this.getSelectorId(options.selector);
+            const inputHash = this.hashInput(inputData);
+            selectorId = `selector_${baseSelectorId}_${inputHash}`;
+        }
+        else if (options === null || options === void 0 ? void 0 : options.selector) {
+            selectorId = this.getSelectorId(options.selector);
+        }
+        else {
+            selectorId = 'no_selector';
+        }
+        // Create options hash without expensive JSON.stringify
+        const initWithStoredValues = (_a = options === null || options === void 0 ? void 0 : options.initWithStoredValues) !== null && _a !== void 0 ? _a : true;
+        const allowStaleData = (_b = options === null || options === void 0 ? void 0 : options.allowStaleData) !== null && _b !== void 0 ? _b : false;
+        const canBeMissing = (_c = options === null || options === void 0 ? void 0 : options.canBeMissing) !== null && _c !== void 0 ? _c : true;
+        return `${selectorId}_${initWithStoredValues}_${allowStaleData}_${canBeMissing}`;
+    }
+    /**
+     * Get cached result for a specific key and cache key combination
+     */
+    get(onyxKey, cacheKey) {
+        const keyCache = this.cache.get(onyxKey);
+        if (keyCache) {
+            return keyCache.get(cacheKey);
+        }
+        return undefined;
+    }
+    /**
+     * Set cached result for a specific key and cache key combination
+     */
+    set(onyxKey, cacheKey, result) {
+        if (!this.cache.has(onyxKey)) {
+            this.cache.set(onyxKey, new Map());
+        }
+        this.cache.get(onyxKey).set(cacheKey, result);
+    }
+    /**
+     * Check if there's a cached result for a specific key and cache key combination
+     */
+    has(onyxKey, cacheKey) {
+        const keyCache = this.cache.get(onyxKey);
+        return keyCache ? keyCache.has(cacheKey) : false;
+    }
+    /**
+     * O(1) cache invalidation - delete the entire cache for this key
+     */
+    invalidateKey(onyxKey) {
+        this.cache.delete(onyxKey);
+    }
+    /**
+     * Clear all caches (useful for testing)
+     */
+    clear() {
+        this.cache.clear();
+    }
+    /**
+     * Clear selector ID map (useful for testing)
+     */
+    clearSelectorIds() {
+        this.selectorIdMap.clear();
+        this.selectorCounter = 0;
+    }
+    /**
+     * Log current cache statistics to console
+     */
+    logStats() {
+        const stats = this.getStats();
+        console.log('📊 SnapshotCache Stats:', {
+            'Cache Entries': `${stats.totalEntries} across ${stats.totalKeys} keys`,
+            'Hit Rate': stats.hitRate,
+            Hits: stats.hits,
+            Misses: stats.misses,
+            Skips: stats.skips,
+            'Total Calls': stats.hits + stats.misses + stats.skips,
+        });
+    }
+    /**
+     * Record cache hit
+     */
+    recordHit() {
+        this.hits++;
+    }
+    /**
+     * Record cache miss
+     */
+    recordMiss() {
+        this.misses++;
+    }
+    /**
+     * Record cache skip (when cache is intentionally bypassed)
+     */
+    recordSkip() {
+        this.skips++;
+    }
+    /**
+     * Get cache statistics for debugging
+     */
+    getStats() {
+        let totalEntries = 0;
+        for (const keyCache of this.cache.values()) {
+            totalEntries += keyCache.size;
+        }
+        const total = this.hits + this.misses;
+        const hitRate = total > 0 ? ((this.hits / total) * 100).toFixed(1) + '%' : '0%';
+        return {
+            totalKeys: this.cache.size,
+            totalEntries,
+            hits: this.hits,
+            misses: this.misses,
+            skips: this.skips,
+            hitRate,
+        };
+    }
+    /**
+     * Reset cache statistics
+     */
+    resetStats() {
+        this.hits = 0;
+        this.misses = 0;
+        this.skips = 0;
+    }
+}
+// Export singleton instance
+exports.default = new SnapshotCache();
diff --git a/node_modules/react-native-onyx/dist/useOnyx/index.d.ts b/node_modules/react-native-onyx/dist/useOnyx/index.d.ts
new file mode 100644
index 0000000..4897f50
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx/index.d.ts
@@ -0,0 +1,52 @@
+import type { DependencyList } from 'react';
+import type { OnyxKey, OnyxValue } from '../types';
+import SnapshotCache from './SnapshotCache';
+type UseOnyxSelector<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>> = (data: OnyxValue<TKey> | undefined) => TReturnValue;
+type UseOnyxOptions<TKey extends OnyxKey, TReturnValue> = {
+    /**
+     * Determines if this key in this subscription is safe to be evicted.
+     */
+    canEvict?: boolean;
+    /**
+     * If set to `false`, then no data will be prefilled into the component.
+     */
+    initWithStoredValues?: boolean;
+    /**
+     * If set to `true`, data will be retrieved from cache during the first render even if there is a pending merge for the key.
+     */
+    allowStaleData?: boolean;
+    /**
+     * If set to `false`, the connection won't be reused between other subscribers that are listening to the same Onyx key
+     * with the same connect configurations.
+     */
+    reuseConnection?: boolean;
+    /**
+     * If set to `true`, the key can be changed dynamically during the component lifecycle.
+     */
+    allowDynamicKey?: boolean;
+    /**
+     * If the component calling this is the one loading the data by calling an action, then you should set this to `true`.
+     *
+     * If the component calling this does not load the data then you should set it to `false`, which means that if the data
+     * is not there, it will log an alert, as it means we are using data that no one loaded and that's most probably a bug.
+     */
+    canBeMissing?: boolean;
+    /**
+     * This will be used to subscribe to a subset of an Onyx key's data.
+     * Using this setting on `useOnyx` can have very positive performance benefits because the component will only re-render
+     * when the subset of data changes. Otherwise, any change of data on any property would normally
+     * cause the component to re-render (and that can be expensive from a performance standpoint).
+     * @see `useOnyx` cannot return `null` and so selector will replace `null` with `undefined` to maintain compatibility.
+     */
+    selector?: UseOnyxSelector<TKey, TReturnValue>;
+};
+type FetchStatus = 'loading' | 'loaded';
+type ResultMetadata<TValue> = {
+    status: FetchStatus;
+    sourceValue?: NonNullable<TValue> | undefined;
+};
+type UseOnyxResult<TValue> = [NonNullable<TValue> | undefined, ResultMetadata<TValue>];
+declare function useOnyx<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>>(key: TKey, options?: UseOnyxOptions<TKey, TReturnValue>, dependencies?: DependencyList): UseOnyxResult<TReturnValue>;
+export default useOnyx;
+export { SnapshotCache };
+export type { FetchStatus, ResultMetadata, UseOnyxResult, UseOnyxOptions, UseOnyxSelector };
diff --git a/node_modules/react-native-onyx/dist/useOnyx/index.js b/node_modules/react-native-onyx/dist/useOnyx/index.js
new file mode 100644
index 0000000..e348673
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx/index.js
@@ -0,0 +1,315 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.SnapshotCache = void 0;
+const fast_equals_1 = require("fast-equals");
+const react_1 = require("react");
+const OnyxCache_1 = __importStar(require("../OnyxCache"));
+const OnyxConnectionManager_1 = __importDefault(require("../OnyxConnectionManager"));
+const OnyxUtils_1 = __importDefault(require("../OnyxUtils"));
+const GlobalSettings = __importStar(require("../GlobalSettings"));
+const usePrevious_1 = __importDefault(require("../usePrevious"));
+const metrics_1 = __importDefault(require("../metrics"));
+const Logger = __importStar(require("../Logger"));
+const SnapshotCache_1 = __importDefault(require("./SnapshotCache"));
+exports.SnapshotCache = SnapshotCache_1.default;
+function useOnyx(key, options, dependencies = []) {
+    const connectionRef = (0, react_1.useRef)(null);
+    const previousKey = (0, usePrevious_1.default)(key);
+    // Generate unique instance ID for this hook to prevent cache sharing between different hook instances
+    const hookInstanceId = (0, react_1.useRef)(`hook_${Math.random().toString(36).substr(2, 9)}_${Date.now()}`).current;
+    // Create memoized version of selector for performance
+    const memoizedSelector = (0, react_1.useMemo)(() => {
+        if (!(options === null || options === void 0 ? void 0 : options.selector))
+            return null;
+        let lastInput;
+        let lastOutput;
+        let hasComputed = false;
+        return (input) => {
+            // Always recompute when input changes
+            if (!hasComputed || lastInput !== input) {
+                const newOutput = options.selector(input);
+                // Deep equality mode: only update if output actually changed
+                if (!hasComputed || !(0, fast_equals_1.deepEqual)(lastOutput, newOutput)) {
+                    lastInput = input;
+                    lastOutput = newOutput;
+                    hasComputed = true;
+                }
+            }
+            return lastOutput;
+        };
+    }, [options === null || options === void 0 ? void 0 : options.selector, ...dependencies]);
+    // Stores the previous cached value as it's necessary to compare with the new value in `getSnapshot()`.
+    // We initialize it to `null` to simulate that we don't have any value from cache yet.
+    const previousValueRef = (0, react_1.useRef)(null);
+    // Stores the newest cached value in order to compare with the previous one and optimize `getSnapshot()` execution.
+    const newValueRef = (0, react_1.useRef)(null);
+    // Stores the previously result returned by the hook, containing the data from cache and the fetch status.
+    // We initialize it to `undefined` and `loading` fetch status to simulate the initial result when the hook is loading from the cache.
+    // However, if `initWithStoredValues` is `false` we set the fetch status to `loaded` since we want to signal that data is ready.
+    const resultRef = (0, react_1.useRef)([
+        undefined,
+        {
+            status: (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false ? 'loaded' : 'loading',
+        },
+    ]);
+    // Indicates if it's the first Onyx connection of this hook or not, as we don't want certain use cases
+    // in `getSnapshot()` to be satisfied several times.
+    const isFirstConnectionRef = (0, react_1.useRef)(true);
+    // Indicates if the hook is connecting to an Onyx key.
+    const isConnectingRef = (0, react_1.useRef)(false);
+    // Stores the `onStoreChange()` function, which can be used to trigger a `getSnapshot()` update when desired.
+    const onStoreChangeFnRef = (0, react_1.useRef)(null);
+    // Indicates if we should get the newest cached value from Onyx during `getSnapshot()` execution.
+    const shouldGetCachedValueRef = (0, react_1.useRef)(true);
+    // Inside useOnyx.ts, we need to track the sourceValue separately
+    const sourceValueRef = (0, react_1.useRef)(undefined);
+    // Track selector changes between renders (not between getSnapshot calls within the same render)
+    const previousSelectorRef = (0, react_1.useRef)(options === null || options === void 0 ? void 0 : options.selector);
+    const selectorChangedInThisRender = (0, react_1.useRef)(false);
+    // Detect selector changes on each render
+    if (previousSelectorRef.current !== (options === null || options === void 0 ? void 0 : options.selector)) {
+        previousSelectorRef.current = options === null || options === void 0 ? void 0 : options.selector;
+        selectorChangedInThisRender.current = true;
+    }
+    else {
+        selectorChangedInThisRender.current = false;
+    }
+    (0, react_1.useEffect)(() => {
+        // These conditions will ensure we can only handle dynamic collection member keys from the same collection.
+        if ((options === null || options === void 0 ? void 0 : options.allowDynamicKey) || previousKey === key) {
+            return;
+        }
+        try {
+            const previousCollectionKey = OnyxUtils_1.default.splitCollectionMemberKey(previousKey)[0];
+            const collectionKey = OnyxUtils_1.default.splitCollectionMemberKey(key)[0];
+            if (OnyxUtils_1.default.isCollectionMemberKey(previousCollectionKey, previousKey) && OnyxUtils_1.default.isCollectionMemberKey(collectionKey, key) && previousCollectionKey === collectionKey) {
+                return;
+            }
+        }
+        catch (e) {
+            throw new Error(`'${previousKey}' key can't be changed to '${key}'. useOnyx() only supports dynamic keys if they are both collection member keys from the same collection e.g. from 'collection_id1' to 'collection_id2'.`);
+        }
+        throw new Error(`'${previousKey}' key can't be changed to '${key}'. useOnyx() only supports dynamic keys if they are both collection member keys from the same collection e.g. from 'collection_id1' to 'collection_id2'.`);
+    }, [previousKey, key, options === null || options === void 0 ? void 0 : options.allowDynamicKey]);
+    (0, react_1.useEffect)(() => {
+        // This effect will only run if the `dependencies` array changes. If it changes it will force the hook
+        // to trigger a `getSnapshot()` update by calling the stored `onStoreChange()` function reference, thus
+        // re-running the hook and returning the latest value to the consumer.
+        if (connectionRef.current === null || isConnectingRef.current || !onStoreChangeFnRef.current) {
+            return;
+        }
+        shouldGetCachedValueRef.current = true;
+        onStoreChangeFnRef.current();
+        // eslint-disable-next-line react-hooks/exhaustive-deps
+    }, [...dependencies]);
+    // Mimics withOnyx's checkEvictableKeys() behavior.
+    const checkEvictableKey = (0, react_1.useCallback)(() => {
+        if ((options === null || options === void 0 ? void 0 : options.canEvict) === undefined || !connectionRef.current) {
+            return;
+        }
+        if (!OnyxCache_1.default.isEvictableKey(key)) {
+            throw new Error(`canEvict can't be used on key '${key}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({evictableKeys: []}).`);
+        }
+        if (options.canEvict) {
+            OnyxConnectionManager_1.default.removeFromEvictionBlockList(connectionRef.current);
+        }
+        else {
+            OnyxConnectionManager_1.default.addToEvictionBlockList(connectionRef.current);
+        }
+    }, [key, options === null || options === void 0 ? void 0 : options.canEvict]);
+    const getSnapshot = (0, react_1.useCallback)(() => {
+        var _a, _b, _c, _d;
+        const keyStr = key;
+        // Skip cache on first connection if initWithStoredValues is false
+        // This ensures each hook instance respects its individual initWithStoredValues setting
+        const shouldSkipCacheOnFirstConnection = isFirstConnectionRef.current && (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false;
+        // Skip cache if dependencies are provided, as they can change the selector behavior
+        // without changing the selector function itself
+        const shouldSkipCacheForDependencies = dependencies.length > 0;
+        // Skip cache if selector reference has changed in this render
+        const selectorChanged = selectorChangedInThisRender.current;
+        // Check if we have any cache for this Onyx key (but respect individual hook settings)
+        // Skip cache for selector changes, dependencies to preserve individual behavior
+        const useGlobalCache = true;
+        const shouldSkipCache = shouldSkipCacheOnFirstConnection || shouldSkipCacheForDependencies || selectorChanged;
+        // Get input data for cache key generation (for selectors)
+        let inputData;
+        if ((options === null || options === void 0 ? void 0 : options.selector) && !shouldSkipCache) {
+            // We get the value from cache while the first connection to Onyx is being made,
+            // so we can return any cached value right away. After the connection is made, we only
+            // update `newValueRef` when `Onyx.connect()` callback is fired.
+            if (isFirstConnectionRef.current || shouldGetCachedValueRef.current) {
+                inputData = OnyxUtils_1.default.tryGetCachedValue(key);
+            }
+            else {
+                inputData = newValueRef.current;
+            }
+        }
+        const selectorKey = SnapshotCache_1.default.generateCacheKey(options, memoizedSelector, hookInstanceId, inputData);
+        if (useGlobalCache && !shouldSkipCache) {
+            const cachedResult = SnapshotCache_1.default.get(keyStr, selectorKey);
+            if (cachedResult !== undefined) {
+                SnapshotCache_1.default.recordHit();
+                resultRef.current = cachedResult;
+                return cachedResult;
+            }
+            else {
+                SnapshotCache_1.default.recordMiss();
+            }
+        }
+        else {
+            SnapshotCache_1.default.recordSkip();
+        }
+        let isOnyxValueDefined = true;
+        // We return the initial result right away during the first connection if `initWithStoredValues` is set to `false`.
+        if (isFirstConnectionRef.current && (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false) {
+            const result = resultRef.current;
+            // Store in cache
+            if (useGlobalCache) {
+                SnapshotCache_1.default.set(keyStr, selectorKey, result);
+            }
+            return result;
+        }
+        // We get the value from cache while the first connection to Onyx is being made,
+        // so we can return any cached value right away. After the connection is made, we only
+        // update `newValueRef` when `Onyx.connect()` callback is fired.
+        if (isFirstConnectionRef.current || shouldGetCachedValueRef.current) {
+            // Gets the value from cache and maps it with selector. It changes `null` to `undefined` for `useOnyx` compatibility.
+            const value = OnyxUtils_1.default.tryGetCachedValue(key);
+            const selectedValue = memoizedSelector ? memoizedSelector(value) : value;
+            newValueRef.current = (selectedValue !== null && selectedValue !== void 0 ? selectedValue : undefined);
+            // This flag is `false` when the original Onyx value (without selector) is not defined yet.
+            // It will be used later to check if we need to log an alert that the value is missing.
+            isOnyxValueDefined = value !== null && value !== undefined;
+            // We set this flag to `false` again since we don't want to get the newest cached value every time `getSnapshot()` is executed,
+            // and only when `Onyx.connect()` callback is fired.
+            shouldGetCachedValueRef.current = false;
+        }
+        const hasCacheForKey = OnyxCache_1.default.hasCacheForKey(key);
+        // Since the fetch status can be different given the use cases below, we define the variable right away.
+        let newFetchStatus;
+        // If we have pending merge operations for the key during the first connection, we set the new value to `undefined`
+        // and fetch status to `loading` to simulate that it is still being loaded until we have the most updated data.
+        // If `allowStaleData` is `true` this logic will be ignored and cached value will be used, even if it's stale data.
+        if (isFirstConnectionRef.current && OnyxUtils_1.default.hasPendingMergeForKey(key) && !(options === null || options === void 0 ? void 0 : options.allowStaleData)) {
+            newValueRef.current = undefined;
+            newFetchStatus = 'loading';
+        }
+        // Optimized equality checking - eliminated redundant deep equality:
+        // - Memoized selectors already handle deep equality internally, so we can use fast reference equality
+        // - Non-selector cases use shallow equality for object reference checks
+        // - Normalize null to undefined to ensure consistent comparison (both represent "no value")
+        let areValuesEqual;
+        if (memoizedSelector) {
+            const normalizedPrevious = (_a = previousValueRef.current) !== null && _a !== void 0 ? _a : undefined;
+            const normalizedNew = (_b = newValueRef.current) !== null && _b !== void 0 ? _b : undefined;
+            areValuesEqual = normalizedPrevious === normalizedNew;
+        }
+        else {
+            areValuesEqual = (0, fast_equals_1.shallowEqual)((_c = previousValueRef.current) !== null && _c !== void 0 ? _c : undefined, newValueRef.current);
+        }
+        // We update the cached value and the result in the following conditions:
+        // We will update the cached value and the result in any of the following situations:
+        // - The previously cached value is different from the new value.
+        // - The previously cached value is `null` (not set from cache yet) and we have cache for this key
+        //   OR we have a pending `Onyx.clear()` task (if `Onyx.clear()` is running cache might not be available anymore
+        //   so we update the cached value/result right away in order to prevent infinite loading state issues).
+        const shouldUpdateResult = !areValuesEqual || (previousValueRef.current === null && (hasCacheForKey || OnyxCache_1.default.hasPendingTask(OnyxCache_1.TASK.CLEAR)));
+        if (shouldUpdateResult) {
+            previousValueRef.current = newValueRef.current;
+            // If the new value is `null` we default it to `undefined` to ensure the consumer gets a consistent result from the hook.
+            const newStatus = newFetchStatus !== null && newFetchStatus !== void 0 ? newFetchStatus : 'loaded';
+            resultRef.current = [
+                (_d = previousValueRef.current) !== null && _d !== void 0 ? _d : undefined,
+                {
+                    status: newStatus,
+                    sourceValue: sourceValueRef.current,
+                },
+            ];
+            // If `canBeMissing` is set to `false` and the Onyx value of that key is not defined,
+            // we log an alert so it can be acknowledged by the consumer. Additionally, we won't log alerts
+            // if there's a `Onyx.clear()` task in progress.
+            if ((options === null || options === void 0 ? void 0 : options.canBeMissing) === false && newStatus === 'loaded' && !isOnyxValueDefined && !OnyxCache_1.default.hasPendingTask(OnyxCache_1.TASK.CLEAR)) {
+                Logger.logAlert(`useOnyx returned no data for key with canBeMissing set to false for key ${key}`, { showAlert: true });
+            }
+        }
+        // Cache the result globally for other useOnyx instances
+        if (useGlobalCache) {
+            SnapshotCache_1.default.set(keyStr, selectorKey, resultRef.current);
+        }
+        return resultRef.current;
+    }, [options === null || options === void 0 ? void 0 : options.initWithStoredValues, options === null || options === void 0 ? void 0 : options.allowStaleData, options === null || options === void 0 ? void 0 : options.canBeMissing, key, memoizedSelector]);
+    const subscribe = (0, react_1.useCallback)((onStoreChange) => {
+        isConnectingRef.current = true;
+        onStoreChangeFnRef.current = onStoreChange;
+        connectionRef.current = OnyxConnectionManager_1.default.connect({
+            key,
+            callback: (value, callbackKey, sourceValue) => {
+                isConnectingRef.current = false;
+                onStoreChangeFnRef.current = onStoreChange;
+                // Signals that the first connection was made, so some logics in `getSnapshot()`
+                // won't be executed anymore.
+                isFirstConnectionRef.current = false;
+                // Signals that we want to get the newest cached value again in `getSnapshot()`.
+                shouldGetCachedValueRef.current = true;
+                // sourceValue is unknown type, so we need to cast it to the correct type.
+                sourceValueRef.current = sourceValue;
+                // Invalidate global cache for this key when data changes
+                SnapshotCache_1.default.invalidateKey(key);
+                // Finally, we signal that the store changed, making `getSnapshot()` be called again.
+                onStoreChange();
+            },
+            initWithStoredValues: options === null || options === void 0 ? void 0 : options.initWithStoredValues,
+            waitForCollectionCallback: OnyxUtils_1.default.isCollectionKey(key),
+            reuseConnection: options === null || options === void 0 ? void 0 : options.reuseConnection,
+        });
+        checkEvictableKey();
+        return () => {
+            if (!connectionRef.current) {
+                return;
+            }
+            OnyxConnectionManager_1.default.disconnect(connectionRef.current);
+            isFirstConnectionRef.current = false;
+            isConnectingRef.current = false;
+            onStoreChangeFnRef.current = null;
+        };
+    }, [key, options === null || options === void 0 ? void 0 : options.initWithStoredValues, options === null || options === void 0 ? void 0 : options.reuseConnection, checkEvictableKey]);
+    const getSnapshotDecorated = (0, react_1.useMemo)(() => {
+        if (!GlobalSettings.isPerformanceMetricsEnabled()) {
+            return getSnapshot;
+        }
+        return (0, metrics_1.default)(getSnapshot, 'useOnyx.getSnapshot');
+    }, [getSnapshot]);
+    (0, react_1.useEffect)(() => {
+        checkEvictableKey();
+    }, [checkEvictableKey]);
+    const result = (0, react_1.useSyncExternalStore)(subscribe, getSnapshotDecorated);
+    return result;
+}
+exports.default = useOnyx;
diff --git a/node_modules/react-native-onyx/dist/useOnyx/types.d.ts b/node_modules/react-native-onyx/dist/useOnyx/types.d.ts
new file mode 100644
index 0000000..fb16c37
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx/types.d.ts
@@ -0,0 +1 @@
+export default UseOnyx;
diff --git a/node_modules/react-native-onyx/dist/useOnyx/types.js b/node_modules/react-native-onyx/dist/useOnyx/types.js
new file mode 100644
index 0000000..c48104a
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyx/types.js
@@ -0,0 +1,3 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = UseOnyx;
diff --git a/node_modules/react-native-onyx/dist/useOnyxBatch.d.ts b/node_modules/react-native-onyx/dist/useOnyxBatch.d.ts
new file mode 100644
index 0000000..cb0ff5c
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxBatch.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/node_modules/react-native-onyx/dist/useOnyxBatch.js b/node_modules/react-native-onyx/dist/useOnyxBatch.js
new file mode 100644
index 0000000..86b2618
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxBatch.js
@@ -0,0 +1,48 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const react_1 = require("react");
+nimport;
+type;
+{
+    OnyxKey;
+}
+from;
+'./types';
+nimport;
+useOnyx;
+from;
+'./useOnyx';
+nimport;
+type;
+{
+    UseOnyxOptions, UseOnyxResult;
+}
+from;
+'./useOnyx';
+n;
+n; /**\n * A simple utility to batch useOnyx hook creation when you need hundreds/thousands of connections.\n * Instead of creating all connections immediately (which can cause 400ms freezes),\n * this creates them in small batches over time.\n * \n * Usage:\n * ```\n * const batchedData = useOnyxBatch([\n *   { key: 'user1', options: { selector: user => user.name } },\n *   { key: 'user2', options: { selector: user => user.name } },\n *   // ... hundreds more\n * ]);\n * ```\n */
+n;
+ntype;
+(BatchRequest) = { n, key: TKey, n, options: (UseOnyxOptions), n };
+n;
+ntype;
+(BatchResult) = T;
+BatchRequest;
+n ? UseOnyxResult : ;
+n: never;
+n;
+n; /**\n * Hook that batches multiple useOnyx calls to prevent main thread blocking\n * when you need to create hundreds or thousands of connections at once.\n * \n * @param requests Array of useOnyx requests\n * @param batchSize How many connections to create per frame (default: 10)\n * @returns Array of results, with loading state for unprocessed batches\n */
+nfunction;
+useOnyxBatch(n, requests, T, n, batchSize, number = 10, n);
+{
+    [K in keyof, T];
+    BatchResult;
+}
+{
+    n;
+    const [processedCount, setProcessedCount] = (0, react_1.useState)(0);
+    n;
+    const timeoutRef = (0, react_1.useRef)(null);
+    n;
+    n;
+} // Batch processing\n  useEffect(() => {\n    if (processedCount < requests.length) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      \n      timeoutRef.current = setTimeout(() => {\n        setProcessedCount(prev => Math.min(prev + batchSize, requests.length));\n      }, 0); // Next tick\n    }\n    \n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [processedCount, requests.length, batchSize]);\n  \n  // This is a simplified example - in practice you'd need to manage\n  // the individual useOnyx hooks more carefully to avoid React rules violations\n  const results: any[] = [];\n  \n  for (let i = 0; i < requests.length; i++) {\n    if (i < processedCount) {\n      // This would need to be implemented differently to comply with React rules\n      // You can't conditionally call hooks like this\n      results[i] = [undefined, { status: 'loaded' }]; // Placeholder\n    } else {\n      results[i] = [undefined, { status: 'loading' }];\n    }\n  }\n  \n  return results as any;\n}\n\n/**\n * Alternative: Pre-connection utility\n * Call this early to start creating connections before you need the data\n */\nfunction preconnectOnyx(keys: OnyxKey[]): void {\n  // Pre-create connections in small batches\n  // This warms up the connection pool\n}\n\nexport { useOnyxBatch, preconnectOnyx };\nexport type { BatchRequest };
diff --git a/node_modules/react-native-onyx/dist/useOnyxDirect.d.ts b/node_modules/react-native-onyx/dist/useOnyxDirect.d.ts
new file mode 100644
index 0000000..4cef64b
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxDirect.d.ts
@@ -0,0 +1,25 @@
+import type { DependencyList } from 'react';
+import type { OnyxKey, OnyxValue } from './types';
+type UseOnyxDirectSelector<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>> = (data: OnyxValue<TKey> | undefined) => TReturnValue;
+type UseOnyxDirectOptions<TKey extends OnyxKey, TReturnValue> = {
+    /**
+     * Transform the data before returning it to the component.
+     */
+    selector?: UseOnyxDirectSelector<TKey, TReturnValue>;
+    /**
+     * If set to `false`, then no data will be prefilled into the component.
+     */
+    initWithStoredValues?: boolean;
+    /**
+     * If set to `true`, the key can be changed dynamically during the component lifecycle.
+     */
+    allowDynamicKey?: boolean;
+};
+type FetchStatus = 'loading' | 'loaded';
+type ResultMetadata = {
+    status: FetchStatus;
+};
+type UseOnyxDirectResult<TValue> = [NonNullable<TValue> | undefined, ResultMetadata];
+declare function useOnyxDirect<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>>(key: TKey, options?: UseOnyxDirectOptions<TKey, TReturnValue>, dependencies?: DependencyList): UseOnyxDirectResult<TReturnValue>;
+export default useOnyxDirect;
+export type { FetchStatus, ResultMetadata, UseOnyxDirectResult, UseOnyxDirectOptions, UseOnyxDirectSelector };
diff --git a/node_modules/react-native-onyx/dist/useOnyxDirect.js b/node_modules/react-native-onyx/dist/useOnyxDirect.js
new file mode 100644
index 0000000..b95f8bb
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxDirect.js
@@ -0,0 +1,231 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const react_1 = require("react");
+const storage_1 = __importDefault(require("./storage"));
+const usePrevious_1 = __importDefault(require("./usePrevious"));
+// Simple storage change listener system
+const storageListeners = new Map();
+// Track storage changes manually since we're bypassing the cache system
+const notifyStorageListeners = (key) => {
+    const listeners = storageListeners.get(key);
+    if (listeners) {
+        listeners.forEach((listener) => listener());
+    }
+    // Also notify collection listeners if this key matches any collection patterns
+    storageListeners.forEach((collectionListeners, listenerKey) => {
+        if (listenerKey === key || !isCollectionKey(listenerKey) || !key.startsWith(listenerKey)) {
+            return;
+        }
+        collectionListeners.forEach((listener) => listener());
+    });
+};
+// Simple collection key detection - collection keys end with underscore
+const isCollectionKey = (key) => {
+    return key.endsWith('_');
+};
+// Load all keys that match a collection pattern
+const loadCollectionData = (collectionKey) => {
+    return storage_1.default.getAllKeys().then((allKeys) => {
+        const matchingKeys = allKeys.filter((key) => key.startsWith(collectionKey) && key !== collectionKey);
+        if (matchingKeys.length === 0) {
+            return {};
+        }
+        return storage_1.default.multiGet(matchingKeys).then((keyValuePairs) => {
+            const collection = {};
+            keyValuePairs.forEach(([key, value]) => {
+                if (value === null) {
+                    return;
+                }
+                collection[key] = value;
+            });
+            return collection;
+        });
+    });
+};
+// Override storage methods to notify our listeners
+const originalSetItem = storage_1.default.setItem;
+const originalMultiSet = storage_1.default.multiSet;
+const originalMergeItem = storage_1.default.mergeItem;
+const originalMultiMerge = storage_1.default.multiMerge;
+const originalRemoveItem = storage_1.default.removeItem;
+const originalRemoveItems = storage_1.default.removeItems;
+const originalClear = storage_1.default.clear;
+storage_1.default.setItem = (key, value) => {
+    const result = originalSetItem(key, value);
+    result.then(() => notifyStorageListeners(key));
+    return result;
+};
+storage_1.default.multiSet = (pairs) => {
+    const result = originalMultiSet(pairs);
+    result.then(() => {
+        pairs.forEach(([key]) => notifyStorageListeners(key));
+    });
+    return result;
+};
+storage_1.default.mergeItem = (key, changes, replaceNullPatches) => {
+    const result = originalMergeItem(key, changes, replaceNullPatches);
+    result.then(() => notifyStorageListeners(key));
+    return result;
+};
+storage_1.default.multiMerge = (pairs) => {
+    const result = originalMultiMerge(pairs);
+    result.then(() => {
+        pairs.forEach(([key]) => notifyStorageListeners(key));
+    });
+    return result;
+};
+storage_1.default.removeItem = (key) => {
+    const result = originalRemoveItem(key);
+    result.then(() => notifyStorageListeners(key));
+    return result;
+};
+storage_1.default.removeItems = (keys) => {
+    const result = originalRemoveItems(keys);
+    result.then(() => {
+        keys.forEach((key) => notifyStorageListeners(key));
+    });
+    return result;
+};
+storage_1.default.clear = () => {
+    const result = originalClear();
+    result.then(() => {
+        // Notify all listeners on clear
+        storageListeners.forEach((listeners) => {
+            listeners.forEach((listener) => listener());
+        });
+    });
+    return result;
+};
+function useOnyxDirect(key, options, dependencies = []) {
+    const previousKey = (0, usePrevious_1.default)(key);
+    // Store current value and status
+    const valueRef = (0, react_1.useRef)(undefined);
+    const statusRef = (0, react_1.useRef)((options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false ? 'loaded' : 'loading');
+    const resultRef = (0, react_1.useRef)([undefined, { status: statusRef.current }]);
+    // Track if we've loaded initial data
+    const hasLoadedInitialData = (0, react_1.useRef)(false);
+    // Memoized selector that respects dependencies
+    const selectorRef = (0, react_1.useRef)(options === null || options === void 0 ? void 0 : options.selector);
+    const dependenciesRef = (0, react_1.useRef)(dependencies);
+    // Update refs when dependencies or selector change
+    (0, react_1.useEffect)(() => {
+        selectorRef.current = options === null || options === void 0 ? void 0 : options.selector;
+        dependenciesRef.current = dependencies;
+        // eslint-disable-next-line react-hooks/exhaustive-deps
+    }, [options === null || options === void 0 ? void 0 : options.selector, dependencies]);
+    // Handle dynamic key changes (similar to original useOnyx)
+    (0, react_1.useEffect)(() => {
+        // These conditions will ensure we can only handle dynamic collection member keys from the same collection.
+        if ((options === null || options === void 0 ? void 0 : options.allowDynamicKey) || previousKey === key) {
+            return;
+        }
+        if (!previousKey) {
+            return;
+        }
+        // For simplicity, we'll allow any dynamic key change if allowDynamicKey is true
+        // Otherwise, we only allow collection member keys from the same collection
+        try {
+            // Check if both keys are collection member keys from the same collection
+            if (previousKey.includes('_') && key.includes('_')) {
+                const previousCollectionKey = previousKey.substring(0, previousKey.lastIndexOf('_') + 1);
+                const currentCollectionKey = key.substring(0, key.lastIndexOf('_') + 1);
+                if (previousCollectionKey === currentCollectionKey) {
+                    return;
+                }
+            }
+        }
+        catch (e) {
+            // Fall through to error
+        }
+        throw new Error(`'${previousKey}' key can't be changed to '${key}'. useOnyxDirect() only supports dynamic keys if they are both collection member keys from the same collection e.g. from 'collection_id1' to 'collection_id2', or if allowDynamicKey is true.`);
+    }, [previousKey, key, options === null || options === void 0 ? void 0 : options.allowDynamicKey]);
+    const getSnapshot = (0, react_1.useCallback)(() => {
+        return resultRef.current;
+    }, []);
+    const subscribe = (0, react_1.useCallback)((onStoreChange) => {
+        // Add listener for this key
+        if (!storageListeners.has(key)) {
+            storageListeners.set(key, new Set());
+        }
+        storageListeners.get(key).add(onStoreChange);
+        // Load initial data if needed
+        if (!hasLoadedInitialData.current && (options === null || options === void 0 ? void 0 : options.initWithStoredValues) !== false) {
+            hasLoadedInitialData.current = true;
+            const loadData = isCollectionKey(key) ? loadCollectionData(key) : storage_1.default.getItem(key);
+            loadData
+                .then((rawValue) => {
+                const value = rawValue;
+                const selectedValue = selectorRef.current ? selectorRef.current(value) : value;
+                valueRef.current = (selectedValue !== null && selectedValue !== void 0 ? selectedValue : undefined);
+                statusRef.current = 'loaded';
+                resultRef.current = [valueRef.current, { status: statusRef.current }];
+                onStoreChange();
+            })
+                .catch((error) => {
+                console.error(`useOnyxDirect: Error loading initial data for key ${key}:`, error);
+                statusRef.current = 'loaded';
+                resultRef.current = [undefined, { status: statusRef.current }];
+                onStoreChange();
+            });
+        }
+        else if ((options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false) {
+            // If we don't want initial values, mark as loaded immediately
+            hasLoadedInitialData.current = true;
+            statusRef.current = 'loaded';
+            resultRef.current = [undefined, { status: statusRef.current }];
+        }
+        // Create storage change handler
+        const handleStorageChange = () => {
+            const loadData = isCollectionKey(key) ? loadCollectionData(key) : storage_1.default.getItem(key);
+            loadData
+                .then((rawValue) => {
+                const value = rawValue;
+                const selectedValue = selectorRef.current ? selectorRef.current(value) : value;
+                const newValue = (selectedValue !== null && selectedValue !== void 0 ? selectedValue : undefined);
+                // Only update if value actually changed
+                if (valueRef.current !== newValue) {
+                    valueRef.current = newValue;
+                    statusRef.current = 'loaded';
+                    resultRef.current = [valueRef.current, { status: statusRef.current }];
+                    onStoreChange();
+                }
+            })
+                .catch((error) => {
+                console.error(`useOnyxDirect: Error loading data for key ${key}:`, error);
+            });
+        };
+        // Set up the storage change listener
+        if (!storageListeners.has(key)) {
+            storageListeners.set(key, new Set());
+        }
+        storageListeners.get(key).add(handleStorageChange);
+        return () => {
+            // Clean up listener
+            const listeners = storageListeners.get(key);
+            if (listeners) {
+                listeners.delete(onStoreChange);
+                listeners.delete(handleStorageChange);
+                if (listeners.size === 0) {
+                    storageListeners.delete(key);
+                }
+            }
+        };
+    }, [key, options === null || options === void 0 ? void 0 : options.initWithStoredValues]);
+    // Handle key changes by forcing re-subscription
+    (0, react_1.useEffect)(() => {
+        if (!previousKey || previousKey === key) {
+            return;
+        }
+        // Reset state for new key
+        hasLoadedInitialData.current = false;
+        valueRef.current = undefined;
+        statusRef.current = (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false ? 'loaded' : 'loading';
+        resultRef.current = [undefined, { status: statusRef.current }];
+    }, [key, previousKey, options === null || options === void 0 ? void 0 : options.initWithStoredValues]);
+    const result = (0, react_1.useSyncExternalStore)(subscribe, getSnapshot);
+    return result;
+}
+exports.default = useOnyxDirect;
diff --git a/node_modules/react-native-onyx/dist/useOnyxSourceValue.d.ts b/node_modules/react-native-onyx/dist/useOnyxSourceValue.d.ts
new file mode 100644
index 0000000..e0cd3a5
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxSourceValue.d.ts
@@ -0,0 +1,42 @@
+import type { OnyxKey, OnyxValue } from './types';
+import type { UseOnyxOptions, ResultMetadata } from './useOnyx';
+type SourceValueChangeCallback<TValue> = (currentSource: TValue | undefined, previousSource: TValue | undefined) => void;
+type UseOnyxSourceValueOptions<TKey extends OnyxKey> = UseOnyxOptions<TKey, OnyxValue<TKey>> & {
+    /**
+     * Callback fired when the source value changes
+     */
+    onSourceValueChange?: SourceValueChangeCallback<NonNullable<OnyxValue<TKey>>>;
+};
+type UseOnyxSourceValueResult<TKey extends OnyxKey> = {
+    data: NonNullable<OnyxValue<TKey>> | undefined;
+    metadata: ResultMetadata<OnyxValue<TKey>>;
+    sourceValue: NonNullable<OnyxValue<TKey>> | undefined;
+    previousSourceValue: NonNullable<OnyxValue<TKey>> | undefined;
+    hasSourceValueChanged: boolean;
+};
+/**
+ * Hook to easily handle source values of particular Onyx states.
+ * Provides the original source value that triggered the update, along with utilities
+ * to track changes and compare with previous source values.
+ */
+declare function useOnyxSourceValue<TKey extends OnyxKey>(key: TKey, options?: UseOnyxSourceValueOptions<TKey>): UseOnyxSourceValueResult<TKey>;
+/**
+ * Hook that only returns the source value and its metadata.
+ * Useful when you only care about the original source data.
+ */
+declare function useOnyxSourceValueOnly<TKey extends OnyxKey>(key: TKey, options?: UseOnyxOptions<TKey, OnyxValue<TKey>>): [NonNullable<OnyxValue<TKey>> | undefined, ResultMetadata<OnyxValue<TKey>> & {
+    hasSourceValueChanged: boolean;
+}];
+/**
+ * Hook to track source value changes over time.
+ * Returns a callback to check if the source value has changed since a specific point.
+ */
+declare function useOnyxSourceValueTracker<TKey extends OnyxKey>(key: TKey, options?: UseOnyxOptions<TKey, OnyxValue<TKey>>): {
+    currentSourceValue: NonNullable<OnyxValue<TKey>> | undefined;
+    takeSnapshot: () => void;
+    hasChangedSinceSnapshot: () => boolean;
+    getSnapshot: () => NonNullable<OnyxValue<TKey>> | undefined;
+};
+export default useOnyxSourceValue;
+export { useOnyxSourceValueOnly, useOnyxSourceValueTracker };
+export type { UseOnyxSourceValueOptions, UseOnyxSourceValueResult, SourceValueChangeCallback };
diff --git a/node_modules/react-native-onyx/dist/useOnyxSourceValue.js b/node_modules/react-native-onyx/dist/useOnyxSourceValue.js
new file mode 100644
index 0000000..6c6db8c
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxSourceValue.js
@@ -0,0 +1,82 @@
+"use strict";
+var __rest = (this && this.__rest) || function (s, e) {
+    var t = {};
+    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
+        t[p] = s[p];
+    if (s != null && typeof Object.getOwnPropertySymbols === "function")
+        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
+            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
+                t[p[i]] = s[p[i]];
+        }
+    return t;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.useOnyxSourceValueTracker = exports.useOnyxSourceValueOnly = void 0;
+const react_1 = require("react");
+const useOnyx_1 = __importDefault(require("./useOnyx"));
+const usePrevious_1 = __importDefault(require("./usePrevious"));
+/**
+ * Hook to easily handle source values of particular Onyx states.
+ * Provides the original source value that triggered the update, along with utilities
+ * to track changes and compare with previous source values.
+ */
+function useOnyxSourceValue(key, options) {
+    const _a = options || {}, { onSourceValueChange } = _a, useOnyxOptions = __rest(_a, ["onSourceValueChange"]);
+    const [data, metadata] = (0, useOnyx_1.default)(key, useOnyxOptions);
+    const previousSourceValue = (0, usePrevious_1.default)(metadata.sourceValue);
+    // Track if we've already fired the callback for this source value change
+    const lastCallbackSourceRef = (0, react_1.useRef)(undefined);
+    const hasSourceValueChanged = metadata.sourceValue !== previousSourceValue;
+    // Fire callback when source value changes
+    if (onSourceValueChange && hasSourceValueChanged && metadata.sourceValue !== lastCallbackSourceRef.current) {
+        lastCallbackSourceRef.current = metadata.sourceValue;
+        onSourceValueChange(metadata.sourceValue, previousSourceValue);
+    }
+    return {
+        data,
+        metadata,
+        sourceValue: metadata.sourceValue,
+        previousSourceValue,
+        hasSourceValueChanged,
+    };
+}
+/**
+ * Hook that only returns the source value and its metadata.
+ * Useful when you only care about the original source data.
+ */
+function useOnyxSourceValueOnly(key, options) {
+    const result = useOnyxSourceValue(key, options);
+    return [
+        result.sourceValue,
+        Object.assign(Object.assign({}, result.metadata), { hasSourceValueChanged: result.hasSourceValueChanged }),
+    ];
+}
+exports.useOnyxSourceValueOnly = useOnyxSourceValueOnly;
+/**
+ * Hook to track source value changes over time.
+ * Returns a callback to check if the source value has changed since a specific point.
+ */
+function useOnyxSourceValueTracker(key, options) {
+    const [, metadata] = (0, useOnyx_1.default)(key, options);
+    const snapshotRef = (0, react_1.useRef)(undefined);
+    const takeSnapshot = (0, react_1.useCallback)(() => {
+        snapshotRef.current = metadata.sourceValue;
+    }, [metadata.sourceValue]);
+    const hasChangedSinceSnapshot = (0, react_1.useCallback)(() => {
+        return metadata.sourceValue !== snapshotRef.current;
+    }, [metadata.sourceValue]);
+    const getSnapshot = (0, react_1.useCallback)(() => {
+        return snapshotRef.current;
+    }, []);
+    return {
+        currentSourceValue: metadata.sourceValue,
+        takeSnapshot,
+        hasChangedSinceSnapshot,
+        getSnapshot,
+    };
+}
+exports.useOnyxSourceValueTracker = useOnyxSourceValueTracker;
+exports.default = useOnyxSourceValue;
diff --git a/node_modules/react-native-onyx/dist/useOnyxWithTracking.d.ts b/node_modules/react-native-onyx/dist/useOnyxWithTracking.d.ts
new file mode 100644
index 0000000..1755018
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxWithTracking.d.ts
@@ -0,0 +1,21 @@
+import type { DependencyList } from 'react';
+import type { OnyxKey, OnyxValue } from './types';
+type UseOnyxSelector<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>> = (data: OnyxValue<TKey> | undefined) => TReturnValue;
+type UseOnyxOptions<TKey extends OnyxKey, TReturnValue> = {
+    selector?: UseOnyxSelector<TKey, TReturnValue>;
+    canEvict?: boolean;
+    initWithStoredValues?: boolean;
+    allowStaleData?: boolean;
+    reuseConnection?: boolean;
+    allowDynamicKey?: boolean;
+    canBeMissing?: boolean;
+};
+type FetchStatus = 'loading' | 'loaded';
+type ResultMetadata<TValue> = {
+    status: FetchStatus;
+    sourceValue?: NonNullable<TValue> | undefined;
+};
+type UseOnyxResult<TValue> = [NonNullable<TValue> | undefined, ResultMetadata<TValue>];
+declare function useOnyxWithTracking<TKey extends OnyxKey, TReturnValue = OnyxValue<TKey>>(key: TKey, options?: UseOnyxOptions<TKey, TReturnValue>, dependencies?: DependencyList): UseOnyxResult<TReturnValue>;
+export default useOnyxWithTracking;
+export type { FetchStatus, ResultMetadata, UseOnyxResult, UseOnyxOptions, UseOnyxSelector };
diff --git a/node_modules/react-native-onyx/dist/useOnyxWithTracking.js b/node_modules/react-native-onyx/dist/useOnyxWithTracking.js
new file mode 100644
index 0000000..5e80b91
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useOnyxWithTracking.js
@@ -0,0 +1,231 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || function (mod) {
+    if (mod && mod.__esModule) return mod;
+    var result = {};
+    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
+    __setModuleDefault(result, mod);
+    return result;
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const react_1 = require("react");
+const OnyxCache_1 = __importStar(require("./OnyxCache"));
+const OnyxConnectionManager_1 = __importDefault(require("./OnyxConnectionManager"));
+const OnyxUtils_1 = __importDefault(require("./OnyxUtils"));
+const usePrevious_1 = __importDefault(require("./usePrevious"));
+const OnyxSnapshotCache_1 = __importDefault(require("./OnyxSnapshotCache"));
+// Dependency tracking utilities
+function createDependencyTracker() {
+    const tracker = new Set();
+    function createProxy(obj, path = '') {
+        if (!obj || typeof obj !== 'object')
+            return obj;
+        return new Proxy(obj, {
+            get(target, prop) {
+                const fullPath = path ? `${path}.${prop}` : prop;
+                tracker.add(fullPath);
+                const value = target[prop];
+                // Recursively proxy nested objects
+                if (value && typeof value === 'object' && !Array.isArray(value)) {
+                    return createProxy(value, fullPath);
+                }
+                return value;
+            },
+        });
+    }
+    return {
+        tracker,
+        createProxy: (obj) => createProxy(obj),
+        getDependencies: () => Array.from(tracker).sort(),
+        reset: () => tracker.clear(),
+    };
+}
+// Check if object changed based on tracked dependencies
+function hasRelevantChanges(oldObj, newObj, dependencies) {
+    if (oldObj === newObj)
+        return false;
+    if (!oldObj || !newObj)
+        return true;
+    for (const dep of dependencies) {
+        const oldValue = getNestedValue(oldObj, dep);
+        const newValue = getNestedValue(newObj, dep);
+        if (oldValue !== newValue) {
+            return true;
+        }
+    }
+    return false;
+}
+function getNestedValue(obj, path) {
+    return path.split('.').reduce((current, key) => current === null || current === void 0 ? void 0 : current[key], obj);
+}
+function useOnyxWithTracking(key, options, dependencies = []) {
+    const connectionRef = (0, react_1.useRef)(null);
+    const previousKey = (0, usePrevious_1.default)(key);
+    // Dependency tracking state
+    const dependencyTrackerRef = (0, react_1.useRef)(createDependencyTracker());
+    const trackedDependenciesRef = (0, react_1.useRef)([]);
+    const lastInputRef = (0, react_1.useRef)();
+    const lastOutputRef = (0, react_1.useRef)();
+    const hasComputedRef = (0, react_1.useRef)(false);
+    // Create smart memoized selector with dependency tracking
+    const memoizedSelector = (0, react_1.useMemo)(() => {
+        if (!(options === null || options === void 0 ? void 0 : options.selector))
+            return null;
+        return (input) => {
+            // Fast path: reference equality check first
+            if (hasComputedRef.current && lastInputRef.current === input) {
+                return lastOutputRef.current;
+            }
+            // Smart path: check only tracked dependencies
+            if (hasComputedRef.current && trackedDependenciesRef.current.length > 0) {
+                const hasChanges = hasRelevantChanges(lastInputRef.current, input, trackedDependenciesRef.current);
+                if (!hasChanges) {
+                    console.log(`[tracking] No relevant changes detected for key: ${key}, dependencies: [${trackedDependenciesRef.current.join(', ')}]`);
+                    return lastOutputRef.current;
+                }
+            }
+            // Recompute with dependency tracking
+            console.log(`[tracking] Recomputing selector for key: ${key}`);
+            dependencyTrackerRef.current.reset();
+            const proxiedInput = dependencyTrackerRef.current.createProxy(input);
+            const newOutput = options.selector(proxiedInput);
+            // Update tracked dependencies
+            trackedDependenciesRef.current = dependencyTrackerRef.current.getDependencies();
+            console.log(`[tracking] Tracked dependencies for key ${key}: [${trackedDependenciesRef.current.join(', ')}]`);
+            // Cache results
+            lastInputRef.current = input;
+            lastOutputRef.current = newOutput;
+            hasComputedRef.current = true;
+            return newOutput;
+        };
+    }, [options === null || options === void 0 ? void 0 : options.selector, key]);
+    // Rest of useOnyx implementation would be similar to original
+    // but using the smart memoized selector instead of deepEqual
+    const previousValueRef = (0, react_1.useRef)(null);
+    const newValueRef = (0, react_1.useRef)(null);
+    const resultRef = (0, react_1.useRef)([
+        undefined,
+        {
+            status: (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false ? 'loaded' : 'loading',
+        },
+    ]);
+    const isFirstConnectionRef = (0, react_1.useRef)(true);
+    const isConnectingRef = (0, react_1.useRef)(false);
+    const onStoreChangeFnRef = (0, react_1.useRef)(null);
+    const shouldGetCachedValueRef = (0, react_1.useRef)(true);
+    const sourceValueRef = (0, react_1.useRef)(undefined);
+    const cacheKeyRef = (0, react_1.useRef)(null);
+    const currentCacheKey = OnyxSnapshotCache_1.default.generateCacheKey(options);
+    if (cacheKeyRef.current !== currentCacheKey) {
+        cacheKeyRef.current = currentCacheKey;
+    }
+    const getSnapshot = (0, react_1.useCallback)(() => {
+        var _a;
+        const cacheKey = cacheKeyRef.current;
+        const keyStr = key;
+        // Cache check
+        if (!(isFirstConnectionRef.current && (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false) && !shouldGetCachedValueRef.current) {
+            const cachedResult = OnyxSnapshotCache_1.default.getCachedResult(keyStr, cacheKey);
+            if (cachedResult !== undefined) {
+                resultRef.current = cachedResult;
+                return cachedResult;
+            }
+        }
+        let isOnyxValueDefined = true;
+        if (isFirstConnectionRef.current && (options === null || options === void 0 ? void 0 : options.initWithStoredValues) === false) {
+            const result = resultRef.current;
+            OnyxSnapshotCache_1.default.setCachedResult(keyStr, cacheKey, result);
+            return result;
+        }
+        if (isFirstConnectionRef.current || shouldGetCachedValueRef.current) {
+            const value = OnyxUtils_1.default.tryGetCachedValue(key);
+            const selectedValue = memoizedSelector ? memoizedSelector(value) : value;
+            newValueRef.current = (selectedValue !== null && selectedValue !== void 0 ? selectedValue : undefined);
+            isOnyxValueDefined = value !== null && value !== undefined;
+            shouldGetCachedValueRef.current = false;
+        }
+        const hasCacheForKey = OnyxCache_1.default.hasCacheForKey(key);
+        let newFetchStatus;
+        if (isFirstConnectionRef.current && OnyxUtils_1.default.hasPendingMergeForKey(key) && !(options === null || options === void 0 ? void 0 : options.allowStaleData)) {
+            newValueRef.current = undefined;
+            newFetchStatus = 'loading';
+        }
+        // For tracked selectors, use reference equality since tracking handles the rest
+        // For non-selectors, use shallow equality as before
+        const areValuesEqual = memoizedSelector ? previousValueRef.current === newValueRef.current : previousValueRef.current === newValueRef.current; // Could use shallowEqual for non-selector cases
+        const shouldUpdateResult = !areValuesEqual || (previousValueRef.current === null && (hasCacheForKey || OnyxCache_1.default.hasPendingTask(OnyxCache_1.TASK.CLEAR)));
+        if (shouldUpdateResult) {
+            previousValueRef.current = newValueRef.current;
+            const newStatus = newFetchStatus !== null && newFetchStatus !== void 0 ? newFetchStatus : 'loaded';
+            resultRef.current = [
+                (_a = previousValueRef.current) !== null && _a !== void 0 ? _a : undefined,
+                {
+                    status: newStatus,
+                    sourceValue: sourceValueRef.current,
+                },
+            ];
+        }
+        OnyxSnapshotCache_1.default.setCachedResult(keyStr, cacheKey, resultRef.current);
+        return resultRef.current;
+    }, [options === null || options === void 0 ? void 0 : options.initWithStoredValues, options === null || options === void 0 ? void 0 : options.allowStaleData, key, memoizedSelector]);
+    const subscribe = (0, react_1.useCallback)((onStoreChange) => {
+        isConnectingRef.current = true;
+        onStoreChangeFnRef.current = onStoreChange;
+        connectionRef.current = OnyxConnectionManager_1.default.connect({
+            key,
+            callback: (value, callbackKey, sourceValue) => {
+                isConnectingRef.current = false;
+                onStoreChangeFnRef.current = onStoreChange;
+                isFirstConnectionRef.current = false;
+                shouldGetCachedValueRef.current = true;
+                sourceValueRef.current = sourceValue;
+                OnyxSnapshotCache_1.default.invalidateForKey(key);
+                onStoreChange();
+            },
+            initWithStoredValues: options === null || options === void 0 ? void 0 : options.initWithStoredValues,
+            waitForCollectionCallback: OnyxUtils_1.default.isCollectionKey(key),
+            reuseConnection: options === null || options === void 0 ? void 0 : options.reuseConnection,
+        });
+        return () => {
+            if (!connectionRef.current)
+                return;
+            OnyxConnectionManager_1.default.disconnect(connectionRef.current);
+            isFirstConnectionRef.current = false;
+            isConnectingRef.current = false;
+            onStoreChangeFnRef.current = null;
+        };
+    }, [key, options === null || options === void 0 ? void 0 : options.initWithStoredValues, options === null || options === void 0 ? void 0 : options.reuseConnection]);
+    // Reset tracking when dependencies change
+    (0, react_1.useEffect)(() => {
+        if (connectionRef.current === null || isConnectingRef.current || !onStoreChangeFnRef.current) {
+            return;
+        }
+        // Reset dependency tracking
+        trackedDependenciesRef.current = [];
+        hasComputedRef.current = false;
+        OnyxSnapshotCache_1.default.invalidateForKey(key);
+        shouldGetCachedValueRef.current = true;
+        onStoreChangeFnRef.current();
+    }, [...dependencies]);
+    const result = (0, react_1.useSyncExternalStore)(subscribe, getSnapshot);
+    return result;
+}
+exports.default = useOnyxWithTracking;
diff --git a/node_modules/react-native-onyx/dist/useSelector.d.ts b/node_modules/react-native-onyx/dist/useSelector.d.ts
new file mode 100644
index 0000000..f571dc0
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useSelector.d.ts
@@ -0,0 +1,17 @@
+import type { DependencyList } from 'react';
+import type { OnyxKey, OnyxValue } from './types';
+type EntireState = Record<OnyxKey, OnyxValue<OnyxKey>>;
+type UseSelectorSelector<TReturnValue = EntireState> = (state: EntireState) => TReturnValue;
+type UseSelectorOptions<TReturnValue> = {
+    /**
+     * This will be used to subscribe to a subset of the entire Onyx state.
+     * Using this setting can have very positive performance benefits because the component will only re-render
+     * when the subset of data changes. Otherwise, any change of data on any property would normally
+     * cause the component to re-render (and that can be expensive from a performance standpoint).
+     */
+    selector?: UseSelectorSelector<TReturnValue>;
+};
+type UseSelectorResult<TValue> = TValue;
+declare function useSelector<TReturnValue = EntireState>(options?: UseSelectorOptions<TReturnValue>, dependencies?: DependencyList): UseSelectorResult<TReturnValue>;
+export default useSelector;
+export type { UseSelectorOptions, UseSelectorResult, UseSelectorSelector, EntireState };
diff --git a/node_modules/react-native-onyx/dist/useSelector.js b/node_modules/react-native-onyx/dist/useSelector.js
new file mode 100644
index 0000000..0acf49a
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/useSelector.js
@@ -0,0 +1,183 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const fast_equals_1 = require("fast-equals");
+const react_1 = require("react");
+const storage_1 = __importDefault(require("./storage"));
+const useLiveRef_1 = __importDefault(require("./useLiveRef"));
+const metrics_1 = __importDefault(require("./metrics"));
+const GlobalSettings = __importStar(require("./GlobalSettings"));
+const OnyxUtils_1 = __importDefault(require("./OnyxUtils"));
+function useSelector(options, dependencies = []) {
+    const currentDependenciesRef = (0, useLiveRef_1.default)(dependencies);
+    const currentSelectorRef = (0, useLiveRef_1.default)(options === null || options === void 0 ? void 0 : options.selector);
+    // Create memoized version of selector for performance
+    const memoizedSelector = (0, react_1.useMemo)(() => {
+        if (!(options === null || options === void 0 ? void 0 : options.selector))
+            return null;
+        let lastInput;
+        let lastOutput;
+        let lastDependencies = [];
+        let hasComputed = false;
+        return (input) => {
+            const currentDependencies = currentDependenciesRef.current;
+            const currentSelector = currentSelectorRef.current;
+            // Recompute if input changed, dependencies changed, or first time
+            const dependenciesChanged = !(0, fast_equals_1.shallowEqual)(lastDependencies, currentDependencies);
+            if (!hasComputed || !(0, fast_equals_1.shallowEqual)(lastInput, input) || dependenciesChanged) {
+                // Only proceed if we have a valid selector
+                if (currentSelector) {
+                    const newOutput = currentSelector(input);
+                    // Deep equality mode: only update if output actually changed
+                    if (!hasComputed || !(0, fast_equals_1.deepEqual)(lastOutput, newOutput) || dependenciesChanged) {
+                        lastInput = input;
+                        lastOutput = newOutput;
+                        lastDependencies = [...currentDependencies];
+                        hasComputed = true;
+                    }
+                }
+            }
+            return lastOutput;
+        };
+    }, [currentDependenciesRef, currentSelectorRef, options === null || options === void 0 ? void 0 : options.selector]);
+    // Track previous dependencies to prevent infinite loops
+    const previousDependenciesRef = (0, react_1.useRef)([]);
+    // Stores the result from the hook
+    const resultRef = (0, react_1.useRef)();
+    // Connection for listening to changes
+    const connectionRef = (0, react_1.useRef)(null);
+    const listenerRef = (0, react_1.useRef)();
+    // Cached state to avoid expensive storage calls
+    const cachedStateRef = (0, react_1.useRef)({});
+    const isLoadingStateRef = (0, react_1.useRef)(false);
+    // Function to get current state efficiently from storage
+    const getCurrentState = (0, react_1.useCallback)(() => __awaiter(this, void 0, void 0, function* () {
+        if (isLoadingStateRef.current) {
+            return cachedStateRef.current;
+        }
+        isLoadingStateRef.current = true;
+        try {
+            // Get all keys from storage
+            const allKeys = yield storage_1.default.getAllKeys();
+            // Get all values in one batch operation - much faster!
+            const keyValuePairs = yield storage_1.default.multiGet(allKeys);
+            const state = {};
+            keyValuePairs.forEach(([key, value]) => {
+                if (value !== null && value !== undefined) {
+                    state[key] = value;
+                }
+            });
+            cachedStateRef.current = state;
+            return state;
+        }
+        finally {
+            isLoadingStateRef.current = false;
+        }
+    }), []);
+    // Synchronous getter that returns cached state
+    const getCurrentStateSync = (0, react_1.useCallback)(() => {
+        return cachedStateRef.current;
+    }, []);
+    const getSnapshot = (0, react_1.useCallback)(() => {
+        // Get the entire state from cache (synchronous)
+        const entireState = getCurrentStateSync();
+        // Apply selector if provided
+        const selectedValue = memoizedSelector ? memoizedSelector(entireState) : entireState;
+        resultRef.current = selectedValue;
+        return resultRef.current;
+    }, [memoizedSelector, getCurrentStateSync]);
+    const subscribe = (0, react_1.useCallback)((onStoreChange) => {
+        listenerRef.current = onStoreChange;
+        // Initialize the cache on first subscription
+        getCurrentState().then(() => {
+            if (listenerRef.current) {
+                listenerRef.current();
+            }
+        });
+        // Create a connection that uses OnyxUtils.subscribeToKey to listen for any key changes
+        // Since there's no direct way to subscribe to all keys, we'll create a connection
+        // using the connectionManager but with a callback that refreshes our cache
+        const subscriptionId = OnyxUtils_1.default.subscribeToKey({
+            key: '', // Empty key as a wildcard
+            callback: () => {
+                // Refresh cache when any data changes
+                getCurrentState().then(() => {
+                    if (listenerRef.current) {
+                        listenerRef.current();
+                    }
+                });
+            },
+            initWithStoredValues: true,
+        });
+        return () => {
+            OnyxUtils_1.default.unsubscribeFromKey(subscriptionId);
+            listenerRef.current = undefined;
+        };
+    }, [getCurrentState]);
+    // Handle dependency changes
+    (0, react_1.useEffect)(() => {
+        // Deep equality check to prevent infinite loops when dependencies array reference changes
+        // but content remains the same
+        if ((0, fast_equals_1.shallowEqual)(previousDependenciesRef.current, dependencies)) {
+            return;
+        }
+        previousDependenciesRef.current = dependencies;
+        // Force re-computation when dependencies change
+        if (listenerRef.current) {
+            listenerRef.current();
+        }
+    }, [...dependencies]);
+    const getSnapshotDecorated = (0, react_1.useMemo)(() => {
+        if (!GlobalSettings.isPerformanceMetricsEnabled()) {
+            return getSnapshot;
+        }
+        return (0, metrics_1.default)(getSnapshot, 'useSelector.getSnapshot');
+    }, [getSnapshot]);
+    const result = (0, react_1.useSyncExternalStore)(subscribe, getSnapshotDecorated);
+    return result;
+}
+exports.default = useSelector;
diff --git a/node_modules/react-native-onyx/dist/withOnyx/index.d.ts b/node_modules/react-native-onyx/dist/withOnyx/index.d.ts
new file mode 100644
index 0000000..988a5e5
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/withOnyx/index.d.ts
@@ -0,0 +1,15 @@
+/**
+ * This is a higher order component that provides the ability to map a state property directly to
+ * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view
+ * will automatically change to reflect the new data.
+ */
+import React from 'react';
+import type { MapOnyxToState } from './types';
+/**
+ * @deprecated Use `useOnyx` instead of `withOnyx` whenever possible.
+ *
+ * This is a higher order component that provides the ability to map a state property directly to
+ * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view
+ * will automatically change to reflect the new data.
+ */
+export default function <TComponentProps, TOnyxProps>(mapOnyxToState: MapOnyxToState<TComponentProps, TOnyxProps>, shouldDelayUpdates?: boolean): (component: React.ComponentType<TComponentProps>) => React.ComponentType<Omit<TComponentProps, keyof TOnyxProps>>;
diff --git a/node_modules/react-native-onyx/dist/withOnyx/index.js b/node_modules/react-native-onyx/dist/withOnyx/index.js
new file mode 100644
index 0000000..3b313f7
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/withOnyx/index.js
@@ -0,0 +1,332 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.default = default_1;
+/**
+ * This is a higher order component that provides the ability to map a state property directly to
+ * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view
+ * will automatically change to reflect the new data.
+ */
+const react_1 = __importDefault(require("react"));
+const OnyxUtils_1 = __importDefault(require("../OnyxUtils"));
+const Str = __importStar(require("../Str"));
+const utils_1 = __importDefault(require("../utils"));
+const OnyxCache_1 = __importDefault(require("../OnyxCache"));
+const OnyxConnectionManager_1 = __importDefault(require("../OnyxConnectionManager"));
+// This is a list of keys that can exist on a `mapping`, but are not directly related to loading data from Onyx. When the keys of a mapping are looped over to check
+// if a key has changed, it's a good idea to skip looking at these properties since they would have unexpected results.
+const mappingPropertiesToIgnoreChangesTo = ['initialValue', 'allowStaleData'];
+/**
+ * Returns the display name of a component
+ */
+function getDisplayName(component) {
+    return component.displayName || component.name || 'Component';
+}
+/**
+ * Removes all the keys from state that are unrelated to the onyx data being mapped to the component.
+ *
+ * @param state of the component
+ * @param onyxToStateMapping the object holding all of the mapping configuration for the component
+ */
+function getOnyxDataFromState(state, onyxToStateMapping) {
+    return utils_1.default.pick(state, Object.keys(onyxToStateMapping));
+}
+/**
+ * Utility function to return the properly typed entries of the `withOnyx` mapping object.
+ */
+function mapOnyxToStateEntries(mapOnyxToState) {
+    return Object.entries(mapOnyxToState);
+}
+/**
+ * @deprecated Use `useOnyx` instead of `withOnyx` whenever possible.
+ *
+ * This is a higher order component that provides the ability to map a state property directly to
+ * something in Onyx (a key/value store). That way, as soon as data in Onyx changes, the state will be set and the view
+ * will automatically change to reflect the new data.
+ */
+function default_1(mapOnyxToState, shouldDelayUpdates = false) {
+    // A list of keys that must be present in tempState before we can render the WrappedComponent
+    const requiredKeysForInit = Object.keys(utils_1.default.omit(mapOnyxToState, ([, options]) => options.initWithStoredValues === false));
+    return (WrappedComponent) => {
+        const displayName = getDisplayName(WrappedComponent);
+        class withOnyx extends react_1.default.Component {
+            constructor(props) {
+                super(props);
+                this.pendingSetStates = [];
+                this.shouldDelayUpdates = shouldDelayUpdates;
+                this.setWithOnyxState = this.setWithOnyxState.bind(this);
+                this.flushPendingSetStates = this.flushPendingSetStates.bind(this);
+                // This stores all the Onyx connections to be used when the component unmounts so everything can be
+                // disconnected. It is a key value store with the format {[mapping.key]: connection metadata object}.
+                this.activeConnections = {};
+                const cachedState = mapOnyxToStateEntries(mapOnyxToState).reduce((resultObj, [propName, mapping]) => {
+                    const key = Str.result(mapping.key, props);
+                    let value = OnyxUtils_1.default.tryGetCachedValue(key, mapping);
+                    const hasCacheForKey = OnyxCache_1.default.hasCacheForKey(key);
+                    if (!hasCacheForKey && !value && mapping.initialValue) {
+                        value = mapping.initialValue;
+                    }
+                    /**
+                     * If we have a pending merge for a key it could mean that data is being set via Onyx.merge() and someone expects a component to have this data immediately.
+                     *
+                     * @example
+                     *
+                     * Onyx.merge('report_123', value);
+                     * Navigation.navigate(route); // Where "route" expects the "value" to be available immediately once rendered.
+                     *
+                     * In reality, Onyx.merge() will only update the subscriber after all merges have been batched and the previous value is retrieved via a get() (returns a promise).
+                     * So, we won't use the cache optimization here as it will lead us to arbitrarily defer various actions in the application code.
+                     */
+                    const hasPendingMergeForKey = OnyxUtils_1.default.hasPendingMergeForKey(key);
+                    const hasValueInCache = hasCacheForKey || value !== undefined;
+                    const shouldSetState = mapping.initWithStoredValues !== false && ((hasValueInCache && !hasPendingMergeForKey) || !!mapping.allowStaleData);
+                    if (shouldSetState) {
+                        // eslint-disable-next-line no-param-reassign
+                        resultObj[propName] = value;
+                    }
+                    return resultObj;
+                }, {});
+                // If we have all the data we need, then we can render the component immediately
+                cachedState.loading = Object.keys(cachedState).length < requiredKeysForInit.length;
+                // Object holding the temporary initial state for the component while we load the various Onyx keys
+                this.tempState = cachedState;
+                this.state = cachedState;
+            }
+            componentDidMount() {
+                const onyxDataFromState = getOnyxDataFromState(this.state, mapOnyxToState);
+                // Subscribe each of the state properties to the proper Onyx key
+                mapOnyxToStateEntries(mapOnyxToState).forEach(([propName, mapping]) => {
+                    if (mappingPropertiesToIgnoreChangesTo.includes(propName)) {
+                        return;
+                    }
+                    const key = Str.result(mapping.key, Object.assign(Object.assign({}, this.props), onyxDataFromState));
+                    this.connectMappingToOnyx(mapping, propName, key);
+                });
+                this.checkEvictableKeys();
+            }
+            componentDidUpdate(prevProps, prevState) {
+                // The whole purpose of this method is to check to see if a key that is subscribed to Onyx has changed, and then Onyx needs to be disconnected from the old
+                // key and connected to the new key.
+                // For example, a key could change if KeyB depends on data loading from Onyx for KeyA.
+                const isFirstTimeUpdatingAfterLoading = prevState.loading && !this.state.loading;
+                const onyxDataFromState = getOnyxDataFromState(this.state, mapOnyxToState);
+                const prevOnyxDataFromState = getOnyxDataFromState(prevState, mapOnyxToState);
+                mapOnyxToStateEntries(mapOnyxToState).forEach(([propName, mapping]) => {
+                    // Some properties can be ignored because they aren't related to onyx keys and they will never change
+                    if (mappingPropertiesToIgnoreChangesTo.includes(propName)) {
+                        return;
+                    }
+                    // The previous key comes from either:
+                    // 1) The initial key that was connected to (ie. set from `componentDidMount()`)
+                    // 2) The updated props which caused `componentDidUpdate()` to run
+                    // The first case cannot be used all the time because of race conditions where `componentDidUpdate()` can be triggered before connectingMappingToOnyx() is done
+                    // (eg. if a user switches chats really quickly). In this case, it's much more stable to always look at the changes to prevProp and prevState to derive the key.
+                    // The second case cannot be used all the time because the onyx data doesn't change the first time that `componentDidUpdate()` runs after loading. In this case,
+                    // the `mapping.previousKey` must be used for the comparison or else this logic never detects that onyx data could have changed during the loading process.
+                    const previousKey = isFirstTimeUpdatingAfterLoading ? mapping.previousKey : Str.result(mapping.key, Object.assign(Object.assign({}, prevProps), prevOnyxDataFromState));
+                    const newKey = Str.result(mapping.key, Object.assign(Object.assign({}, this.props), onyxDataFromState));
+                    if (previousKey !== newKey) {
+                        OnyxConnectionManager_1.default.disconnect(this.activeConnections[previousKey]);
+                        delete this.activeConnections[previousKey];
+                        this.connectMappingToOnyx(mapping, propName, newKey);
+                    }
+                });
+                this.checkEvictableKeys();
+            }
+            componentWillUnmount() {
+                // Disconnect everything from Onyx
+                mapOnyxToStateEntries(mapOnyxToState).forEach(([, mapping]) => {
+                    const key = Str.result(mapping.key, Object.assign(Object.assign({}, this.props), getOnyxDataFromState(this.state, mapOnyxToState)));
+                    OnyxConnectionManager_1.default.disconnect(this.activeConnections[key]);
+                });
+            }
+            setStateProxy(modifier) {
+                if (this.shouldDelayUpdates) {
+                    this.pendingSetStates.push(modifier);
+                }
+                else {
+                    this.setState(modifier);
+                }
+            }
+            /**
+             * This method is used by the internal raw Onyx `sendDataToConnection`, it is designed to prevent unnecessary renders while a component
+             * still in a "loading" (read "mounting") state. The temporary initial state is saved to the HOC instance and setState()
+             * only called once all the necessary data has been collected.
+             *
+             * There is however the possibility the component could have been updated by a call to setState()
+             * before the data was "initially" collected. A race condition.
+             * For example some update happened on some key, while onyx was still gathering the initial hydration data.
+             * This update is disptached directly to setStateProxy and therefore the component has the most up-to-date data
+             *
+             * This is a design flaw in Onyx itself as dispatching updates before initial hydration is not a correct event flow.
+             * We however need to workaround this issue in the HOC. The addition of initialValue makes things even more complex,
+             * since you cannot be really sure if the component has been updated before or after the initial hydration. Therefore if
+             * initialValue is there, we just check if the update is different than that and then try to handle it as best as we can.
+             */
+            setWithOnyxState(statePropertyName, val) {
+                const prevVal = this.state[statePropertyName];
+                // If the component is not loading (read "mounting"), then we can just update the state
+                // There is a small race condition.
+                // When calling setWithOnyxState we delete the tempState object that is used to hold temporary state updates while the HOC is gathering data.
+                // However the loading flag is only set on the setState callback down below. setState however is an async operation that is also batched,
+                // therefore there is a small window of time where the loading flag is not false but the tempState is already gone
+                // (while the update is queued and waiting to be applied).
+                // This simply bypasses the loading check if the tempState is gone and the update can be safely queued with a normal setStateProxy.
+                if (!this.state.loading || !this.tempState) {
+                    // Performance optimization, do not trigger update with same values
+                    if (prevVal === val || (utils_1.default.isEmptyObject(prevVal) && utils_1.default.isEmptyObject(val))) {
+                        return;
+                    }
+                    const valueWithoutNull = val === null ? undefined : val;
+                    this.setStateProxy({ [statePropertyName]: valueWithoutNull });
+                    return;
+                }
+                this.tempState[statePropertyName] = val;
+                // If some key does not have a value yet, do not update the state yet
+                const tempStateIsMissingKey = requiredKeysForInit.some((key) => { var _a; return !(key in ((_a = this.tempState) !== null && _a !== void 0 ? _a : {})); });
+                if (tempStateIsMissingKey) {
+                    return;
+                }
+                const stateUpdate = Object.assign({}, this.tempState);
+                delete this.tempState;
+                // Full of hacky workarounds to prevent the race condition described above.
+                this.setState((prevState) => {
+                    const finalState = Object.keys(stateUpdate).reduce((result, _key) => {
+                        const key = _key;
+                        if (key === 'loading') {
+                            return result;
+                        }
+                        const initialValue = mapOnyxToState[key].initialValue;
+                        // If initialValue is there and the state contains something different it means
+                        // an update has already been received and we can discard the value we are trying to hydrate
+                        if (initialValue !== undefined && prevState[key] !== undefined && prevState[key] !== initialValue && prevState[key] !== null) {
+                            // eslint-disable-next-line no-param-reassign
+                            result[key] = prevState[key];
+                        }
+                        else if (prevState[key] !== undefined && prevState[key] !== null) {
+                            // if value is already there (without initial value) then we can discard the value we are trying to hydrate
+                            // eslint-disable-next-line no-param-reassign
+                            result[key] = prevState[key];
+                        }
+                        else if (stateUpdate[key] !== null) {
+                            // eslint-disable-next-line no-param-reassign
+                            result[key] = stateUpdate[key];
+                        }
+                        return result;
+                    }, {});
+                    finalState.loading = false;
+                    return finalState;
+                });
+            }
+            /**
+             * Makes sure each Onyx key we requested has been set to state with a value of some kind.
+             * We are doing this so that the wrapped component will only render when all the data
+             * it needs is available to it.
+             */
+            checkEvictableKeys() {
+                // We will add this key to our list of recently accessed keys
+                // if the canEvict function returns true. This is necessary criteria
+                // we MUST use to specify if a key can be removed or not.
+                mapOnyxToStateEntries(mapOnyxToState).forEach(([, mapping]) => {
+                    if (mapping.canEvict === undefined) {
+                        return;
+                    }
+                    const canEvict = !!Str.result(mapping.canEvict, this.props);
+                    const key = Str.result(mapping.key, this.props);
+                    if (!OnyxCache_1.default.isEvictableKey(key)) {
+                        throw new Error(`canEvict can't be used on key '${key}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({evictableKeys: []}).`);
+                    }
+                    if (canEvict) {
+                        OnyxConnectionManager_1.default.removeFromEvictionBlockList(this.activeConnections[key]);
+                    }
+                    else {
+                        OnyxConnectionManager_1.default.addToEvictionBlockList(this.activeConnections[key]);
+                    }
+                });
+            }
+            /**
+             * Takes a single mapping and binds the state of the component to the store
+             *
+             * @param mapping.key key to connect to. can be a string or a
+             * function that takes this.props as an argument and returns a string
+             * @param statePropertyName the name of the state property that Onyx will add the data to
+             * @param [mapping.initWithStoredValues] If set to false, then no data will be prefilled into the
+             *  component
+             * @param key to connect to Onyx with
+             */
+            connectMappingToOnyx(mapping, statePropertyName, key) {
+                const onyxMapping = mapOnyxToState[statePropertyName];
+                // Remember what the previous key was so that key changes can be detected when data is being loaded from Onyx. This will allow
+                // dependent keys to finish loading their data.
+                // eslint-disable-next-line no-param-reassign
+                onyxMapping.previousKey = key;
+                // eslint-disable-next-line rulesdir/prefer-onyx-connect-in-libs
+                this.activeConnections[key] = OnyxConnectionManager_1.default.connect(Object.assign(Object.assign({}, mapping), { key, statePropertyName: statePropertyName, withOnyxInstance: this, displayName }));
+            }
+            flushPendingSetStates() {
+                if (!this.shouldDelayUpdates) {
+                    return;
+                }
+                this.shouldDelayUpdates = false;
+                this.pendingSetStates.forEach((modifier) => {
+                    this.setState(modifier);
+                });
+                this.pendingSetStates = [];
+            }
+            render() {
+                // Remove any null values so that React replaces them with default props
+                const propsToPass = utils_1.default.omit(this.props, ([, propValue]) => propValue === null);
+                if (this.state.loading) {
+                    return null;
+                }
+                // Remove any internal state properties used by withOnyx
+                // that should not be passed to a wrapped component
+                const stateToPass = utils_1.default.omit(this.state, ([stateKey, stateValue]) => stateKey === 'loading' || stateValue === null);
+                // Spreading props and state is necessary in an HOC where the data cannot be predicted
+                return (react_1.default.createElement(WrappedComponent, Object.assign({ markReadyForHydration: this.flushPendingSetStates }, propsToPass, stateToPass, { ref: this.props.forwardedRef })));
+            }
+        }
+        withOnyx.displayName = `withOnyx(${displayName})`;
+        return react_1.default.forwardRef((props, ref) => {
+            const Component = withOnyx;
+            return (react_1.default.createElement(Component
+            // eslint-disable-next-line react/jsx-props-no-spreading
+            , Object.assign({}, props, { forwardedRef: ref })));
+        });
+    };
+}
diff --git a/node_modules/react-native-onyx/dist/withOnyx/types.d.ts b/node_modules/react-native-onyx/dist/withOnyx/types.d.ts
new file mode 100644
index 0000000..e88608e
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/withOnyx/types.d.ts
@@ -0,0 +1,141 @@
+import type { ForwardedRef } from 'react';
+import type { IsEqual } from 'type-fest';
+import type { CollectionKeyBase, ExtractOnyxCollectionValue, KeyValueMapping, OnyxCollection, OnyxEntry, OnyxKey, OnyxValue, Selector } from '../types';
+/**
+ * Represents the base mapping options between an Onyx key and the component's prop.
+ */
+type BaseMapping<TComponentProps, TOnyxProps> = {
+    canEvict?: boolean | ((props: Omit<TComponentProps, keyof TOnyxProps>) => boolean);
+    initWithStoredValues?: boolean;
+    allowStaleData?: boolean;
+};
+/**
+ * Represents the base mapping options when an Onyx collection key is supplied.
+ */
+type CollectionBaseMapping<TOnyxKey extends CollectionKeyBase> = {
+    initialValue?: OnyxCollection<KeyValueMapping[TOnyxKey]>;
+};
+/**
+ * Represents the base mapping options when an Onyx non-collection key is supplied.
+ */
+type EntryBaseMapping<TOnyxKey extends OnyxKey> = {
+    initialValue?: OnyxEntry<KeyValueMapping[TOnyxKey]>;
+};
+/**
+ * Represents the string / function `key` mapping option between an Onyx key and the component's prop.
+ *
+ * If `key` is `string`, the type of the Onyx value that is associated with `key` must match with the type of the component's prop,
+ * otherwise an error will be thrown.
+ *
+ * If `key` is `function`, the return type of `key` function must be a valid Onyx key and the type of the Onyx value associated
+ * with `key` must match with the type of the component's prop, otherwise an error will be thrown.
+ *
+ * @example
+ * ```ts
+ * // Onyx prop with `string` key
+ * onyxProp: {
+ *     key: ONYXKEYS.ACCOUNT,
+ * },
+ *
+ * // Onyx prop with `function` key
+ * onyxProp: {
+ *     key: ({reportId}) => ONYXKEYS.ACCOUNT,
+ * },
+ * ```
+ */
+type BaseMappingKey<TComponentProps, TOnyxProps, TOnyxProp extends keyof TOnyxProps, TOnyxKey extends OnyxKey, TOnyxValue> = IsEqual<TOnyxValue, TOnyxProps[TOnyxProp]> extends true ? {
+    key: TOnyxKey | ((props: Omit<TComponentProps, keyof TOnyxProps> & Partial<TOnyxProps>) => TOnyxKey);
+} : never;
+/**
+ * Represents the string `key` and `selector` mapping options between an Onyx key and the component's prop.
+ *
+ * The function signature and return type of `selector` must match with the type of the component's prop,
+ * otherwise an error will be thrown.
+ *
+ * @example
+ * ```ts
+ * // Onyx prop with `string` key and selector
+ * onyxProp: {
+ *     key: ONYXKEYS.ACCOUNT,
+ *     selector: (value: Account | null): string => value?.id ?? '',
+ * },
+ * ```
+ */
+type BaseMappingStringKeyAndSelector<TComponentProps, TOnyxProps, TReturnType, TOnyxKey extends OnyxKey> = {
+    key: TOnyxKey;
+    selector: Selector<TOnyxKey, TOnyxProps, TReturnType>;
+};
+/**
+ * Represents the function `key` and `selector` mapping options between an Onyx key and the component's prop.
+ *
+ * The function signature and return type of `selector` must match with the type of the component's prop,
+ * otherwise an error will be thrown.
+ *
+ * @example
+ * ```ts
+ * // Onyx prop with `function` key and selector
+ * onyxProp: {
+ *     key: ({reportId}) => ONYXKEYS.ACCOUNT,
+ *     selector: (value: Account | null) => value?.id ?? '',
+ * },
+ * ```
+ */
+type BaseMappingFunctionKeyAndSelector<TComponentProps, TOnyxProps, TReturnType, TOnyxKey extends OnyxKey> = {
+    key: (props: Omit<TComponentProps, keyof TOnyxProps> & Partial<TOnyxProps>) => TOnyxKey;
+    selector: Selector<TOnyxKey, TOnyxProps, TReturnType>;
+};
+/**
+ * Represents the mapping options between an Onyx key and the component's prop with all its possibilities.
+ */
+type Mapping<TComponentProps, TOnyxProps, TOnyxProp extends keyof TOnyxProps, TOnyxKey extends OnyxKey> = BaseMapping<TComponentProps, TOnyxProps> & EntryBaseMapping<TOnyxKey> & (BaseMappingKey<TComponentProps, TOnyxProps, TOnyxProp, TOnyxKey, OnyxEntry<KeyValueMapping[TOnyxKey]>> | BaseMappingStringKeyAndSelector<TComponentProps, TOnyxProps, TOnyxProps[TOnyxProp], TOnyxKey> | BaseMappingFunctionKeyAndSelector<TComponentProps, TOnyxProps, TOnyxProps[TOnyxProp], TOnyxKey>);
+/**
+ * Represents a superset of `Mapping` type with internal properties included.
+ */
+type WithOnyxMapping<TComponentProps, TOnyxProps> = Mapping<TComponentProps, TOnyxProps, keyof TOnyxProps, OnyxKey> & {
+    subscriptionID: number;
+    previousKey?: OnyxKey;
+};
+/**
+ * Represents the mapping options between an Onyx collection key without suffix and the component's prop with all its possibilities.
+ */
+type CollectionMapping<TComponentProps, TOnyxProps, TOnyxProp extends keyof TOnyxProps, TOnyxKey extends CollectionKeyBase> = BaseMapping<TComponentProps, TOnyxProps> & CollectionBaseMapping<TOnyxKey> & (BaseMappingKey<TComponentProps, TOnyxProps, TOnyxProp, TOnyxKey, OnyxCollection<KeyValueMapping[TOnyxKey]>> | BaseMappingStringKeyAndSelector<TComponentProps, TOnyxProps, ExtractOnyxCollectionValue<TOnyxProps[TOnyxProp]>, TOnyxKey> | BaseMappingFunctionKeyAndSelector<TComponentProps, TOnyxProps, ExtractOnyxCollectionValue<TOnyxProps[TOnyxProp]>, TOnyxKey>);
+/**
+ * Represents an union type of all the possible Onyx key mappings.
+ * Each `OnyxPropMapping` will be associated with its respective Onyx key, ensuring different type-safety for each object.
+ */
+type OnyxPropMapping<TComponentProps, TOnyxProps, TOnyxProp extends keyof TOnyxProps> = {
+    [TOnyxKey in OnyxKey]: Mapping<TComponentProps, TOnyxProps, TOnyxProp, TOnyxKey>;
+}[OnyxKey];
+/**
+ * Represents an union type of all the possible Onyx collection keys without suffix mappings.
+ * Each `OnyxPropCollectionMapping` will be associated with its respective Onyx key, ensuring different type-safety for each object.
+ */
+type OnyxPropCollectionMapping<TComponentProps, TOnyxProps, TOnyxProp extends keyof TOnyxProps> = {
+    [TOnyxKey in CollectionKeyBase]: CollectionMapping<TComponentProps, TOnyxProps, TOnyxProp, TOnyxKey>;
+}[CollectionKeyBase];
+/**
+ * Represents an Onyx mapping object that connects Onyx keys to component's props.
+ */
+type MapOnyxToState<TComponentProps, TOnyxProps> = {
+    [TOnyxProp in keyof TOnyxProps]: OnyxPropMapping<TComponentProps, TOnyxProps, TOnyxProp> | OnyxPropCollectionMapping<TComponentProps, TOnyxProps, TOnyxProp>;
+};
+/**
+ * Represents the `withOnyx` internal component props.
+ */
+type WithOnyxProps<TComponentProps, TOnyxProps> = Omit<TComponentProps, keyof TOnyxProps> & {
+    forwardedRef?: ForwardedRef<unknown>;
+};
+/**
+ * Represents the `withOnyx` internal component state.
+ */
+type WithOnyxState<TOnyxProps> = TOnyxProps & {
+    loading: boolean;
+};
+/**
+ * Represents the `withOnyx` internal component instance.
+ */
+type WithOnyxInstance = React.Component<unknown, WithOnyxState<KeyValueMapping>> & {
+    setStateProxy: (modifier: Record<string, OnyxCollection<KeyValueMapping[OnyxKey]>> | ((state: Record<string, OnyxCollection<KeyValueMapping[OnyxKey]>>) => OnyxValue<OnyxKey>)) => void;
+    setWithOnyxState: (statePropertyName: OnyxKey, value: OnyxValue<OnyxKey>) => void;
+};
+export type { WithOnyxMapping, MapOnyxToState, WithOnyxProps, WithOnyxInstance, WithOnyxState };
diff --git a/node_modules/react-native-onyx/dist/withOnyx/types.js b/node_modules/react-native-onyx/dist/withOnyx/types.js
new file mode 100644
index 0000000..c8ad2e5
--- /dev/null
+++ b/node_modules/react-native-onyx/dist/withOnyx/types.js
@@ -0,0 +1,2 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
