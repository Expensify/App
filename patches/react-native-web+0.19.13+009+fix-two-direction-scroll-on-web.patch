diff --git a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
index 1b8a228..ea8275c 100644
--- a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
+++ b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
@@ -323,6 +323,7 @@ class VirtualizedList extends StateSafePureComponent {
     this._nestedChildLists = new ChildListCollection();
     this._offsetFromParentVirtualizedList = 0;
     this._prevParentOffset = 0;
+    this._prevDataLength = 0;
     this._scrollMetrics = {
       contentLength: 0,
       dOffset: 0,
@@ -356,12 +357,12 @@ class VirtualizedList extends StateSafePureComponent {
           // $FlowFixMe[incompatible-use]
           React.createElement(ScrollView, _extends({}, props, {
             refreshControl: props.refreshControl == null ? /*#__PURE__*/React.createElement(RefreshControl
-            // $FlowFixMe[incompatible-type]
-            , {
-              refreshing: props.refreshing,
-              onRefresh: onRefresh,
-              progressViewOffset: props.progressViewOffset
-            }) : props.refreshControl
+              // $FlowFixMe[incompatible-type]
+              , {
+                refreshing: props.refreshing,
+                onRefresh: onRefresh,
+                progressViewOffset: props.progressViewOffset
+              }) : props.refreshControl
           }))
         );
       } else {
@@ -383,6 +384,20 @@ class VirtualizedList extends StateSafePureComponent {
         this._totalCellLength += next.length - (curr ? curr.length : 0);
         this._totalCellsMeasured += curr ? 0 : 1;
         this._averageCellLength = this._totalCellLength / this._totalCellsMeasured;
+        if (index < Object.keys(this._frames).length) {
+          const doesFrameWithTheSameIndexExist = Object.entries(this._frames).some(([key, frame]) => frame.index === index && key !== cellKey);
+          if (doesFrameWithTheSameIndexExist) {
+            Object.keys(this._frames).forEach(key => {
+              if (this._frames[key].index >= index) {
+                this._frames[key] = {
+                  ...this._frames[key],
+                  offset: this._frames[key].offset + next.length,
+                  index: this._frames[key].index + 1,
+                }
+              }
+            });
+          }
+        };
         this._frames[cellKey] = next;
         this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);
         this._scheduleCellsToRenderUpdate();
@@ -397,9 +412,22 @@ class VirtualizedList extends StateSafePureComponent {
       delete this._cellRefs[cellKey];
       var curr = this._frames[cellKey];
       if (curr) {
-        this._frames[cellKey] = _objectSpread(_objectSpread({}, curr), {}, {
-          inLayout: false
-        });
+        if (this._prevDataLength !== this.props.data.length) {
+          Object.keys(this._frames).forEach(key => {
+            if (this._frames[key].index > curr.index) {
+              this._frames[key] = {
+                ...this._frames[key],
+                offset: this._frames[key].offset - curr.length,
+                index: this._frames[key].index - 1,
+              }
+            }
+          });
+          delete this._frames[cellKey];
+        } else {
+          this._frames[cellKey] = _objectSpread(_objectSpread({}, curr), {}, {
+            inLayout: false
+          });
+        }
       }
     };
     this._onLayout = e => {
@@ -580,7 +608,7 @@ class VirtualizedList extends StateSafePureComponent {
       });
     };
     this._createViewToken = (index, isViewable, props
-    // $FlowFixMe[missing-local-annot]
+      // $FlowFixMe[missing-local-annot]
     ) => {
       var data = props.data,
         getItem = props.getItem;
@@ -703,40 +731,41 @@ class VirtualizedList extends StateSafePureComponent {
     // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
     // For issue https://github.com/necolas/react-native-web/issues/995
     this.invertedWheelEventHandler = (ev) => {
-        const isHorizontal = this.props.horizontal;
-        const deltaX = ev.deltaX || ev.wheelDeltaX || 0;
-        const deltaY = ev.deltaY || ev.wheelDeltaY || 0;
-
-        const scrollOffset = isHorizontal ? ev.target.scrollLeft : ev.target.scrollTop;
-        const scrollLength = isHorizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
-        const clientLength = isHorizontal ? ev.target.clientWidth : ev.target.clientHeight;
-        const isEventTargetScrollable = scrollLength > clientLength;
-        const delta = isHorizontal ? deltaX : deltaY;
-        let leftoverDelta = delta;
-        if (isEventTargetScrollable) {
-            leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
-        }
-        const targetDelta = delta - leftoverDelta;
-        if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
-            const node = this._scrollRef.getScrollableNode();
-            if (isHorizontal) {
-                ev.target.scrollLeft += targetDelta;
-                const nextScrollLeft = node.scrollLeft - leftoverDelta;
-                node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
+      const isHorizontal = this.props.horizontal;
+      const deltaX = ev.deltaX || ev.wheelDeltaX || 0;
+      const deltaY = ev.deltaY || ev.wheelDeltaY || 0;
 
-                if (Math.abs(deltaX) > Math.abs(deltaY)) {
-                    ev.preventDefault();
-                }
-            } else {
-                ev.target.scrollTop += targetDelta;
-                const nextScrollTop = node.scrollTop - leftoverDelta;
-                node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
+      const scrollOffset = isHorizontal ? ev.target.scrollLeft : ev.target.scrollTop;
+      const scrollLength = isHorizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
+      const clientLength = isHorizontal ? ev.target.clientWidth : ev.target.clientHeight;
+      const isEventTargetScrollable = scrollLength > clientLength;
+      const delta = isHorizontal ? deltaX : deltaY;
+      let leftoverDelta = delta;
+      if (isEventTargetScrollable) {
+        leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
+      }
+      const targetDelta = delta - leftoverDelta;
+      if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
+        const node = this._scrollRef.getScrollableNode();
 
-                if (Math.abs(deltaY) > Math.abs(deltaX)) {
-                    ev.preventDefault();
-                }
-            }
+        if (isHorizontal) {
+          if (Math.abs(deltaX) > Math.abs(deltaY)) {
+            ev.target.scrollLeft += targetDelta;
+            const nextScrollLeft = node.scrollLeft - leftoverDelta;
+            node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
+            ev.preventDefault();
+            ev.stopPropagation();
+          }
+        } else {
+          if (Math.abs(deltaY) > Math.abs(deltaX)) {
+            ev.target.scrollTop += targetDelta;
+            const nextScrollTop = node.scrollTop - leftoverDelta;
+            node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
+            ev.preventDefault();
+            ev.stopPropagation();
+          }
         }
+      }
     };
   }
   _checkProps(props) {
@@ -746,8 +775,8 @@ class VirtualizedList extends StateSafePureComponent {
       data = props.data,
       initialScrollIndex = props.initialScrollIndex;
     invariant(
-    // $FlowFixMe[prop-missing]
-    !onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
+      // $FlowFixMe[prop-missing]
+      !onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');
     invariant(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');
     invariant(getItemCount, 'VirtualizedList: The "getItemCount" prop must be provided');
     var itemCount = getItemCount(data);
@@ -1067,34 +1096,34 @@ class VirtualizedList extends StateSafePureComponent {
         stickyHeaderIndices.push(0);
       }
       var _element = /*#__PURE__*/React.isValidElement(ListHeaderComponent) ? ListHeaderComponent :
-      /*#__PURE__*/
-      // $FlowFixMe[not-a-component]
-      // $FlowFixMe[incompatible-type-arg]
-      React.createElement(ListHeaderComponent, null);
+        /*#__PURE__*/
+        // $FlowFixMe[not-a-component]
+        // $FlowFixMe[incompatible-type-arg]
+        React.createElement(ListHeaderComponent, null);
       cells.push(/*#__PURE__*/React.createElement(VirtualizedListCellContextProvider, {
         cellKey: this._getCellKey() + '-header',
         key: "$header"
       }, /*#__PURE__*/React.createElement(View
-      // We expect that header component will be a single native view so make it
-      // not collapsable to avoid this view being flattened and make this assumption
-      // no longer true.
-      , {
-        collapsable: false,
-        onLayout: this._onLayoutHeader,
-        style: [inversionStyle, this.props.ListHeaderComponentStyle]
-      },
-      // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
-      _element)));
+        // We expect that header component will be a single native view so make it
+        // not collapsable to avoid this view being flattened and make this assumption
+        // no longer true.
+        , {
+          collapsable: false,
+          onLayout: this._onLayoutHeader,
+          style: [inversionStyle, this.props.ListHeaderComponentStyle]
+        },
+        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
+        _element)));
     }
 
     // 2a. Add a cell for ListEmptyComponent if applicable
     var itemCount = this.props.getItemCount(data);
     if (itemCount === 0 && ListEmptyComponent) {
       var _element2 = /*#__PURE__*/React.isValidElement(ListEmptyComponent) ? ListEmptyComponent :
-      /*#__PURE__*/
-      // $FlowFixMe[not-a-component]
-      // $FlowFixMe[incompatible-type-arg]
-      React.createElement(ListEmptyComponent, null);
+        /*#__PURE__*/
+        // $FlowFixMe[not-a-component]
+        // $FlowFixMe[incompatible-type-arg]
+        React.createElement(ListEmptyComponent, null);
       cells.push(/*#__PURE__*/React.createElement(VirtualizedListCellContextProvider, {
         cellKey: this._getCellKey() + '-empty',
         key: "$empty"
@@ -1154,10 +1183,10 @@ class VirtualizedList extends StateSafePureComponent {
     // 3. Add cell for ListFooterComponent
     if (ListFooterComponent) {
       var _element3 = /*#__PURE__*/React.isValidElement(ListFooterComponent) ? ListFooterComponent :
-      /*#__PURE__*/
-      // $FlowFixMe[not-a-component]
-      // $FlowFixMe[incompatible-type-arg]
-      React.createElement(ListFooterComponent, null);
+        /*#__PURE__*/
+        // $FlowFixMe[not-a-component]
+        // $FlowFixMe[incompatible-type-arg]
+        React.createElement(ListFooterComponent, null);
       cells.push(/*#__PURE__*/React.createElement(VirtualizedListCellContextProvider, {
         cellKey: this._getFooterCellKey(),
         key: "$footer"
@@ -1165,8 +1194,8 @@ class VirtualizedList extends StateSafePureComponent {
         onLayout: this._onLayoutFooter,
         style: [inversionStyle, this.props.ListFooterComponentStyle]
       },
-      // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
-      _element3)));
+        // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors
+        _element3)));
     }
 
     // 4. Render the ScrollView
@@ -1240,6 +1269,7 @@ class VirtualizedList extends StateSafePureComponent {
     var _this$props7 = this.props,
       data = _this$props7.data,
       extraData = _this$props7.extraData;
+    this._prevDataLength = prevProps.data.length;
     if (data !== prevProps.data || extraData !== prevProps.extraData) {
       // clear the viewableIndices cache to also trigger
       // the onViewableItemsChanged callback with the new data
@@ -1262,7 +1292,7 @@ class VirtualizedList extends StateSafePureComponent {
     }
 
     if (this.state.cellsAroundViewport.first !== prevState.cellsAroundViewport.first ||
-        this.state.cellsAroundViewport.last !== prevState.cellsAroundViewport.last) {
+      this.state.cellsAroundViewport.last !== prevState.cellsAroundViewport.last) {
       this._maybeCallOnEdgeReached();
     }
   }
