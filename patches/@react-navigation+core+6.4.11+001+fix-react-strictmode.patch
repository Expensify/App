diff --git a/node_modules/@react-navigation/core/lib/module/useNavigationBuilder.js b/node_modules/@react-navigation/core/lib/module/useNavigationBuilder.js
index 051520b..bd76110 100644
--- a/node_modules/@react-navigation/core/lib/module/useNavigationBuilder.js
+++ b/node_modules/@react-navigation/core/lib/module/useNavigationBuilder.js
@@ -173,18 +173,7 @@ export default function useNavigationBuilder(createRouter, options) {
     getKey,
     getIsInitial
   } = React.useContext(NavigationStateContext);
-  const stateCleanedUp = React.useRef(false);
-  const cleanUpState = React.useCallback(() => {
-    setCurrentState(undefined);
-    stateCleanedUp.current = true;
-  }, [setCurrentState]);
   const setState = React.useCallback(state => {
-    if (stateCleanedUp.current) {
-      // State might have been already cleaned up due to unmount
-      // We do not want to expose API allowing to override this
-      // This would lead to old data preservation on main navigator unmount
-      return;
-    }
     setCurrentState(state);
   }, [setCurrentState]);
   const [initializedState, isFirstStateInitialization] = React.useMemo(() => {
@@ -298,17 +287,6 @@ export default function useNavigationBuilder(createRouter, options) {
       // This is necessary for proper screen tracking, URL updates etc.
       setState(nextState);
     }
-    return () => {
-      // We need to clean up state for this navigator on unmount
-      // We do it in a timeout because we need to detect if another navigator mounted in the meantime
-      // For example, if another navigator has started rendering, we should skip cleanup
-      // Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it
-      setTimeout(() => {
-        if (getCurrentState() !== undefined && getKey() === navigatorKey) {
-          cleanUpState();
-        }
-      }, 0);
-    };
     // eslint-disable-next-line react-hooks/exhaustive-deps
   }, []);
 
diff --git a/node_modules/@react-navigation/core/src/useNavigationBuilder.tsx b/node_modules/@react-navigation/core/src/useNavigationBuilder.tsx
index b1971ba..1da31d2 100644
--- a/node_modules/@react-navigation/core/src/useNavigationBuilder.tsx
+++ b/node_modules/@react-navigation/core/src/useNavigationBuilder.tsx
@@ -360,21 +360,8 @@ export default function useNavigationBuilder<
     getIsInitial,
   } = React.useContext(NavigationStateContext);
 
-  const stateCleanedUp = React.useRef(false);
-
-  const cleanUpState = React.useCallback(() => {
-    setCurrentState(undefined);
-    stateCleanedUp.current = true;
-  }, [setCurrentState]);
-
   const setState = React.useCallback(
     (state: NavigationState | PartialState<NavigationState> | undefined) => {
-      if (stateCleanedUp.current) {
-        // State might have been already cleaned up due to unmount
-        // We do not want to expose API allowing to override this
-        // This would lead to old data preservation on main navigator unmount
-        return;
-      }
       setCurrentState(state);
     },
     [setCurrentState]
@@ -548,18 +535,6 @@ export default function useNavigationBuilder<
       // This is necessary for proper screen tracking, URL updates etc.
       setState(nextState);
     }
-
-    return () => {
-      // We need to clean up state for this navigator on unmount
-      // We do it in a timeout because we need to detect if another navigator mounted in the meantime
-      // For example, if another navigator has started rendering, we should skip cleanup
-      // Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it
-      setTimeout(() => {
-        if (getCurrentState() !== undefined && getKey() === navigatorKey) {
-          cleanUpState();
-        }
-      }, 0);
-    };
     // eslint-disable-next-line react-hooks/exhaustive-deps
   }, []);
 
