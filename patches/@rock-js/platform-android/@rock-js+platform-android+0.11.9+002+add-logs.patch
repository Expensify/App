diff --git a/node_modules/@rock-js/platform-android/dist/src/lib/commands/signAndroid/signAndroid.js b/node_modules/@rock-js/platform-android/dist/src/lib/commands/signAndroid/signAndroid.js
index bf00b00..dddcd13 100644
--- a/node_modules/@rock-js/platform-android/dist/src/lib/commands/signAndroid/signAndroid.js
+++ b/node_modules/@rock-js/platform-android/dist/src/lib/commands/signAndroid/signAndroid.js
@@ -1,6 +1,6 @@
 import fs from 'node:fs';
 import path from 'node:path';
-import { colorLink, getDotRockPath, intro, outro, relativeToCwd, RockError, spawn, spinner, } from '@rock-js/tools';
+import { colorLink, getDotRockPath, intro, logger, outro, relativeToCwd, RockError, spawn, spinner, } from '@rock-js/tools';
 import AdmZip from 'adm-zip';
 import { findAndroidBuildTool, getAndroidBuildToolsPath } from '../../paths.js';
 import { buildJsBundle } from './bundle.js';
@@ -17,12 +17,20 @@ export async function signAndroid(options) {
     if (options.buildJsBundle) {
         const bundleOutputPath = path.join(tempPath, 'index.android.bundle');
         loader.start('Building JS bundle...');
+        logger.log(`Building bundle to: ${bundleOutputPath}`);
+        logger.log(`Assets destination: ${path.join(tempPath, 'res')}`);
+        logger.log(`Use Hermes: ${options.useHermes ?? true}`);
         await buildJsBundle({
             bundleOutputPath,
             assetsDestPath: path.join(tempPath, 'res'),
             sourcemapOutputPath: path.join(tempPath, 'index.android.bundle.packager.map'),
             useHermes: options.useHermes ?? true,
         });
+        // Log bundle info after building
+        if (fs.existsSync(bundleOutputPath)) {
+            const bundleSize = fs.statSync(bundleOutputPath).size;
+            logger.log(`Built bundle size: ${bundleSize} bytes`);
+        }
         loader.stop(`Built JS bundle: ${colorLink(relativeToCwd(bundleOutputPath))}`);
         options.jsBundlePath = bundleOutputPath;
     }
@@ -30,10 +38,29 @@ export async function signAndroid(options) {
     const tempArchivePath = path.join(tempPath, `output-app.${extension}`);
     loader.start(`Initializing output ${extension.toUpperCase()}...`);
     try {
+        logger.log(`Reading APK: ${options.binaryPath}`);
         const zip = new AdmZip(options.binaryPath);
+        // Log APK contents before modification
+        const entries = zip.getEntries();
+        logger.log(`APK contains ${entries.length} entries`);
+        // Log signature-related files
+        const signatureFiles = entries.filter((e) => e.entryName.startsWith('META-INF/') &&
+            (e.entryName.endsWith('.SF') ||
+                e.entryName.endsWith('.RSA') ||
+                e.entryName.endsWith('.DSA') ||
+                e.entryName === 'META-INF/MANIFEST.MF'));
+        logger.log(`Found ${signatureFiles.length} signature files: ${signatureFiles.map((f) => f.entryName).join(', ')}`);
+        // Log bundle compression
+        const bundleEntry = entries.find((e) => e.entryName === 'assets/index.android.bundle');
+        if (bundleEntry) {
+            const compressionMethod = bundleEntry.header.method === 0 ? 'STORED' : 'DEFLATED';
+            logger.log(`Original bundle compression: ${compressionMethod} (method=${bundleEntry.header.method})`);
+        }
         // Remove old signature files
         zip.deleteFile('META-INF/*');
+        logger.log(`Removed META-INF/* files`);
         zip.writeZip(tempArchivePath);
+        logger.log(`Wrote temporary APK: ${tempArchivePath}`);
     }
     catch (error) {
         throw new RockError(`Failed to initialize output file: ${options.outputPath}`, { cause: error.stderr });
@@ -79,11 +106,32 @@ function validateOptions(options) {
 }
 async function replaceJsBundle({ archivePath, jsBundlePath, }) {
     try {
+        logger.log(`Replacing bundle in: ${archivePath}`);
+        logger.log(`New bundle path: ${jsBundlePath}`);
+        logger.log(`Bundle size: ${fs.statSync(jsBundlePath).size} bytes`);
         const zip = new AdmZip(archivePath);
         const assetsPath = isAab(archivePath) ? 'base/assets' : 'assets';
-        zip.deleteFile(path.join(assetsPath, 'index.android.bundle'));
+        const bundlePath = path.join(assetsPath, 'index.android.bundle');
+        // Log old bundle info
+        const oldEntry = zip.getEntry(bundlePath);
+        if (oldEntry) {
+            const oldMethod = oldEntry.header.method === 0 ? 'STORED' : 'DEFLATED';
+            logger.log(`Old bundle compression: ${oldMethod} (method=${oldEntry.header.method})`);
+            logger.log(`Old bundle size: ${oldEntry.header.size} bytes`);
+        }
+        zip.deleteFile(bundlePath);
+        logger.log(`Deleted old bundle: ${bundlePath}`);
         zip.addLocalFile(jsBundlePath, assetsPath, 'index.android.bundle');
+        logger.log(`Added new bundle using addLocalFile()`);
+        // Log new bundle info
+        const newEntry = zip.getEntry(bundlePath);
+        if (newEntry) {
+            const newMethod = newEntry.header.method === 0 ? 'STORED' : 'DEFLATED';
+            logger.log(`New bundle compression: ${newMethod} (method=${newEntry.header.method})`);
+            logger.log(`New bundle compressed size: ${newEntry.header.compressedSize} bytes`);
+        }
         zip.writeZip(archivePath);
+        logger.log(`Wrote updated APK: ${archivePath}`);
     }
     catch (error) {
         throw new RockError(`Failed to replace JS bundle in destination file: ${archivePath}`, { cause: error });
@@ -111,8 +159,15 @@ Please follow instructions at: https://reactnative.dev/docs/set-up-your-environm
         inputArchivePath,
         outputPath,
     ];
+    logger.log(`Running zipalign: ${zipAlignPath} ${zipalignArgs.join(' ')}`);
+    logger.log(`Input: ${inputArchivePath}`);
+    logger.log(`Output: ${outputPath}`);
     try {
-        await spawn(zipAlignPath, zipalignArgs);
+        const result = await spawn(zipAlignPath, zipalignArgs);
+        logger.log(`zipalign completed successfully`);
+        if (result.stdout) {
+            logger.log(`zipalign output: ${result.stdout}`);
+        }
     }
     catch (error) {
         throw new RockError(`Failed to align archive file: ${zipAlignPath} ${zipalignArgs.join(' ')}`, { cause: error.stderr });
@@ -139,8 +194,41 @@ Please follow instructions at: https://reactnative.dev/docs/set-up-your-environm
         ...(isAab(binaryPath) ? ['--min-sdk-version', '36'] : []),
         binaryPath,
     ];
+    logger.log(`Running apksigner: ${apksignerPath}`);
+    logger.log(`Signing: ${binaryPath}`);
+    logger.log(`Keystore: ${keystorePath}`);
+    logger.log(`Key alias: ${keyAlias || 'default'}`);
     try {
         await spawn(apksignerPath, apksignerArgs);
+        logger.log(`apksigner completed successfully`);
+        // Verify the signature
+        logger.log(`Verifying signature...`);
+        const verifyResult = await spawn(apksignerPath, [
+            'verify',
+            '-v',
+            binaryPath,
+        ]);
+        logger.log(`Signature verification: ${verifyResult.stdout}`);
+        // Check what signature schemes were applied
+        const zip = new AdmZip(binaryPath);
+        const entries = zip.getEntries();
+        const v1Files = entries.filter((e) => e.entryName.startsWith('META-INF/') &&
+            (e.entryName.endsWith('.SF') ||
+                e.entryName.endsWith('.RSA') ||
+                e.entryName.endsWith('.DSA') ||
+                e.entryName === 'META-INF/MANIFEST.MF'));
+        logger.log(`V1 signature files present: ${v1Files.length > 0 ? 'YES' : 'NO'}`);
+        if (v1Files.length > 0) {
+            logger.log(`V1 files: ${v1Files.map((f) => f.entryName).join(', ')}`);
+        }
+        // Log final bundle compression
+        const bundleEntry = entries.find((e) => e.entryName === 'assets/index.android.bundle');
+        if (bundleEntry) {
+            const compressionMethod = bundleEntry.header.method === 0 ? 'STORED' : 'DEFLATED';
+            logger.log(`Final bundle compression: ${compressionMethod} (method=${bundleEntry.header.method})`);
+            logger.log(`Final bundle size: ${bundleEntry.header.size} bytes`);
+            logger.log(`Final bundle compressed size: ${bundleEntry.header.compressedSize} bytes`);
+        }
     }
     catch (error) {
         throw new RockError(`Failed to sign APK file: ${apksignerPath} ${apksignerArgs.join(' ')}`, { cause: error.stderr });
