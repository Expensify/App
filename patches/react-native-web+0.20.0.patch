diff --git a/node_modules/react-native-web/dist/exports/Image/index.js b/node_modules/react-native-web/dist/exports/Image/index.js
index 348831d..ca40ee8 100644
--- a/node_modules/react-native-web/dist/exports/Image/index.js
+++ b/node_modules/react-native-web/dist/exports/Image/index.js
@@ -137,7 +137,22 @@ function resolveAssetUri(source) {
   }
   return uri;
 }
-var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
+function raiseOnErrorEvent(uri, _ref) {
+  var onError = _ref.onError,
+    onLoadEnd = _ref.onLoadEnd;
+  if (onError) {
+    onError({
+      nativeEvent: {
+        error: "Failed to load resource " + uri
+      }
+    });
+  }
+  if (onLoadEnd) onLoadEnd();
+}
+function hasSourceDiff(a, b) {
+  return a.uri !== b.uri || JSON.stringify(a.headers) !== JSON.stringify(b.headers);
+}
+var BaseImage = /*#__PURE__*/React.forwardRef((props, ref) => {
   var _ariaLabel = props['aria-label'],
     accessibilityLabel = props.accessibilityLabel,
     blurRadius = props.blurRadius,
@@ -240,16 +255,10 @@ var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
         }
       }, function error() {
         updateState(ERRORED);
-        if (onError) {
-          onError({
-            nativeEvent: {
-              error: "Failed to load resource " + uri
-            }
-          });
-        }
-        if (onLoadEnd) {
-          onLoadEnd();
-        }
+        raiseOnErrorEvent(uri, {
+          onError,
+          onLoadEnd
+        });
       });
     }
     function abortPendingRequest() {
@@ -281,10 +290,79 @@ var Image = /*#__PURE__*/React.forwardRef((props, ref) => {
     suppressHydrationWarning: true
   }), hiddenImage, createTintColorSVG(tintColor, filterRef.current));
 });
-Image.displayName = 'Image';
+BaseImage.displayName = 'Image';
+
+/**
+ * This component handles specifically loading an image source with headers
+ * default source is never loaded using headers
+ */
+var ImageWithHeaders = /*#__PURE__*/React.forwardRef((props, ref) => {
+  // $FlowIgnore: This component would only be rendered when `source` matches `ImageSource`
+  var nextSource = props.source;
+  var _React$useState3 = React.useState(''),
+    blobUri = _React$useState3[0],
+    setBlobUri = _React$useState3[1];
+  var request = React.useRef(null);
+  var onError = props.onError,
+    onLoadStart = props.onLoadStart,
+    onLoadEnd = props.onLoadEnd;
+  React.useEffect(() => {
+    if (request.current !== null && !hasSourceDiff(nextSource, request.current.source)) {
+      return;
+    }
+
+    // When source changes we want to clean up any old/running requests
+    if (request.current !== null) {
+      request.current.cancel();
+    }
+
+    if (onLoadStart) {
+      onLoadStart();
+    }
+
+    // Store a ref for the current load request so we know what's the last loaded source,
+    // and so we can cancel it if a different source is passed through props
+    request.current = ImageLoader.loadWithHeaders(nextSource);
+    request.current.promise.then(uri => setBlobUri(uri)).catch(() => raiseOnErrorEvent(request.current.source.uri, {
+      onError,
+      onLoadEnd
+    }));
+  }, [nextSource, onLoadStart, onError, onLoadEnd]);
+
+  // Cancel any request on unmount
+  React.useEffect(() => () => {
+    if (request.current !== null) {
+      request.current.cancel();
+      request.current = null;
+    }
+  }, []);
+  var propsToPass = _objectSpread(_objectSpread({}, props), {}, {
+    // `onLoadStart` is called from the current component
+    // We skip passing it down to prevent BaseImage raising it a 2nd time
+    onLoadStart: undefined,
+    // Until the current component resolves the request (using headers)
+    // we skip forwarding the source so the base component doesn't attempt
+    // to load the original source
+    source: blobUri ? _objectSpread(_objectSpread({}, nextSource), {}, {
+      uri: blobUri
+    }) : undefined
+  });
+  return /*#__PURE__*/React.createElement(BaseImage, _extends({
+    ref: ref
+  }, propsToPass));
+});
 
 // $FlowIgnore: This is the correct type, but casting makes it unhappy since the variables aren't defined yet
-var ImageWithStatics = Image;
+var ImageWithStatics = /*#__PURE__*/React.forwardRef((props, ref) => {
+  if (props.source && props.source.headers) {
+    return /*#__PURE__*/React.createElement(ImageWithHeaders, _extends({
+      ref: ref
+    }, props));
+  }
+  return /*#__PURE__*/React.createElement(BaseImage, _extends({
+    ref: ref
+  }, props));
+});
 ImageWithStatics.getSize = function (uri, success, failure) {
   ImageLoader.getSize(uri, success, failure);
 };
diff --git a/node_modules/react-native-web/dist/exports/Modal/index.js b/node_modules/react-native-web/dist/exports/Modal/index.js
index a9a7c36..522ef93 100644
--- a/node_modules/react-native-web/dist/exports/Modal/index.js
+++ b/node_modules/react-native-web/dist/exports/Modal/index.js
@@ -88,13 +88,11 @@ var Modal = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
     onDismiss: onDismissCallback,
     onShow: onShowCallback,
     visible: visible
-  }, /*#__PURE__*/React.createElement(ModalFocusTrap, {
-    active: isActive
   }, /*#__PURE__*/React.createElement(ModalContent, _extends({}, rest, {
     active: isActive,
     onRequestClose: onRequestClose,
     ref: forwardedRef,
     transparent: transparent
-  }), children))));
+  }), children)));
 });
 export default Modal;
\ No newline at end of file
diff --git a/node_modules/react-native-web/dist/exports/Text/index.js b/node_modules/react-native-web/dist/exports/Text/index.js
index 1076f55..1bba56c 100644
--- a/node_modules/react-native-web/dist/exports/Text/index.js
+++ b/node_modules/react-native-web/dist/exports/Text/index.js
@@ -29,7 +29,12 @@ import { useLocaleContext, getLocaleDirection } from '../../modules/useLocale';
 var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
   href: true,
   lang: true,
-  pointerEvents: true
+  pointerEvents: true,
+  // Fullstory props
+  fsClass: true,
+  dataComponent: true,
+  dataElement: true,
+  dataSourceFile: true
 });
 var pickProps = props => pick(props, forwardPropsList);
 var Text = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
diff --git a/node_modules/react-native-web/dist/exports/TextInput/index.js b/node_modules/react-native-web/dist/exports/TextInput/index.js
index 0f476a7..6fab5b0 100644
--- a/node_modules/react-native-web/dist/exports/TextInput/index.js
+++ b/node_modules/react-native-web/dist/exports/TextInput/index.js
@@ -66,7 +66,12 @@ var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedP
   rows: true,
   spellCheck: true,
   value: true,
-  type: true
+  type: true,
+  // Fullstory props
+  fsClass: true,
+  dataComponent: true,
+  dataElement: true,
+  dataSourceFile: true
 });
 var pickProps = props => pick(props, forwardPropsList);
 
diff --git a/node_modules/react-native-web/dist/exports/TouchableWithoutFeedback/index.js b/node_modules/react-native-web/dist/exports/TouchableWithoutFeedback/index.js
index 656e8d9..ec53965 100644
--- a/node_modules/react-native-web/dist/exports/TouchableWithoutFeedback/index.js
+++ b/node_modules/react-native-web/dist/exports/TouchableWithoutFeedback/index.js
@@ -30,7 +30,12 @@ var forwardPropsList = {
   onBlur: true,
   onFocus: true,
   onLayout: true,
-  testID: true
+  testID: true,
+  // Fullstory props
+  fsClass: true,
+  dataComponent: true,
+  dataElement: true,
+  dataSourceFile: true
 };
 var pickProps = props => pick(props, forwardPropsList);
 function TouchableWithoutFeedback(props, forwardedRef) {
diff --git a/node_modules/react-native-web/dist/exports/View/index.js b/node_modules/react-native-web/dist/exports/View/index.js
index 45343e5..054942f 100644
--- a/node_modules/react-native-web/dist/exports/View/index.js
+++ b/node_modules/react-native-web/dist/exports/View/index.js
@@ -28,7 +28,12 @@ var forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedP
   lang: true,
   onScroll: true,
   onWheel: true,
-  pointerEvents: true
+  pointerEvents: true,
+  // Fullstory props
+  fsClass: true,
+  dataComponent: true,
+  dataElement: true,
+  dataSourceFile: true
 });
 var pickProps = props => pick(props, forwardPropsList);
 var View = /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
diff --git a/node_modules/react-native-web/dist/modules/AccessibilityUtil/propsToAccessibilityComponent.js b/node_modules/react-native-web/dist/modules/AccessibilityUtil/propsToAccessibilityComponent.js
index 7d1d587..de51afe 100644
--- a/node_modules/react-native-web/dist/modules/AccessibilityUtil/propsToAccessibilityComponent.js
+++ b/node_modules/react-native-web/dist/modules/AccessibilityUtil/propsToAccessibilityComponent.js
@@ -27,7 +27,8 @@ var roleComponents = {
   navigation: 'nav',
   paragraph: 'p',
   region: 'section',
-  strong: 'strong'
+  strong: 'strong',
+  switch: 'button'
 };
 var emptyObject = {};
 var propsToAccessibilityComponent = function propsToAccessibilityComponent(props) {
diff --git a/node_modules/react-native-web/dist/modules/ImageLoader/index.js b/node_modules/react-native-web/dist/modules/ImageLoader/index.js
index bc06a87..5a22819 100644
--- a/node_modules/react-native-web/dist/modules/ImageLoader/index.js
+++ b/node_modules/react-native-web/dist/modules/ImageLoader/index.js
@@ -76,7 +76,7 @@ var ImageLoader = {
       var image = requests["" + requestId];
       if (image) {
         var naturalHeight = image.naturalHeight,
-          naturalWidth = image.naturalWidth;
+            naturalWidth = image.naturalWidth;
         if (naturalHeight && naturalWidth) {
           success(naturalWidth, naturalHeight);
           complete = true;
@@ -102,11 +102,19 @@ var ImageLoader = {
     id += 1;
     var image = new window.Image();
     image.onerror = onError;
-    image.onload = e => {
+    image.onload = nativeEvent => {
       // avoid blocking the main thread
-      var onDecode = () => onLoad({
-        nativeEvent: e
-      });
+      var onDecode = () => {
+        // Append `source` to match RN's ImageLoadEvent interface
+        nativeEvent.source = {
+          uri: image.src,
+          width: image.naturalWidth,
+          height: image.naturalHeight
+        };
+        onLoad({
+          nativeEvent
+        });
+      };
       if (typeof image.decode === 'function') {
         // Safari currently throws exceptions when decoding svgs.
         // We want to catch that error and allow the load handler
@@ -120,6 +128,32 @@ var ImageLoader = {
     requests["" + id] = image;
     return id;
   },
+  loadWithHeaders(source) {
+    var uri;
+    var abortController = new AbortController();
+    var request = new Request(source.uri, {
+      headers: source.headers,
+      signal: abortController.signal
+    });
+    request.headers.append('accept', 'image/*');
+    var promise = fetch(request).then(response => response.blob()).then(blob => {
+      uri = URL.createObjectURL(blob);
+      return uri;
+    }).catch(error => {
+      if (error.name === 'AbortError') {
+        return '';
+      }
+      throw error;
+    });
+    return {
+      promise,
+      source,
+      cancel: () => {
+        abortController.abort();
+        URL.revokeObjectURL(uri);
+      }
+    };
+  },
   prefetch(uri) {
     return new Promise((resolve, reject) => {
       ImageLoader.load(uri, () => {
diff --git a/node_modules/react-native-web/dist/modules/createDOMProps/index.js b/node_modules/react-native-web/dist/modules/createDOMProps/index.js
index 18f5e8b..1cfcc9c 100644
--- a/node_modules/react-native-web/dist/modules/createDOMProps/index.js
+++ b/node_modules/react-native-web/dist/modules/createDOMProps/index.js
@@ -1,6 +1,6 @@
 import _objectSpread from "@babel/runtime/helpers/objectSpread2";
 import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
-var _excluded = ["aria-activedescendant", "accessibilityActiveDescendant", "aria-atomic", "accessibilityAtomic", "aria-autocomplete", "accessibilityAutoComplete", "aria-busy", "accessibilityBusy", "aria-checked", "accessibilityChecked", "aria-colcount", "accessibilityColumnCount", "aria-colindex", "accessibilityColumnIndex", "aria-colspan", "accessibilityColumnSpan", "aria-controls", "accessibilityControls", "aria-current", "accessibilityCurrent", "aria-describedby", "accessibilityDescribedBy", "aria-details", "accessibilityDetails", "aria-disabled", "accessibilityDisabled", "aria-errormessage", "accessibilityErrorMessage", "aria-expanded", "accessibilityExpanded", "aria-flowto", "accessibilityFlowTo", "aria-haspopup", "accessibilityHasPopup", "aria-hidden", "accessibilityHidden", "aria-invalid", "accessibilityInvalid", "aria-keyshortcuts", "accessibilityKeyShortcuts", "aria-label", "accessibilityLabel", "aria-labelledby", "accessibilityLabelledBy", "aria-level", "accessibilityLevel", "aria-live", "accessibilityLiveRegion", "aria-modal", "accessibilityModal", "aria-multiline", "accessibilityMultiline", "aria-multiselectable", "accessibilityMultiSelectable", "aria-orientation", "accessibilityOrientation", "aria-owns", "accessibilityOwns", "aria-placeholder", "accessibilityPlaceholder", "aria-posinset", "accessibilityPosInSet", "aria-pressed", "accessibilityPressed", "aria-readonly", "accessibilityReadOnly", "aria-required", "accessibilityRequired", "role", "accessibilityRole", "aria-roledescription", "accessibilityRoleDescription", "aria-rowcount", "accessibilityRowCount", "aria-rowindex", "accessibilityRowIndex", "aria-rowspan", "accessibilityRowSpan", "aria-selected", "accessibilitySelected", "aria-setsize", "accessibilitySetSize", "aria-sort", "accessibilitySort", "aria-valuemax", "accessibilityValueMax", "aria-valuemin", "accessibilityValueMin", "aria-valuenow", "accessibilityValueNow", "aria-valuetext", "accessibilityValueText", "dataSet", "focusable", "id", "nativeID", "pointerEvents", "style", "tabIndex", "testID"];
+var _excluded = ["aria-activedescendant", "accessibilityActiveDescendant", "aria-atomic", "accessibilityAtomic", "aria-autocomplete", "accessibilityAutoComplete", "aria-busy", "accessibilityBusy", "aria-checked", "accessibilityChecked", "aria-colcount", "accessibilityColumnCount", "aria-colindex", "accessibilityColumnIndex", "aria-colspan", "accessibilityColumnSpan", "aria-controls", "accessibilityControls", "aria-current", "accessibilityCurrent", "aria-describedby", "accessibilityDescribedBy", "aria-details", "accessibilityDetails", "aria-disabled", "accessibilityDisabled", "aria-errormessage", "accessibilityErrorMessage", "aria-expanded", "accessibilityExpanded", "aria-flowto", "accessibilityFlowTo", "aria-haspopup", "accessibilityHasPopup", "aria-hidden", "accessibilityHidden", "aria-invalid", "accessibilityInvalid", "aria-keyshortcuts", "accessibilityKeyShortcuts", "aria-label", "accessibilityLabel", "aria-labelledby", "accessibilityLabelledBy", "aria-level", "accessibilityLevel", "aria-live", "accessibilityLiveRegion", "aria-modal", "accessibilityModal", "aria-multiline", "accessibilityMultiline", "aria-multiselectable", "accessibilityMultiSelectable", "aria-orientation", "accessibilityOrientation", "aria-owns", "accessibilityOwns", "aria-placeholder", "accessibilityPlaceholder", "aria-posinset", "accessibilityPosInSet", "aria-pressed", "accessibilityPressed", "aria-readonly", "accessibilityReadOnly", "aria-required", "accessibilityRequired", "role", "accessibilityRole", "aria-roledescription", "accessibilityRoleDescription", "aria-rowcount", "accessibilityRowCount", "aria-rowindex", "accessibilityRowIndex", "aria-rowspan", "accessibilityRowSpan", "aria-selected", "accessibilitySelected", "aria-setsize", "accessibilitySetSize", "aria-sort", "accessibilitySort", "aria-valuemax", "accessibilityValueMax", "aria-valuemin", "accessibilityValueMin", "aria-valuenow", "accessibilityValueNow", "aria-valuetext", "accessibilityValueText", "dataSet", "focusable", "id", "nativeID", "pointerEvents", "style", "tabIndex", "testID", "fsClass", "dataComponent", "dataElement", "dataSourceFile"];
 /**
  * Copyright (c) Nicolas Gallagher.
  *
@@ -145,6 +145,10 @@ var createDOMProps = (elementType, props, options) => {
     style = _props.style,
     tabIndex = _props.tabIndex,
     testID = _props.testID,
+    fsClass = _props.fsClass,
+    dataComponent = _props.dataComponent,
+    dataElement = _props.dataElement,
+    dataSourceFile = _props.dataSourceFile,
     domProps = _objectWithoutPropertiesLoose(_props, _excluded);
 
   /*
@@ -834,6 +838,26 @@ var createDOMProps = (elementType, props, options) => {
   if (domProps.type == null && elementType === 'button') {
     domProps.type = 'button';
   }
+
+  // Fullstory props
+  if (fsClass != null) {
+    // We append `fsClass` prop to the `class` attribute of the element
+    // so Fullstory can correctly identify which elements it must mask/unmask.
+    if (domProps.className) {
+      domProps.className = domProps.className + " " + fsClass;
+    } else {
+      domProps.className = fsClass;
+    }
+  }
+  if (dataComponent != null) {
+    domProps['data-component'] = dataComponent;
+  }
+  if (dataElement != null) {
+    domProps['data-element'] = dataElement;
+  }
+  if (dataSourceFile != null) {
+    domProps['data-source-file'] = dataSourceFile;
+  }
   return domProps;
 };
 export default createDOMProps;
\ No newline at end of file
diff --git a/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js b/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js
index 0aec2d6..a71aec2 100644
--- a/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js
+++ b/node_modules/react-native-web/dist/modules/useResponderEvents/ResponderSystem.js
@@ -133,7 +133,7 @@ to return true:wantsResponderID|                            |
 
 import createResponderEvent from './createResponderEvent';
 import { isCancelish, isEndish, isMoveish, isScroll, isSelectionChange, isStartish } from './ResponderEventTypes';
-import { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryPointerDown, setResponderId } from './utils';
+import { getLowestCommonAncestor, getResponderPaths, hasTargetTouches, hasValidSelection, isPrimaryOrSecondaryPointerDown, setResponderId } from './utils';
 import { ResponderTouchHistoryStore } from './ResponderTouchHistoryStore';
 import canUseDOM from '../canUseDom';
 
@@ -225,7 +225,7 @@ function eventListener(domEvent) {
     }
     return;
   }
-  var isStartEvent = isStartish(eventType) && isPrimaryPointerDown(domEvent);
+  var isStartEvent = isStartish(eventType) && isPrimaryOrSecondaryPointerDown(domEvent);
   var isMoveEvent = isMoveish(eventType);
   var isEndEvent = isEndish(eventType);
   var isScrollEvent = isScroll(eventType);
diff --git a/node_modules/react-native-web/dist/modules/useResponderEvents/utils.js b/node_modules/react-native-web/dist/modules/useResponderEvents/utils.js
index 7382cdd..d88f6c0 100644
--- a/node_modules/react-native-web/dist/modules/useResponderEvents/utils.js
+++ b/node_modules/react-native-web/dist/modules/useResponderEvents/utils.js
@@ -148,14 +148,14 @@ export function hasValidSelection(domEvent) {
 /**
  * Events are only valid if the primary button was used without specific modifier keys.
  */
-export function isPrimaryPointerDown(domEvent) {
+export function isPrimaryOrSecondaryPointerDown(domEvent) {
   var altKey = domEvent.altKey,
     button = domEvent.button,
     buttons = domEvent.buttons,
     ctrlKey = domEvent.ctrlKey,
     type = domEvent.type;
   var isTouch = type === 'touchstart' || type === 'touchmove';
-  var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);
+  var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1 || buttons === 2);
   var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;
   var noModifiers = altKey === false && ctrlKey === false;
   if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {
diff --git a/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedProps.js b/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedProps.js
index 9ba3336..2d67005 100644
--- a/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedProps.js
+++ b/node_modules/react-native-web/dist/vendor/react-native/Animated/nodes/AnimatedProps.js
@@ -68,6 +68,7 @@ class AnimatedProps extends AnimatedNode {
     if (this.__isNative && this._animatedView) {
       this.__disconnectAnimatedView();
     }
+    this._animatedView = null
     for (var key in this._props) {
       var value = this._props[key];
       if (value instanceof AnimatedNode) {
diff --git a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
index e561899..42c4984 100644
--- a/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
+++ b/node_modules/react-native-web/dist/vendor/react-native/VirtualizedList/index.js
@@ -77,14 +77,6 @@ function scrollEventThrottleOrDefault(scrollEventThrottle) {
 function windowSizeOrDefault(windowSize) {
   return windowSize !== null && windowSize !== void 0 ? windowSize : 21;
 }
-function findLastWhere(arr, predicate) {
-  for (var i = arr.length - 1; i >= 0; i--) {
-    if (predicate(arr[i])) {
-      return arr[i];
-    }
-  }
-  return null;
-}
 
 /**
  * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)
@@ -286,7 +278,7 @@ class VirtualizedList extends StateSafePureComponent {
   // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
 
   constructor(_props) {
-    var _this$props$updateCel;
+    var _this$props$updateCel, _this$props$maintainV, _this$props$maintainV2;
     super(_props);
     this._getScrollMetrics = () => {
       return this._scrollMetrics;
@@ -341,7 +333,7 @@ class VirtualizedList extends StateSafePureComponent {
       zoomScale: 1
     };
     this._scrollRef = null;
-    this._sentStartForContentLength = 0;
+    this._sentStartForFirstVisibleItemKey = null;
     this._sentEndForContentLength = 0;
     this._totalCellLength = 0;
     this._totalCellsMeasured = 0;
@@ -521,6 +513,11 @@ class VirtualizedList extends StateSafePureComponent {
         visibleLength,
         zoomScale
       };
+      if (this.state.pendingScrollUpdateCount > 0) {
+        this.setState(state => ({
+          pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1
+        }));
+      }
       this._updateViewableItems(this.props, this.state.cellsAroundViewport);
       if (!this.props) {
         return;
@@ -570,7 +567,7 @@ class VirtualizedList extends StateSafePureComponent {
     this._updateCellsToRender = () => {
       this._updateViewableItems(this.props, this.state.cellsAroundViewport);
       this.setState((state, props) => {
-        var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport);
+        var cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);
         var renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));
         if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {
           return null;
@@ -590,7 +587,7 @@ class VirtualizedList extends StateSafePureComponent {
       return {
         index,
         item,
-        key: this._keyExtractor(item, index, props),
+        key: VirtualizedList._keyExtractor(item, index, props),
         isViewable
       };
     };
@@ -622,12 +619,10 @@ class VirtualizedList extends StateSafePureComponent {
     };
     this._getFrameMetrics = (index, props) => {
       var data = props.data,
-        getItem = props.getItem,
         getItemCount = props.getItemCount,
         getItemLayout = props.getItemLayout;
       invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);
-      var item = getItem(data, index);
-      var frame = this._frames[this._keyExtractor(item, index, props)];
+      var frame = this._frames[VirtualizedList._getItemKey(props, index)];
       if (!frame || frame.index !== index) {
         if (getItemLayout) {
           /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
@@ -651,7 +646,7 @@ class VirtualizedList extends StateSafePureComponent {
 
       // The last cell we rendered may be at a new index. Bail if we don't know
       // where it is.
-      if (focusedCellIndex >= itemCount || this._keyExtractor(props.getItem(props.data, focusedCellIndex), focusedCellIndex, props) !== this._lastFocusedCellKey) {
+      if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== this._lastFocusedCellKey) {
         return [];
       }
       var first = focusedCellIndex;
@@ -690,38 +685,68 @@ class VirtualizedList extends StateSafePureComponent {
         });
       }
     }
+    var itemCount = this.props.getItemCount(this.props.data);
     var initialRenderRegion = VirtualizedList._initialRenderRegion(_props);
+    var minIndexForVisible = (_this$props$maintainV = (_this$props$maintainV2 = this.props.maintainVisibleContentPosition) == null ? void 0 : _this$props$maintainV2.minIndexForVisible) !== null && _this$props$maintainV !== void 0 ? _this$props$maintainV : 0;
     this.state = {
       cellsAroundViewport: initialRenderRegion,
-      renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion)
+      renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion),
+      firstVisibleItemKey: itemCount > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,
+      // When we have a non-zero initialScrollIndex, we will receive a
+      // scroll event later so this will prevent the window from updating
+      // until we get a valid offset.
+      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0,
+      lastItemCount: itemCount
     };
 
     // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
     // For issue https://github.com/necolas/react-native-web/issues/995
-    this.invertedWheelEventHandler = ev => {
-      var scrollOffset = this.props.horizontal ? ev.target.scrollLeft : ev.target.scrollTop;
-      var scrollLength = this.props.horizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
-      var clientLength = this.props.horizontal ? ev.target.clientWidth : ev.target.clientHeight;
-      var isEventTargetScrollable = scrollLength > clientLength;
-      var delta = this.props.horizontal ? ev.deltaX || ev.wheelDeltaX : ev.deltaY || ev.wheelDeltaY;
-      var leftoverDelta = delta;
-      if (isEventTargetScrollable) {
-        leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
-      }
-      var targetDelta = delta - leftoverDelta;
-      if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
-        var node = this._scrollRef.getScrollableNode();
-        if (this.props.horizontal) {
-          ev.target.scrollLeft += targetDelta;
-          var nextScrollLeft = node.scrollLeft - leftoverDelta;
-          node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
-        } else {
-          ev.target.scrollTop += targetDelta;
-          var nextScrollTop = node.scrollTop - leftoverDelta;
-          node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
+    this.invertedWheelEventHandler = (ev) => {
+        const isHorizontal = this.props.horizontal;
+        const deltaX = ev.deltaX || ev.wheelDeltaX || 0;
+        const deltaY = ev.deltaY || ev.wheelDeltaY || 0;
+
+        const scrollOffset = isHorizontal ? ev.target.scrollLeft : ev.target.scrollTop;
+        const scrollLength = isHorizontal ? ev.target.scrollWidth : ev.target.scrollHeight;
+        const clientLength = isHorizontal ? ev.target.clientWidth : ev.target.clientHeight;
+        const isEventTargetScrollable = scrollLength > clientLength;
+        const delta = isHorizontal ? deltaX : deltaY;
+        let leftoverDelta = delta;
+        if (isEventTargetScrollable) {
+            leftoverDelta = delta < 0 ? Math.min(delta + scrollOffset, 0) : Math.max(delta - (scrollLength - clientLength - scrollOffset), 0);
+        }
+        const targetDelta = delta - leftoverDelta;
+        if (this.props.inverted && this._scrollRef && this._scrollRef.getScrollableNode) {
+            const node = this._scrollRef.getScrollableNode();
+                
+            const scrollMetricsOffset = this._scrollMetrics.offset;
+            const contentLength = this._scrollMetrics.contentLength;
+            const visibleLength = this._scrollMetrics.visibleLength
+            const isOnScrollLimit = scrollMetricsOffset <= 0 || Math.ceil(scrollMetricsOffset) >= contentLength - visibleLength;
+              
+            if (isHorizontal) {
+                if (Math.abs(deltaX) > Math.abs(deltaY)) {
+                  ev.target.scrollLeft += targetDelta;
+                  const nextScrollLeft = node.scrollLeft - leftoverDelta;
+                  node.scrollLeft = !this.props.getItemLayout ? Math.min(nextScrollLeft, this._totalCellLength) : nextScrollLeft;
+                  ev.preventDefault();
+                  ev.stopPropagation();
+                }
+            } else {
+                 // Avoid recoil/rubber band effect on overscroll
+                if (isOnScrollLimit && Math.abs(deltaY) > 0) {
+                  ev.preventDefault();
+                }
+
+                if (Math.abs(deltaY) > Math.abs(deltaX)) {
+                  ev.target.scrollTop += targetDelta;
+                  const nextScrollTop = node.scrollTop - leftoverDelta;
+                  node.scrollTop = !this.props.getItemLayout ? Math.min(nextScrollTop, this._totalCellLength) : nextScrollTop;
+                  ev.preventDefault();
+                  ev.stopPropagation();
+                }
+            }
         }
-        ev.preventDefault();
-      }
     };
   }
   _checkProps(props) {
@@ -749,6 +774,26 @@ class VirtualizedList extends StateSafePureComponent {
       }
     }
   }
+  static _findItemIndexWithKey(props, key, hint) {
+    var itemCount = props.getItemCount(props.data);
+    if (hint != null && hint >= 0 && hint < itemCount) {
+      var curKey = VirtualizedList._getItemKey(props, hint);
+      if (curKey === key) {
+        return hint;
+      }
+    }
+    for (var ii = 0; ii < itemCount; ii++) {
+      var _curKey = VirtualizedList._getItemKey(props, ii);
+      if (_curKey === key) {
+        return ii;
+      }
+    }
+    return null;
+  }
+  static _getItemKey(props, index) {
+    var item = props.getItem(props.data, index);
+    return VirtualizedList._keyExtractor(item, index, props);
+  }
   static _createRenderMask(props, cellsAroundViewport, additionalRegions) {
     var itemCount = props.getItemCount(props.data);
     invariant(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, "Invalid cells around viewport \"[" + cellsAroundViewport.first + ", " + cellsAroundViewport.last + "]\" was passed to VirtualizedList._createRenderMask");
@@ -797,7 +842,7 @@ class VirtualizedList extends StateSafePureComponent {
       }
     }
   }
-  _adjustCellsAroundViewport(props, cellsAroundViewport) {
+  _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {
     var data = props.data,
       getItemCount = props.getItemCount;
     var onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);
@@ -820,17 +865,9 @@ class VirtualizedList extends StateSafePureComponent {
         last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)
       };
     } else {
-      // If we have a non-zero initialScrollIndex and run this before we've scrolled,
-      // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
-      // So let's wait until we've scrolled the view to the right place. And until then,
-      // we will trust the initialScrollIndex suggestion.
-
-      // Thus, we want to recalculate the windowed render limits if any of the following hold:
-      // - initialScrollIndex is undefined or is 0
-      // - initialScrollIndex > 0 AND scrolling is complete
-      // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case
-      //   where the list is shorter than the visible area)
-      if (props.initialScrollIndex && !this._scrollMetrics.offset && Math.abs(distanceFromEnd) >= Number.EPSILON) {
+      // If we have a pending scroll update, we should not adjust the render window as it
+      // might override the correct window.
+      if (pendingScrollUpdateCount > 0) {
         return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;
       }
       newCellsAroundViewport = computeWindowedRenderLimits(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this.__getFrameMetricsApprox, this._scrollMetrics);
@@ -903,16 +940,37 @@ class VirtualizedList extends StateSafePureComponent {
     }
   }
   static getDerivedStateFromProps(newProps, prevState) {
+    var _newProps$maintainVis, _newProps$maintainVis2;
     // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
     // sure we're rendering a reasonable range here.
     var itemCount = newProps.getItemCount(newProps.data);
-    if (itemCount === prevState.renderMask.numCells()) {
+    if (itemCount === prevState.renderMask.numCells() && itemCount === prevState.lastItemCount) {
       return prevState;
     }
-    var constrainedCells = VirtualizedList._constrainToItemCount(prevState.cellsAroundViewport, newProps);
+    var maintainVisibleContentPositionAdjustment = null;
+    var prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
+    var minIndexForVisible = (_newProps$maintainVis = (_newProps$maintainVis2 = newProps.maintainVisibleContentPosition) == null ? void 0 : _newProps$maintainVis2.minIndexForVisible) !== null && _newProps$maintainVis !== void 0 ? _newProps$maintainVis : 0;
+    var newFirstVisibleItemKey = itemCount > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;
+    if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {
+      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
+        // Fast path if items were added at the start of the list.
+        var hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;
+        var firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);
+        maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;
+      } else {
+        maintainVisibleContentPositionAdjustment = null;
+      }
+    }
+    var constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {
+      first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,
+      last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment
+    } : prevState.cellsAroundViewport, newProps);
     return {
       cellsAroundViewport: constrainedCells,
-      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells)
+      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
+      firstVisibleItemKey: newFirstVisibleItemKey,
+      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount,
+      lastItemCount: itemCount
     };
   }
   _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {
@@ -935,7 +993,7 @@ class VirtualizedList extends StateSafePureComponent {
     last = Math.min(end, last);
     var _loop = function _loop() {
       var item = getItem(data, ii);
-      var key = _this._keyExtractor(item, ii, _this.props);
+      var key = VirtualizedList._keyExtractor(item, ii, _this.props);
       _this._indicesToKeys.set(ii, key);
       if (stickyIndicesFromProps.has(ii + stickyOffset)) {
         stickyHeaderIndices.push(cells.length);
@@ -970,20 +1028,23 @@ class VirtualizedList extends StateSafePureComponent {
   }
   static _constrainToItemCount(cells, props) {
     var itemCount = props.getItemCount(props.data);
-    var last = Math.min(itemCount - 1, cells.last);
+    var lastPossibleCellIndex = itemCount - 1;
+
+    // Constraining `last` may significantly shrink the window. Adjust `first`
+    // to expand the window if the new `last` results in a new window smaller
+    // than the number of cells rendered per batch.
     var maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);
+    var maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);
     return {
-      first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
-      last
+      first: clamp(0, cells.first, maxFirst),
+      last: Math.min(lastPossibleCellIndex, cells.last)
     };
   }
   _isNestedWithSameOrientation() {
     var nestedContext = this.context;
     return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));
   }
-  _keyExtractor(item, index, props
-  // $FlowFixMe[missing-local-annot]
-  ) {
+  static _keyExtractor(item, index, props) {
     if (props.keyExtractor != null) {
       return props.keyExtractor(item, index);
     }
@@ -1023,7 +1084,12 @@ class VirtualizedList extends StateSafePureComponent {
       cells.push(/*#__PURE__*/React.createElement(VirtualizedListCellContextProvider, {
         cellKey: this._getCellKey() + '-header',
         key: "$header"
-      }, /*#__PURE__*/React.createElement(View, {
+      }, /*#__PURE__*/React.createElement(View
+      // We expect that header component will be a single native view so make it
+      // not collapsable to avoid this view being flattened and make this assumption
+      // no longer true.
+      , {
+        collapsable: false,
         onLayout: this._onLayoutHeader,
         style: [inversionStyle, this.props.ListHeaderComponentStyle]
       },
@@ -1059,7 +1125,8 @@ class VirtualizedList extends StateSafePureComponent {
       _keylessItemComponentName = '';
       var spacerKey = this._getSpacerKey(!horizontal);
       var renderRegions = this.state.renderMask.enumerateRegions();
-      var lastSpacer = findLastWhere(renderRegions, r => r.isSpacer);
+      var lastRegion = renderRegions[renderRegions.length - 1];
+      var lastSpacer = lastRegion?.isSpacer ? lastRegion : null;
       for (var _iterator = _createForOfIteratorHelperLoose(renderRegions), _step; !(_step = _iterator()).done;) {
         var section = _step.value;
         if (section.isSpacer) {
@@ -1125,7 +1192,11 @@ class VirtualizedList extends StateSafePureComponent {
       // TODO: Android support
       invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,
       stickyHeaderIndices,
-      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style
+      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style,
+      maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? _objectSpread(_objectSpread({}, this.props.maintainVisibleContentPosition), {}, {
+        // Adjust index to account for ListHeaderComponent.
+        minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)
+      }) : undefined
     });
     this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
     var innerRet = /*#__PURE__*/React.createElement(VirtualizedListContextProvider, {
@@ -1175,7 +1246,7 @@ class VirtualizedList extends StateSafePureComponent {
       return ret;
     }
   }
-  componentDidUpdate(prevProps) {
+  componentDidUpdate(prevProps, prevState) {
     var _this$props7 = this.props,
       data = _this$props7.data,
       extraData = _this$props7.extraData;
@@ -1199,6 +1270,11 @@ class VirtualizedList extends StateSafePureComponent {
     if (hiPriInProgress) {
       this._hiPriInProgress = false;
     }
+
+    if (this.state.cellsAroundViewport.first !== prevState.cellsAroundViewport.first ||
+        this.state.cellsAroundViewport.last !== prevState.cellsAroundViewport.last) {
+      this._maybeCallOnEdgeReached();
+    }
   }
 
   // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex
@@ -1318,8 +1394,12 @@ class VirtualizedList extends StateSafePureComponent {
       onStartReached = _this$props8.onStartReached,
       onStartReachedThreshold = _this$props8.onStartReachedThreshold,
       onEndReached = _this$props8.onEndReached,
-      onEndReachedThreshold = _this$props8.onEndReachedThreshold,
-      initialScrollIndex = _this$props8.initialScrollIndex;
+      onEndReachedThreshold = _this$props8.onEndReachedThreshold;
+    // If we have any pending scroll updates it means that the scroll metrics
+    // are out of date and we should not call any of the edge reached callbacks.
+    if (this.state.pendingScrollUpdateCount > 0) {
+      return;
+    }
     var _this$_scrollMetrics2 = this._scrollMetrics,
       contentLength = _this$_scrollMetrics2.contentLength,
       visibleLength = _this$_scrollMetrics2.visibleLength,
@@ -1358,23 +1438,17 @@ class VirtualizedList extends StateSafePureComponent {
     // Next check if the user just scrolled within the start threshold
     // and call onStartReached only once for a given content length,
     // and only if onEndReached is not being executed
-    else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._scrollMetrics.contentLength !== this._sentStartForContentLength) {
-      // On initial mount when using initialScrollIndex the offset will be 0 initially
-      // and will trigger an unexpected onStartReached. To avoid this we can use
-      // timestamp to differentiate between the initial scroll metrics and when we actually
-      // received the first scroll event.
-      if (!initialScrollIndex || this._scrollMetrics.timestamp !== 0) {
-        this._sentStartForContentLength = this._scrollMetrics.contentLength;
-        onStartReached({
-          distanceFromStart
-        });
-      }
+    else if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this.state.firstVisibleItemKey !== this._sentStartForFirstVisibleItemKey) {
+      this._sentStartForFirstVisibleItemKey = this.state.firstVisibleItemKey;
+      onStartReached({
+        distanceFromStart
+      });
     }
 
     // If the user scrolls away from the start or end and back again,
     // cause onStartReached or onEndReached to be triggered again
     else {
-      this._sentStartForContentLength = isWithinStartThreshold ? this._sentStartForContentLength : 0;
+      this._sentStartForFirstVisibleItemKey = isWithinStartThreshold ? this._sentStartForFirstVisibleItemKey : null;
       this._sentEndForContentLength = isWithinEndThreshold ? this._sentEndForContentLength : 0;
     }
   }
@@ -1434,6 +1508,11 @@ class VirtualizedList extends StateSafePureComponent {
    */
 
   _updateViewableItems(props, cellsAroundViewport) {
+    // If we have any pending scroll updates it means that the scroll metrics
+    // are out of date and we should not call any of the visibility callbacks.
+    if (this.state.pendingScrollUpdateCount > 0) {
+      return;
+    }
     this._viewabilityTuples.forEach(tuple => {
       tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._getFrameMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);
     });
diff --git a/node_modules/react-native-web/src/exports/Text/index.js b/node_modules/react-native-web/src/exports/Text/index.js
index f27ccec..c5b996e 100644
--- a/node_modules/react-native-web/src/exports/Text/index.js
+++ b/node_modules/react-native-web/src/exports/Text/index.js
@@ -39,7 +39,13 @@ const forwardPropsList = Object.assign(
   {
     href: true,
     lang: true,
-    pointerEvents: true
+    pointerEvents: true,
+
+    // Fullstory props
+    fsClass: true,
+    dataComponent: true,
+    dataElement: true,
+    dataSourceFile: true
   }
 );
 
diff --git a/node_modules/react-native-web/src/exports/TextInput/index.js b/node_modules/react-native-web/src/exports/TextInput/index.js
index 8f8de0b..ba933c2 100644
--- a/node_modules/react-native-web/src/exports/TextInput/index.js
+++ b/node_modules/react-native-web/src/exports/TextInput/index.js
@@ -77,7 +77,13 @@ const forwardPropsList = Object.assign(
     rows: true,
     spellCheck: true,
     value: true,
-    type: true
+    type: true,
+
+    // Fullstory props
+    fsClass: true,
+    dataComponent: true,
+    dataElement: true,
+    dataSourceFile: true
   }
 );
 
diff --git a/node_modules/react-native-web/src/exports/TouchableWithoutFeedback/index.js b/node_modules/react-native-web/src/exports/TouchableWithoutFeedback/index.js
index e2ef7d0..7c69697 100644
--- a/node_modules/react-native-web/src/exports/TouchableWithoutFeedback/index.js
+++ b/node_modules/react-native-web/src/exports/TouchableWithoutFeedback/index.js
@@ -56,7 +56,13 @@ const forwardPropsList = {
   onBlur: true,
   onFocus: true,
   onLayout: true,
-  testID: true
+  testID: true,
+
+  // Fullstory props
+  fsClass: true,
+  dataComponent: true,
+  dataElement: true,
+  dataSourceFile: true
 };
 
 const pickProps = (props) => pick(props, forwardPropsList);
diff --git a/node_modules/react-native-web/src/exports/View/index.js b/node_modules/react-native-web/src/exports/View/index.js
index cec4d58..f04f897 100644
--- a/node_modules/react-native-web/src/exports/View/index.js
+++ b/node_modules/react-native-web/src/exports/View/index.js
@@ -40,7 +40,13 @@ const forwardPropsList = Object.assign(
     lang: true,
     onScroll: true,
     onWheel: true,
-    pointerEvents: true
+    pointerEvents: true,
+
+    // Fullstory props
+    fsClass: true,
+    dataComponent: true,
+    dataElement: true,
+    dataSourceFile: true
   }
 );
 
diff --git a/node_modules/react-native-web/src/modules/createDOMProps/index.js b/node_modules/react-native-web/src/modules/createDOMProps/index.js
index 3fbb3df..3376779 100644
--- a/node_modules/react-native-web/src/modules/createDOMProps/index.js
+++ b/node_modules/react-native-web/src/modules/createDOMProps/index.js
@@ -149,6 +149,13 @@ const createDOMProps = (elementType, props, options) => {
     style,
     tabIndex,
     testID,
+
+    // Fullstory props
+    fsClass,
+    dataComponent,
+    dataElement,
+    dataSourceFile,
+
     // Rest
     ...domProps
   } = props;
@@ -912,6 +919,27 @@ const createDOMProps = (elementType, props, options) => {
   if (domProps.type == null && elementType === 'button') {
     domProps.type = 'button';
   }
+
+  // Fullstory props
+  if (fsClass != null) {
+    // We append `fsClass` prop to the `class` attribute of the element
+    // so Fullstory can correctly identify which elements it must mask/unmask.
+    if (domProps.className) {
+      domProps.className = `${domProps.className} ${fsClass}`;
+    } else {
+      domProps.className = fsClass;
+    }
+  }
+  if (dataComponent != null) {
+    domProps['data-component'] = dataComponent;
+  }
+  if (dataElement != null) {
+    domProps['data-element'] = dataElement;
+  }
+  if (dataSourceFile != null) {
+    domProps['data-source-file'] = dataSourceFile;
+  }
+
   return domProps;
 };
 
diff --git a/node_modules/react-native-web/src/vendor/react-native/VirtualizedList/index.js b/node_modules/react-native-web/src/vendor/react-native/VirtualizedList/index.js
index 97c817f..57dc293 100644
--- a/node_modules/react-native-web/src/vendor/react-native/VirtualizedList/index.js
+++ b/node_modules/react-native-web/src/vendor/react-native/VirtualizedList/index.js
@@ -74,6 +74,11 @@ type ViewabilityHelperCallbackTuple = {
 type State = {
   renderMask: CellRenderMask,
   cellsAroundViewport: {first: number, last: number},
+  // Used to track items added at the start of the list for maintainVisibleContentPosition.
+  firstVisibleItemKey: ?string,
+  // When > 0 the scroll position available in JS is considered stale and should not be used.
+  pendingScrollUpdateCount: number,
+  lastItemCount: number,
 };
 
 /**
@@ -446,9 +451,26 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
 
     const initialRenderRegion = VirtualizedList._initialRenderRegion(props);
 
+    const minIndexForVisible =
+      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;
+    const itemCount = this.props.getItemCount(this.props.data);
+
     this.state = {
       cellsAroundViewport: initialRenderRegion,
       renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),
+      firstVisibleItemKey:
+        itemCount > minIndexForVisible
+          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)
+          : null,
+      // When we have a non-zero initialScrollIndex, we will receive a
+      // scroll event later so this will prevent the window from updating
+      // until we get a valid offset.
+      pendingScrollUpdateCount:
+        this.props.initialScrollIndex != null &&
+        this.props.initialScrollIndex > 0
+          ? 1
+          : 0,
+      lastItemCount: itemCount,
     };
 
       // REACT-NATIVE-WEB patch to preserve during future RN merges: Support inverted wheel scroller.
@@ -533,6 +555,40 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     }
   }
 
+  static _findItemIndexWithKey(
+    props: Props,
+    key: string,
+    hint: ?number,
+  ): ?number {
+    const itemCount = props.getItemCount(props.data);
+    if (hint != null && hint >= 0 && hint < itemCount) {
+      const curKey = VirtualizedList._getItemKey(props, hint);
+      if (curKey === key) {
+        return hint;
+      }
+    }
+    for (let ii = 0; ii < itemCount; ii++) {
+      const curKey = VirtualizedList._getItemKey(props, ii);
+      if (curKey === key) {
+        return ii;
+      }
+    }
+    return null;
+  }
+
+  static _getItemKey(
+    props: {
+      data: Props['data'],
+      getItem: Props['getItem'],
+      keyExtractor: Props['keyExtractor'],
+      ...
+    },
+    index: number,
+  ): string {
+    const item = props.getItem(props.data, index);
+    return VirtualizedList._keyExtractor(item, index, props);
+  }
+
   static _createRenderMask(
     props: Props,
     cellsAroundViewport: {first: number, last: number},
@@ -616,6 +672,7 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
   _adjustCellsAroundViewport(
     props: Props,
     cellsAroundViewport: {first: number, last: number},
+    pendingScrollUpdateCount: number,
   ): {first: number, last: number} {
     const {data, getItemCount} = props;
     const onEndReachedThreshold = onEndReachedThresholdOrDefault(
@@ -647,21 +704,9 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
         ),
       };
     } else {
-      // If we have a non-zero initialScrollIndex and run this before we've scrolled,
-      // we'll wipe out the initialNumToRender rendered elements starting at initialScrollIndex.
-      // So let's wait until we've scrolled the view to the right place. And until then,
-      // we will trust the initialScrollIndex suggestion.
-
-      // Thus, we want to recalculate the windowed render limits if any of the following hold:
-      // - initialScrollIndex is undefined or is 0
-      // - initialScrollIndex > 0 AND scrolling is complete
-      // - initialScrollIndex > 0 AND the end of the list is visible (this handles the case
-      //   where the list is shorter than the visible area)
-      if (
-        props.initialScrollIndex &&
-        !this._scrollMetrics.offset &&
-        Math.abs(distanceFromEnd) >= Number.EPSILON
-      ) {
+      // If we have a pending scroll update, we should not adjust the render window as it
+      // might override the correct window.
+      if (pendingScrollUpdateCount > 0) {
         return cellsAroundViewport.last >= getItemCount(data)
           ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)
           : cellsAroundViewport;
@@ -766,18 +811,63 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make
     // sure we're rendering a reasonable range here.
     const itemCount = newProps.getItemCount(newProps.data);
-    if (itemCount === prevState.renderMask.numCells()) {
+    if (itemCount === prevState.renderMask.numCells() && itemCount === prevState.lastItemCount) {
       return prevState;
     }
+    let maintainVisibleContentPositionAdjustment: ?number = null;
+    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;
+    const minIndexForVisible =
+      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;
+    const newFirstVisibleItemKey =
+      itemCount > minIndexForVisible
+        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)
+        : null;
+    if (
+      newProps.maintainVisibleContentPosition != null &&
+      prevFirstVisibleItemKey != null &&
+      newFirstVisibleItemKey != null
+    ) {
+      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {
+        // Fast path if items were added at the start of the list.
+        const hint =
+          itemCount - prevState.renderMask.numCells() + minIndexForVisible;
+        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(
+          newProps,
+          prevFirstVisibleItemKey,
+          hint,
+        );
+        maintainVisibleContentPositionAdjustment =
+          firstVisibleItemIndex != null
+            ? firstVisibleItemIndex - minIndexForVisible
+            : null;
+      } else {
+        maintainVisibleContentPositionAdjustment = null;
+      }
+    }
 
     const constrainedCells = VirtualizedList._constrainToItemCount(
-      prevState.cellsAroundViewport,
+      maintainVisibleContentPositionAdjustment != null
+        ? {
+            first:
+              prevState.cellsAroundViewport.first +
+              maintainVisibleContentPositionAdjustment,
+            last:
+              prevState.cellsAroundViewport.last +
+              maintainVisibleContentPositionAdjustment,
+          }
+        : prevState.cellsAroundViewport,
       newProps,
     );
 
     return {
       cellsAroundViewport: constrainedCells,
       renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),
+      firstVisibleItemKey: newFirstVisibleItemKey,
+      pendingScrollUpdateCount:
+        maintainVisibleContentPositionAdjustment != null
+          ? prevState.pendingScrollUpdateCount + 1
+          : prevState.pendingScrollUpdateCount,
+      lastItemCount: itemCount,
     };
   }
 
@@ -809,7 +899,7 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
 
     for (let ii = first; ii <= last; ii++) {
       const item = getItem(data, ii);
-      const key = this._keyExtractor(item, ii, this.props);
+      const key = VirtualizedList._keyExtractor(item, ii, this.props);
 
       this._indicesToKeys.set(ii, key);
       if (stickyIndicesFromProps.has(ii + stickyOffset)) {
@@ -852,15 +942,19 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     props: Props,
   ): {first: number, last: number} {
     const itemCount = props.getItemCount(props.data);
-    const last = Math.min(itemCount - 1, cells.last);
+    const lastPossibleCellIndex = itemCount - 1;
 
+    // Constraining `last` may significantly shrink the window. Adjust `first`
+    // to expand the window if the new `last` results in a new window smaller
+    // than the number of cells rendered per batch.
     const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(
       props.maxToRenderPerBatch,
     );
+    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);
 
     return {
-      first: clamp(0, itemCount - 1 - maxToRenderPerBatch, cells.first),
-      last,
+      first: clamp(0, cells.first, maxFirst),
+      last: Math.min(lastPossibleCellIndex, cells.last),
     };
   }
 
@@ -882,15 +976,14 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
   _getSpacerKey = (isVertical: boolean): string =>
     isVertical ? 'height' : 'width';
 
-  _keyExtractor(
+  static _keyExtractor(
     item: Item,
     index: number,
     props: {
       keyExtractor?: ?(item: Item, index: number) => string,
       ...
     },
-    // $FlowFixMe[missing-local-annot]
-  ) {
+  ): string {
     if (props.keyExtractor != null) {
       return props.keyExtractor(item, index);
     }
@@ -936,6 +1029,10 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
           cellKey={this._getCellKey() + '-header'}
           key="$header">
           <View
+            // We expect that header component will be a single native view so make it
+            // not collapsable to avoid this view being flattened and make this assumption
+            // no longer true.
+            collapsable={false}
             onLayout={this._onLayoutHeader}
             style={[
               inversionStyle,
@@ -1093,6 +1190,16 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
       style: inversionStyle
         ? [inversionStyle, this.props.style]
         : this.props.style,
+      maintainVisibleContentPosition:
+        this.props.maintainVisibleContentPosition != null
+          ? {
+              ...this.props.maintainVisibleContentPosition,
+              // Adjust index to account for ListHeaderComponent.
+              minIndexForVisible:
+                this.props.maintainVisibleContentPosition.minIndexForVisible +
+                (this.props.ListHeaderComponent ? 1 : 0),
+            }
+          : undefined,
     };
 
     this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;
@@ -1180,6 +1287,11 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     if (hiPriInProgress) {
       this._hiPriInProgress = false;
     }
+
+    if (this.state.cellsAroundViewport.first !== prevState.cellsAroundViewport.first ||
+        this.state.cellsAroundViewport.last !== prevState.cellsAroundViewport.last) {
+      this._maybeCallOnEdgeReached();
+    }
   }
 
   _averageCellLength = 0;
@@ -1220,7 +1332,7 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     zoomScale: 1,
   };
   _scrollRef: ?React.ElementRef<any> = null;
-  _sentStartForContentLength = 0;
+  _sentStartForFirstVisibleItemKey: ?string = null;
   _sentEndForContentLength = 0;
   _totalCellLength = 0;
   _totalCellsMeasured = 0;
@@ -1515,8 +1627,12 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
       onStartReachedThreshold,
       onEndReached,
       onEndReachedThreshold,
-      initialScrollIndex,
     } = this.props;
+    // If we have any pending scroll updates it means that the scroll metrics
+    // are out of date and we should not call any of the edge reached callbacks.
+    if (this.state.pendingScrollUpdateCount > 0) {
+      return;
+    }
     const {contentLength, visibleLength, offset} = this._scrollMetrics;
     let distanceFromStart = offset;
     let distanceFromEnd = contentLength - visibleLength - offset;
@@ -1566,24 +1682,18 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
       onStartReached != null &&
       this.state.cellsAroundViewport.first === 0 &&
       isWithinStartThreshold &&
-      this._scrollMetrics.contentLength !== this._sentStartForContentLength
+      this.state.firstVisibleItemKey !== this._sentStartForFirstVisibleItemKey
     ) {
-      // On initial mount when using initialScrollIndex the offset will be 0 initially
-      // and will trigger an unexpected onStartReached. To avoid this we can use
-      // timestamp to differentiate between the initial scroll metrics and when we actually
-      // received the first scroll event.
-      if (!initialScrollIndex || this._scrollMetrics.timestamp !== 0) {
-        this._sentStartForContentLength = this._scrollMetrics.contentLength;
-        onStartReached({distanceFromStart});
-      }
+      this._sentStartForFirstVisibleItemKey = this.state.firstVisibleItemKey;
+      onStartReached({distanceFromStart});
     }
 
     // If the user scrolls away from the start or end and back again,
     // cause onStartReached or onEndReached to be triggered again
     else {
-      this._sentStartForContentLength = isWithinStartThreshold
-        ? this._sentStartForContentLength
-        : 0;
+      this._sentStartForFirstVisibleItemKey = isWithinStartThreshold
+        ? this._sentStartForFirstVisibleItemKey
+        : null;
       this._sentEndForContentLength = isWithinEndThreshold
         ? this._sentEndForContentLength
         : 0;
@@ -1702,6 +1812,11 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
       visibleLength,
       zoomScale,
     };
+    if (this.state.pendingScrollUpdateCount > 0) {
+      this.setState(state => ({
+        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,
+      }));
+    }
     this._updateViewableItems(this.props, this.state.cellsAroundViewport);
     if (!this.props) {
       return;
@@ -1817,6 +1932,7 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
       const cellsAroundViewport = this._adjustCellsAroundViewport(
         props,
         state.cellsAroundViewport,
+        state.pendingScrollUpdateCount,
       );
       const renderMask = VirtualizedList._createRenderMask(
         props,
@@ -1847,7 +1963,7 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     return {
       index,
       item,
-      key: this._keyExtractor(item, index, props),
+      key: VirtualizedList._keyExtractor(item, index, props),
       isViewable,
     };
   };
@@ -1908,13 +2024,12 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     inLayout?: boolean,
     ...
   } => {
-    const {data, getItem, getItemCount, getItemLayout} = props;
+    const {data, getItemCount, getItemLayout} = props;
     invariant(
       index >= 0 && index < getItemCount(data),
       'Tried to get frame for out of range index ' + index,
     );
-    const item = getItem(data, index);
-    const frame = this._frames[this._keyExtractor(item, index, props)];
+    const frame = this._frames[VirtualizedList._getItemKey(props, index)];
     if (!frame || frame.index !== index) {
       if (getItemLayout) {
         /* $FlowFixMe[prop-missing] (>=0.63.0 site=react_native_fb) This comment
@@ -1949,11 +2064,8 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     // where it is.
     if (
       focusedCellIndex >= itemCount ||
-      this._keyExtractor(
-        props.getItem(props.data, focusedCellIndex),
-        focusedCellIndex,
-        props,
-      ) !== this._lastFocusedCellKey
+      VirtualizedList._getItemKey(props, focusedCellIndex) !==
+        this._lastFocusedCellKey
     ) {
       return [];
     }
@@ -1994,6 +2106,11 @@ class VirtualizedList extends StateSafePureComponent<Props, State> {
     props: FrameMetricProps,
     cellsAroundViewport: {first: number, last: number},
   ) {
+    // If we have any pending scroll updates it means that the scroll metrics
+    // are out of date and we should not call any of the visibility callbacks.
+    if (this.state.pendingScrollUpdateCount > 0) {
+      return;
+    }
     this._viewabilityTuples.forEach(tuple => {
       tuple.viewabilityHelper.onUpdate(
         props,
