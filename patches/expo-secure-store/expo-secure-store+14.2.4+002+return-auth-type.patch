diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
index 4a1a009..980ef0a 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
@@ -20,12 +20,12 @@ class AuthenticationHelper(
 ) {
   private var isAuthenticating = false

-  suspend fun authenticateCipher(cipher: Cipher, requiresAuthentication: Boolean, title: String, enableDeviceFallback: Boolean): Cipher {
-    if (requiresAuthentication) {
-      return openAuthenticationPrompt(cipher, title, enableDeviceFallback).cryptoObject?.cipher
-        ?: throw AuthenticationException("Couldn't get cipher from authentication result")
+  suspend fun authenticateCipher(cipher: Cipher, title: String, enableDeviceFallback: Boolean): BiometricPrompt.AuthenticationResult {
+    val promptResult = openAuthenticationPrompt(cipher, title, enableDeviceFallback)
+    if (promptResult.cryptoObject?.cipher == null) {
+      throw AuthenticationException("Couldn't get cipher from authentication result")
     }
-    return cipher
+    return promptResult
   }

   private suspend fun openAuthenticationPrompt(
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
index 3f21552..866d47d 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
@@ -36,23 +36,23 @@ open class SecureStoreModule : Module() {

     AsyncFunction("setValueWithKeyAsync") Coroutine { value: String?, key: String?, options: SecureStoreOptions ->
       key ?: throw NullKeyException()
-      return@Coroutine setItemImpl(key, value, options, false)
+      return@Coroutine setItemImpl(key, value, options, false).ordinal
     }

     AsyncFunction("getValueWithKeyAsync") Coroutine { key: String, options: SecureStoreOptions ->
-      return@Coroutine getItemImpl(key, options)
+      return@Coroutine getItemImpl(key, options).values
     }

     Function("setValueWithKeySync") { value: String?, key: String?, options: SecureStoreOptions ->
       key ?: throw NullKeyException()
       return@Function runBlocking {
-        return@runBlocking setItemImpl(key, value, options, keyIsInvalidated = false)
+        return@runBlocking setItemImpl(key, value, options, keyIsInvalidated = false).ordinal
       }
     }

     Function("getValueWithKeySync") { key: String, options: SecureStoreOptions ->
       return@Function runBlocking {
-        return@runBlocking getItemImpl(key, options)
+        return@runBlocking getItemImpl(key, options).values
       }
     }

@@ -94,7 +94,7 @@ open class SecureStoreModule : Module() {
     }
   }

-  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): String? {
+  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): SecureStoreFeedback<out String?> {
     // We use a SecureStore-specific shared preferences file, which lets us do things like enumerate
     // its entries or clear all of them
     val prefs: SharedPreferences = getSharedPreferences()
@@ -104,10 +104,10 @@ open class SecureStoreModule : Module() {
     } else if (prefs.contains(key)) { // For backwards-compatibility try to read using the old key format
       return readJSONEncodedItem(key, prefs, options)
     }
-    return null
+    return SecureStoreFeedback(null)
   }

-  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): String? {
+  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): SecureStoreFeedback<out String?> {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)

     val legacyEncryptedItemString = prefs.getString(key, null)
@@ -126,7 +126,7 @@ open class SecureStoreModule : Module() {
       ""
     }

-    encryptedItemString ?: return null
+    encryptedItemString ?: return SecureStoreFeedback(null)

     val encryptedItem: JSONObject = try {
       JSONObject(encryptedItemString)
@@ -149,13 +149,13 @@ open class SecureStoreModule : Module() {
                 "This situation occurs when the app is reinstalled. The value will be removed to avoid future errors. Returning null"
             )
             deleteItemImpl(key, options)
-            return null
+            return SecureStoreFeedback(null)
           }
           return mAESEncryptor.decryptItem(key, encryptedItem, secretKeyEntry, options, authenticationHelper)
         }
         HybridAESEncryptor.NAME -> {
           val privateKeyEntry = getKeyEntryCompat(PrivateKeyEntry::class.java, hybridAESEncryptor, options, requireAuthentication, usesKeystoreSuffix)
-            ?: return null
+            ?: return SecureStoreFeedback(null)
           return hybridAESEncryptor.decryptItem(key, encryptedItem, privateKeyEntry, options, authenticationHelper)
         }
         else -> {
@@ -164,7 +164,7 @@ open class SecureStoreModule : Module() {
       }
     } catch (e: KeyPermanentlyInvalidatedException) {
       Log.w(TAG, "The requested key has been permanently invalidated. Returning null")
-      return null
+      return SecureStoreFeedback(null)
     } catch (e: BadPaddingException) {
       // The key from the KeyStore is unable to decode the entry. This is because a new key was generated, but the entries are encrypted using the old one.
       // This usually means that the user has reinstalled the app. We can safely remove the old value and return null as it's impossible to decrypt it.
@@ -174,7 +174,7 @@ open class SecureStoreModule : Module() {
           "The entry in shared preferences is out of sync with the keystore. It will be removed, returning null."
       )
       deleteItemImpl(key, options)
-      return null
+      return SecureStoreFeedback(null)
     } catch (e: GeneralSecurityException) {
       throw (DecryptException(e.message, key, options.keychainService, e))
     } catch (e: CodedException) {
@@ -184,7 +184,7 @@ open class SecureStoreModule : Module() {
     }
   }

-  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean) {
+  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean): SecureStoreAuthType {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
     val prefs: SharedPreferences = getSharedPreferences()

@@ -193,7 +193,7 @@ open class SecureStoreModule : Module() {
       if (!success) {
         throw WriteException("Could not write a null value to SecureStore", key, options.keychainService)
       }
-      return
+      return SecureStoreAuthType.NONE
     }

     try {
@@ -210,7 +210,8 @@ open class SecureStoreModule : Module() {
        back a value.
        */
       val secretKeyEntry: SecretKeyEntry = getOrCreateKeyEntry(SecretKeyEntry::class.java, mAESEncryptor, options, options.requireAuthentication)
-      val encryptedItem = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper, options.enableDeviceFallback)
+      val encryptResult = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper, options.enableDeviceFallback)
+      val encryptedItem = encryptResult.value
       encryptedItem.put(SCHEME_PROPERTY, AESEncryptor.NAME)
       saveEncryptedItem(encryptedItem, prefs, keychainAwareKey, options.requireAuthentication, options.keychainService)

@@ -218,6 +219,9 @@ open class SecureStoreModule : Module() {
       if (prefs.contains(key)) {
         prefs.edit().remove(key).apply()
       }
+
+      return encryptResult.authType
+
     } catch (e: KeyPermanentlyInvalidatedException) {
       if (!keyIsInvalidated) {
         Log.w(TAG, "Key has been invalidated, retrying with the key deleted")
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
index 0455fd6..d38650c 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
@@ -1,5 +1,6 @@
 package expo.modules.securestore

+import androidx.biometric.BiometricPrompt
 import expo.modules.kotlin.records.Field
 import expo.modules.kotlin.records.Record
 import java.io.Serializable
@@ -11,3 +12,35 @@ class SecureStoreOptions(
   @Field var requireAuthentication: Boolean = false,
   @Field var enableDeviceFallback: Boolean = false
 ) : Record, Serializable
+
+enum class SecureStoreAuthType(index: Int) {
+  UNKNOWN(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_UNKNOWN),
+  CREDENTIAL(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_DEVICE_CREDENTIAL),
+  BIOMETRIC(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC),
+
+  /** Prompt failed, no authentication was used at all */
+  NONE(0)
+}
+
+data class SecureStoreFeedback<T>(
+  val value: T,
+  val authenticationResult: BiometricPrompt.AuthenticationResult? = null
+) {
+  @Field var authType: SecureStoreAuthType = when (authenticationResult?.authenticationType) {
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_UNKNOWN -> {
+      SecureStoreAuthType.UNKNOWN
+    }
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_DEVICE_CREDENTIAL -> {
+      SecureStoreAuthType.CREDENTIAL
+    }
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC -> {
+      SecureStoreAuthType.BIOMETRIC
+    }
+    else -> {
+      SecureStoreAuthType.NONE
+    }
+  }
+
+  /** Used to return easily convertible values to JS code */
+  @Field var values: Pair<T, Int> = Pair(value, authType.ordinal)
+}
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
index 1cd187f..44c84c3 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
@@ -5,8 +5,10 @@ import android.security.keystore.KeyGenParameterSpec
 import android.security.keystore.KeyProperties
 import android.util.Base64
 import androidx.annotation.RequiresApi
+import androidx.biometric.BiometricPrompt
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.DecryptException
+import expo.modules.securestore.SecureStoreFeedback
 import expo.modules.securestore.SecureStoreModule
 import expo.modules.securestore.SecureStoreOptions
 import org.json.JSONException
@@ -86,15 +88,23 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject {
+  ): SecureStoreFeedback<JSONObject> {
     val secretKey = keyStoreEntry.secretKey
     val cipher = Cipher.getInstance(AES_CIPHER)
     cipher.init(Cipher.ENCRYPT_MODE, secretKey)

     val gcmSpec = cipher.parameters.getParameterSpec(GCMParameterSpec::class.java)
-    val authenticatedCipher = authenticationHelper.authenticateCipher(cipher, requireAuthentication, authenticationPrompt, enableDeviceFallback)
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val authenticatedCipher: Cipher

-    return createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec)
+    if (requireAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(cipher, authenticationPrompt, enableDeviceFallback)
+      authenticatedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      authenticatedCipher = cipher
+    }
+
+    return SecureStoreFeedback(createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec), promptResult)
   }

   internal fun createEncryptedItemWithCipher(
@@ -121,7 +131,7 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     keyStoreEntry: KeyStore.SecretKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): SecureStoreFeedback<String> {
     val ciphertext = encryptedItem.getString(CIPHERTEXT_PROPERTY)
     val ivString = encryptedItem.getString(IV_PROPERTY)
     val authenticationTagLength = encryptedItem.getInt(GCM_AUTHENTICATION_TAG_LENGTH_PROPERTY)
@@ -135,8 +145,18 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
       throw DecryptException("Authentication tag length must be at least $MIN_GCM_AUTHENTICATION_TAG_LENGTH bits long", key, options.keychainService)
     }
     cipher.init(Cipher.DECRYPT_MODE, keyStoreEntry.secretKey, gcmSpec)
-    val unlockedCipher = authenticationHelper.authenticateCipher(cipher, requiresAuthentication, options.authenticationPrompt, options.enableDeviceFallback)
-    return String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8)
+
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val unlockedCipher: Cipher
+
+    if (requiresAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(cipher, options.authenticationPrompt, options.enableDeviceFallback)
+      unlockedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      unlockedCipher = cipher
+    }
+
+    return SecureStoreFeedback(String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8), promptResult)
   }

   companion object {
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
index 5f8bbfd..0b3ae0a 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
@@ -7,6 +7,7 @@ import android.util.Base64
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.EncryptException
 import expo.modules.securestore.KeyStoreException
+import expo.modules.securestore.SecureStoreFeedback
 import expo.modules.securestore.SecureStoreModule
 import expo.modules.securestore.SecureStoreOptions
 import org.json.JSONException
@@ -71,7 +72,7 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject {
+  ): SecureStoreFeedback<JSONObject> {
     // This should never be called after we dropped Android SDK 22 support.
     throw EncryptException(
       "HybridAESEncryption should not be used on Android SDK >= 23. This shouldn't happen. " +
@@ -88,7 +89,7 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     keyStoreEntry: KeyStore.PrivateKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): SecureStoreFeedback<String> {
     // Decrypt the encrypted symmetric key
     val encryptedSecretKeyString = encryptedItem.getString(ENCRYPTED_SECRET_KEY_PROPERTY)
     val encryptedSecretKeyBytes = Base64.decode(encryptedSecretKeyString, Base64.DEFAULT)
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
index 39459ff..66ba986 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
@@ -1,6 +1,7 @@
 package expo.modules.securestore.encryptors

 import expo.modules.securestore.AuthenticationHelper
+import expo.modules.securestore.SecureStoreFeedback
 import expo.modules.securestore.SecureStoreOptions
 import org.json.JSONException
 import org.json.JSONObject
@@ -27,7 +28,7 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject
+  ): SecureStoreFeedback<JSONObject>

   @Throws(GeneralSecurityException::class, JSONException::class)
   suspend fun decryptItem(
@@ -36,5 +37,5 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     keyStoreEntry: E,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String
+  ): SecureStoreFeedback<String>
 }
diff --git a/node_modules/expo-secure-store/build/SecureStore.d.ts b/node_modules/expo-secure-store/build/SecureStore.d.ts
index 835a4d4..77895d0 100644
--- a/node_modules/expo-secure-store/build/SecureStore.d.ts
+++ b/node_modules/expo-secure-store/build/SecureStore.d.ts
@@ -1,4 +1,53 @@
 export type KeychainAccessibilityConstant = number;
+
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export declare const AUTH_TYPE = {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    UNKNOWN: -1,
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    NONE: 0,
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    CREDENTIALS: 1,
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    BIOMETRICS: 2,
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    FACE_ID: 3,
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    TOUCH_ID: 4,
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    OPTIC_ID: 5
+} as const;
+
+type AuthType = (typeof AUTH_TYPE)[keyof typeof AUTH_TYPE];
+
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -119,7 +168,7 @@ export declare function deleteItemAsync(key: string, options?: SecureStoreOption
  * > After a key has been invalidated, it becomes impossible to read its value.
  * > This only applies to values stored with `requireAuthentication` set to `true`.
  */
-export declare function getItemAsync(key: string, options?: SecureStoreOptions): Promise<string | null>;
+export declare function getItemAsync(key: string, options?: SecureStoreOptions): Promise<[string | null, AuthType]>;
 /**
  * Stores a key–value pair.
  *
@@ -129,7 +178,7 @@ export declare function getItemAsync(key: string, options?: SecureStoreOptions):
  *
  * @return A promise that rejects if value cannot be stored on the device.
  */
-export declare function setItemAsync(key: string, value: string, options?: SecureStoreOptions): Promise<void>;
+export declare function setItemAsync(key: string, value: string, options?: SecureStoreOptions): Promise<AuthType>;
 /**
  * Stores a key–value pair synchronously.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.
@@ -139,7 +188,7 @@ export declare function setItemAsync(key: string, value: string, options?: Secur
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export declare function setItem(key: string, value: string, options?: SecureStoreOptions): void;
+export declare function setItem(key: string, value: string, options?: SecureStoreOptions): AuthType;
 /**
  * Synchronously reads the stored value associated with the provided key.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`
@@ -150,7 +199,7 @@ export declare function setItem(key: string, value: string, options?: SecureStor
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export declare function getItem(key: string, options?: SecureStoreOptions): string | null;
+export declare function getItem(key: string, options?: SecureStoreOptions): [string | null, AuthType];
 /**
  * Checks if the value can be saved with `requireAuthentication` option enabled.
  * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.
diff --git a/node_modules/expo-secure-store/build/SecureStore.js b/node_modules/expo-secure-store/build/SecureStore.js
index e11bd94..2371b88 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js
+++ b/node_modules/expo-secure-store/build/SecureStore.js
@@ -1,6 +1,52 @@
 import ExpoSecureStore from './ExpoSecureStore';
 import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';
 // @needsAudit
+
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    UNKNOWN: -1,
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    NONE: 0,
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    CREDENTIALS: 1,
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    BIOMETRICS: 2,
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    FACE_ID: 3,
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    TOUCH_ID: 4,
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    OPTIC_ID: 5
+};
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -102,7 +148,7 @@ export async function setItemAsync(key, value, options = {}) {
     if (!isValidValue(value)) {
         throw new Error(`Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`);
     }
-    await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+    return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }
 /**
  * Stores a key–value pair synchronously.
diff --git a/node_modules/expo-secure-store/ios/SecureStoreModule.swift b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
index 1268979..e4c3f2b 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreModule.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
@@ -18,28 +18,40 @@ public final class SecureStoreModule: Module {
       "WHEN_UNLOCKED_THIS_DEVICE_ONLY": SecureStoreAccessible.whenUnlockedThisDeviceOnly.rawValue
     ])

-    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
+      return getSecureStoreFeedback(value: try get(with: key, options: options)).values
     }

-    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) in
+      return getSecureStoreFeedback(value: try get(with: key, options: options)).values
     }

-    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) -> Bool in
+    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) -> Int in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }

-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+
+      if !result {
+        return AuthType.none.rawValue
+      }
+
+      return getSecureStoreFeedback(value: true).authType
     }

-    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) -> Bool in
+    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) -> Int in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }

-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+
+      if !result {
+        return AuthType.none.rawValue
+      }
+
+      return getSecureStoreFeedback(value: true).authType
     }

     AsyncFunction("deleteValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
@@ -53,18 +65,7 @@ public final class SecureStoreModule: Module {
     }

     Function("canUseBiometricAuthentication") {() -> Bool in
-      #if os(tvOS)
-      return false
-      #else
-      let context = LAContext()
-      var error: NSError?
-      let isBiometricsSupported: Bool = context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &error)
-
-      if error != nil {
-        return false
-      }
-      return isBiometricsSupported
-      #endif
+      return areBiometricsEnabled()
     }

     Function("canUseDeviceCredentialsAuthentication") { () -> Bool in
@@ -72,6 +73,31 @@ public final class SecureStoreModule: Module {
     }
   }

+  private func getAuthType() -> AuthType {
+    if !areBiometricsEnabled() {return AuthType.credentials}
+    let biometryType = LAContext().biometryType
+
+    switch biometryType {
+      case .faceID: return .faceID
+      case .touchID: return .touchID
+      case .opticID: return .opticID // available since iOS 17
+      case .none: fallthrough // this one continues to the next line
+      @unknown default: return .credentials
+    }
+  }
+
+  private func getSecureStoreFeedback<T>(value: T) -> SecureStoreFeedback<T> {
+    return SecureStoreFeedback(value: value, authType: getAuthType().rawValue)
+  }
+
+  private func areBiometricsEnabled() -> Bool {
+    #if os(tvOS)
+      return false
+    #else
+      return LAContext().canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: nil)
+    #endif
+  }
+
   private func areDeviceCredentialsEnabled() -> Bool {
     return LAContext().canEvaluatePolicy(LAPolicy.deviceOwnerAuthentication, error: nil)
   }
@@ -96,6 +122,29 @@ public final class SecureStoreModule: Module {
     return nil
   }

+  private func NSFaceIDUsageEntryGuard(options: SecureStoreOptions) throws {
+    if (options.enableDeviceFallback) {
+        return;
+    }
+
+    guard let _ = Bundle.main.infoDictionary?["NSFaceIDUsageDescription"] as? String else {
+      throw MissingPlistKeyException()
+    }
+  }
+
+  private func getAccessOptions(options: SecureStoreOptions, accessibility: CFString) throws -> SecAccessControl {
+    var error: Unmanaged<CFError>? = nil
+
+    let accessControlFlag: SecAccessControlCreateFlags = options.enableDeviceFallback ? .userPresence : .biometryCurrentSet
+
+    guard let accessOptions = SecAccessControlCreateWithFlags(kCFAllocatorDefault, accessibility, accessControlFlag, &error) else {
+      let errorCode = error.map { CFErrorGetCode($0.takeRetainedValue()) }
+      throw SecAccessControlError(errorCode)
+    }
+
+    return accessOptions
+  }
+
   private func set(value: String, with key: String, options: SecureStoreOptions) throws -> Bool {
     var setItemQuery = query(with: key, options: options, requireAuthentication: options.requireAuthentication)

@@ -107,21 +156,8 @@ public final class SecureStoreModule: Module {
     if !options.requireAuthentication {
       setItemQuery[kSecAttrAccessible as String] = accessibility
     } else {
-      if (!options.enableDeviceFallback) {
-        guard let _ = Bundle.main.infoDictionary?["NSFaceIDUsageDescription"] as? String else {
-          throw MissingPlistKeyException()
-        }
-      }
-
-      var error: Unmanaged<CFError>? = nil
-
-      let accessControlFlag: SecAccessControlCreateFlags = options.enableDeviceFallback ? .userPresence : .biometryCurrentSet
-
-      guard let accessOptions = SecAccessControlCreateWithFlags(kCFAllocatorDefault, accessibility, accessControlFlag, &error) else {
-        let errorCode = error.map { CFErrorGetCode($0.takeRetainedValue()) }
-        throw SecAccessControlError(errorCode)
-      }
-      setItemQuery[kSecAttrAccessControl as String] = accessOptions
+      try NSFaceIDUsageEntryGuard(options: options)
+      setItemQuery[kSecAttrAccessControl as String] = try getAccessOptions(options: options, accessibility: accessibility)
     }

     let status = SecItemAdd(setItemQuery as CFDictionary, nil)
diff --git a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
index c9e843b..13e15be 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
@@ -19,3 +19,32 @@ internal struct SecureStoreOptions: Record {
   @Field
   var enableDeviceFallback: Bool = false
 }
+
+@available(iOS 11.2, *)
+public enum AuthType: Int, @unchecked Sendable {
+  /// The device does not support biometry.
+  case none = 0
+
+  /// The device supports device credentials
+  case credentials = 1
+
+  /// Generic type, not specified whether it was a faceID or touchID
+  case biometrics = 2
+
+  /// The device supports Face ID.
+  case faceID = 3
+
+  /// The device supports Touch ID.
+  case touchID = 4
+
+  /// The device supports Optic ID
+  case opticID = 5
+}
+
+struct SecureStoreFeedback<T> {
+  var value: T
+  var authType: Int = AuthType.none.rawValue
+  var values: Array<Any> {
+    get { return [value, authType] }
+  }
+}
diff --git a/node_modules/expo-secure-store/src/SecureStore.ts b/node_modules/expo-secure-store/src/SecureStore.ts
index 4f253a1..c1cc118 100644
--- a/node_modules/expo-secure-store/src/SecureStore.ts
+++ b/node_modules/expo-secure-store/src/SecureStore.ts
@@ -3,6 +3,54 @@ import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';

 export type KeychainAccessibilityConstant = number;

+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+  /**
+   * This is purely for backwards compatibility.
+   * Although it is not listed as a return value of the getAuthenticationType() method,
+   * it is still present in the Android code.
+   * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+   * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+   * @platform android
+   */
+  UNKNOWN: -1,
+  /**
+   * Returned when the authentication fails
+   * @platform android
+   * @platform ios
+   */
+  NONE: 0,
+  /**
+   * Generic type, not specified whether it was a passcode or pattern.
+   * @platform android
+   * @platform ios
+   */
+  CREDENTIALS: 1,
+  /**
+   * Generic type, not specified whether it was a face scan or a fingerprint
+   * @platform android
+   */
+  BIOMETRICS: 2,
+  /**
+   * FaceID was used to authenticate
+   * @platform ios
+   */
+  FACE_ID: 3,
+  /**
+   * TouchID was used to authenticate
+   * @platform ios
+   */
+  TOUCH_ID: 4,
+  /**
+   * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+   */
+  OPTIC_ID: 5
+} as const;
+
+type AuthType = (typeof AUTH_TYPE)[keyof typeof AUTH_TYPE];
+
 // @needsAudit
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
@@ -162,7 +210,7 @@ export async function deleteItemAsync(
 export async function getItemAsync(
   key: string,
   options: SecureStoreOptions = {}
-): Promise<string | null> {
+): Promise<[string | null, AuthType]> {
   ensureValidKey(key);
   return await ExpoSecureStore.getValueWithKeyAsync(key, options);
 }
@@ -181,7 +229,7 @@ export async function setItemAsync(
   key: string,
   value: string,
   options: SecureStoreOptions = {}
-): Promise<void> {
+): Promise<AuthType> {
   ensureValidKey(key);
   if (!isValidValue(value)) {
     throw new Error(
@@ -189,7 +237,7 @@ export async function setItemAsync(
     );
   }

-  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+  return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }

 /**
@@ -201,7 +249,7 @@ export async function setItemAsync(
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {
+export function setItem(key: string, value: string, options: SecureStoreOptions = {}): AuthType {
   ensureValidKey(key);
   if (!isValidValue(value)) {
     throw new Error(
@@ -222,7 +270,7 @@ export function setItem(key: string, value: string, options: SecureStoreOptions
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export function getItem(key: string, options: SecureStoreOptions = {}): string | null {
+export function getItem(key: string, options: SecureStoreOptions = {}): [string | null, AuthType] {
   ensureValidKey(key);
   return ExpoSecureStore.getValueWithKeySync(key, options);
 }
