diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
index 4a1a009..980ef0a 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
@@ -20,12 +20,12 @@ class AuthenticationHelper(
 ) {
   private var isAuthenticating = false
 
-  suspend fun authenticateCipher(cipher: Cipher, requiresAuthentication: Boolean, title: String, enableDeviceFallback: Boolean): Cipher {
-    if (requiresAuthentication) {
-      return openAuthenticationPrompt(cipher, title, enableDeviceFallback).cryptoObject?.cipher
-        ?: throw AuthenticationException("Couldn't get cipher from authentication result")
+  suspend fun authenticateCipher(cipher: Cipher, title: String, enableDeviceFallback: Boolean): BiometricPrompt.AuthenticationResult {
+    val promptResult = openAuthenticationPrompt(cipher, title, enableDeviceFallback)
+    if (promptResult.cryptoObject?.cipher == null) {
+      throw AuthenticationException("Couldn't get cipher from authentication result")
     }
-    return cipher
+    return promptResult
   }
 
   private suspend fun openAuthenticationPrompt(
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
index 3f21552..d209efc 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
@@ -36,23 +36,23 @@ open class SecureStoreModule : Module() {
 
     AsyncFunction("setValueWithKeyAsync") Coroutine { value: String?, key: String?, options: SecureStoreOptions ->
       key ?: throw NullKeyException()
-      return@Coroutine setItemImpl(key, value, options, false)
+      return@Coroutine narrowSecureStoreFeedback(SecureStoreFeedbackAction.SET, setItemImpl(key, value, options, false), options)
     }
 
     AsyncFunction("getValueWithKeyAsync") Coroutine { key: String, options: SecureStoreOptions ->
-      return@Coroutine getItemImpl(key, options)
+      return@Coroutine narrowSecureStoreFeedback(SecureStoreFeedbackAction.GET,getItemImpl(key, options), options)
     }
 
     Function("setValueWithKeySync") { value: String?, key: String?, options: SecureStoreOptions ->
       key ?: throw NullKeyException()
       return@Function runBlocking {
-        return@runBlocking setItemImpl(key, value, options, keyIsInvalidated = false)
+        return@runBlocking narrowSecureStoreFeedback(SecureStoreFeedbackAction.SET, setItemImpl(key, value, options, keyIsInvalidated = false), options).value
       }
     }
 
     Function("getValueWithKeySync") { key: String, options: SecureStoreOptions ->
       return@Function runBlocking {
-        return@runBlocking getItemImpl(key, options)
+        return@runBlocking narrowSecureStoreFeedback(SecureStoreFeedbackAction.GET, getItemImpl(key, options), options).value
       }
     }
 
@@ -94,7 +94,23 @@ open class SecureStoreModule : Module() {
     }
   }
 
-  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): String? {
+  private suspend fun <T> narrowSecureStoreFeedback(action: String, feedback: SecureStoreOriginalFeedback<T>, options: SecureStoreOptions): SecureStoreNarrowedFeedback<T> {
+    if (!options.returnUsedAuthenticationType) {
+      return feedback
+    }
+
+    if (action == SecureStoreFeedbackAction.GET) {
+      return SecureStoreGetFeedback(feedback.source, feedback.authenticationResult)
+    }
+
+    if (action == SecureStoreFeedbackAction.SET) {
+      return SecureStoreSetFeedback(feedback.source, feedback.authenticationResult)
+    }
+
+    return feedback
+  }
+
+  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): SecureStoreOriginalFeedback<out String?> {
     // We use a SecureStore-specific shared preferences file, which lets us do things like enumerate
     // its entries or clear all of them
     val prefs: SharedPreferences = getSharedPreferences()
@@ -104,10 +120,10 @@ open class SecureStoreModule : Module() {
     } else if (prefs.contains(key)) { // For backwards-compatibility try to read using the old key format
       return readJSONEncodedItem(key, prefs, options)
     }
-    return null
+    return SecureStoreOriginalFeedback(null)
   }
 
-  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): String? {
+  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): SecureStoreOriginalFeedback<out String?> {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
 
     val legacyEncryptedItemString = prefs.getString(key, null)
@@ -126,7 +142,7 @@ open class SecureStoreModule : Module() {
       ""
     }
 
-    encryptedItemString ?: return null
+    encryptedItemString ?: return SecureStoreOriginalFeedback(null)
 
     val encryptedItem: JSONObject = try {
       JSONObject(encryptedItemString)
@@ -149,13 +165,13 @@ open class SecureStoreModule : Module() {
                 "This situation occurs when the app is reinstalled. The value will be removed to avoid future errors. Returning null"
             )
             deleteItemImpl(key, options)
-            return null
+            return SecureStoreOriginalFeedback(null)
           }
           return mAESEncryptor.decryptItem(key, encryptedItem, secretKeyEntry, options, authenticationHelper)
         }
         HybridAESEncryptor.NAME -> {
           val privateKeyEntry = getKeyEntryCompat(PrivateKeyEntry::class.java, hybridAESEncryptor, options, requireAuthentication, usesKeystoreSuffix)
-            ?: return null
+            ?: return SecureStoreOriginalFeedback(null)
           return hybridAESEncryptor.decryptItem(key, encryptedItem, privateKeyEntry, options, authenticationHelper)
         }
         else -> {
@@ -164,7 +180,7 @@ open class SecureStoreModule : Module() {
       }
     } catch (e: KeyPermanentlyInvalidatedException) {
       Log.w(TAG, "The requested key has been permanently invalidated. Returning null")
-      return null
+      return SecureStoreOriginalFeedback(null)
     } catch (e: BadPaddingException) {
       // The key from the KeyStore is unable to decode the entry. This is because a new key was generated, but the entries are encrypted using the old one.
       // This usually means that the user has reinstalled the app. We can safely remove the old value and return null as it's impossible to decrypt it.
@@ -174,7 +190,7 @@ open class SecureStoreModule : Module() {
           "The entry in shared preferences is out of sync with the keystore. It will be removed, returning null."
       )
       deleteItemImpl(key, options)
-      return null
+      return SecureStoreOriginalFeedback(null)
     } catch (e: GeneralSecurityException) {
       throw (DecryptException(e.message, key, options.keychainService, e))
     } catch (e: CodedException) {
@@ -184,7 +200,7 @@ open class SecureStoreModule : Module() {
     }
   }
 
-  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean) {
+  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean): SecureStoreOriginalFeedback<out JSONObject?> {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
     val prefs: SharedPreferences = getSharedPreferences()
 
@@ -193,7 +209,7 @@ open class SecureStoreModule : Module() {
       if (!success) {
         throw WriteException("Could not write a null value to SecureStore", key, options.keychainService)
       }
-      return
+      return SecureStoreOriginalFeedback(null)
     }
 
     try {
@@ -210,7 +226,8 @@ open class SecureStoreModule : Module() {
        back a value.
        */
       val secretKeyEntry: SecretKeyEntry = getOrCreateKeyEntry(SecretKeyEntry::class.java, mAESEncryptor, options, options.requireAuthentication)
-      val encryptedItem = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper, options.enableDeviceFallback)
+      val encryptResult = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper, options.enableDeviceFallback)
+      val encryptedItem = encryptResult.value
       encryptedItem.put(SCHEME_PROPERTY, AESEncryptor.NAME)
       saveEncryptedItem(encryptedItem, prefs, keychainAwareKey, options.requireAuthentication, options.keychainService)
 
@@ -218,6 +235,9 @@ open class SecureStoreModule : Module() {
       if (prefs.contains(key)) {
         prefs.edit().remove(key).apply()
       }
+
+      return encryptResult
+
     } catch (e: KeyPermanentlyInvalidatedException) {
       if (!keyIsInvalidated) {
         Log.w(TAG, "Key has been invalidated, retrying with the key deleted")
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
index 0455fd6..4e30440 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
@@ -1,5 +1,6 @@
 package expo.modules.securestore
 
+import androidx.biometric.BiometricPrompt
 import expo.modules.kotlin.records.Field
 import expo.modules.kotlin.records.Record
 import java.io.Serializable
@@ -9,5 +10,58 @@ class SecureStoreOptions(
   @Field var authenticationPrompt: String = " ",
   @Field var keychainService: String = SecureStoreModule.DEFAULT_KEYSTORE_ALIAS,
   @Field var requireAuthentication: Boolean = false,
-  @Field var enableDeviceFallback: Boolean = false
+  @Field var enableDeviceFallback: Boolean = false,
+  @Field var returnUsedAuthenticationType: Boolean = false
 ) : Record, Serializable
+
+enum class SecureStoreAuthType(index: Int) {
+  UNKNOWN(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_UNKNOWN),
+  CREDENTIAL(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_DEVICE_CREDENTIAL),
+  BIOMETRIC(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC),
+
+  /** Prompt failed, no authentication was used at all */
+  NONE(0)
+}
+
+open class SecureStoreFeedbackAction {
+  companion object {
+    const val GET = "GET"
+    const val SET = "SET"
+  }
+}
+
+abstract class SecureStoreFeedback<T, R>(
+  val source: T,
+  val authenticationResult: BiometricPrompt.AuthenticationResult?
+) {
+  @Field var authType: SecureStoreAuthType = when (authenticationResult?.authenticationType) {
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_UNKNOWN -> {
+      SecureStoreAuthType.UNKNOWN
+    }
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_DEVICE_CREDENTIAL -> {
+      SecureStoreAuthType.CREDENTIAL
+    }
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC -> {
+      SecureStoreAuthType.BIOMETRIC
+    }
+    else -> {
+      SecureStoreAuthType.NONE
+    }
+  }
+  abstract val value: R
+}
+
+class SecureStoreGetFeedback<T>(source: T, authenticationResult: BiometricPrompt.AuthenticationResult? = null): SecureStoreFeedback<T, Pair<T, Int>>(source, authenticationResult) {
+  /** Used to return easily convertible values to JS code */
+  @Field override var value: Pair<T, Int> = Pair(source, authType.ordinal)
+}
+
+class SecureStoreSetFeedback<T>(source: T, authenticationResult: BiometricPrompt.AuthenticationResult? = null): SecureStoreFeedback<T, Int>(source, authenticationResult) {
+  @Field override var value: Int = authType.ordinal
+}
+
+class SecureStoreOriginalFeedback<T>(source: T, authenticationResult: BiometricPrompt.AuthenticationResult? = null): SecureStoreFeedback<T, T>(source, authenticationResult) {
+  @Field override var value: T = source
+}
+
+typealias SecureStoreNarrowedFeedback<T> = SecureStoreFeedback<T, out Any?>
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
index 1cd187f..d927ff1 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
@@ -5,10 +5,12 @@ import android.security.keystore.KeyGenParameterSpec
 import android.security.keystore.KeyProperties
 import android.util.Base64
 import androidx.annotation.RequiresApi
+import androidx.biometric.BiometricPrompt
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.DecryptException
 import expo.modules.securestore.SecureStoreModule
 import expo.modules.securestore.SecureStoreOptions
+import expo.modules.securestore.SecureStoreOriginalFeedback
 import org.json.JSONException
 import org.json.JSONObject
 import java.nio.charset.StandardCharsets
@@ -86,15 +88,23 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject {
+  ): SecureStoreOriginalFeedback<JSONObject> {
     val secretKey = keyStoreEntry.secretKey
     val cipher = Cipher.getInstance(AES_CIPHER)
     cipher.init(Cipher.ENCRYPT_MODE, secretKey)
 
     val gcmSpec = cipher.parameters.getParameterSpec(GCMParameterSpec::class.java)
-    val authenticatedCipher = authenticationHelper.authenticateCipher(cipher, requireAuthentication, authenticationPrompt, enableDeviceFallback)
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val authenticatedCipher: Cipher
+
+    if (requireAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(cipher, authenticationPrompt, enableDeviceFallback)
+      authenticatedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      authenticatedCipher = cipher
+    }
 
-    return createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec)
+    return SecureStoreOriginalFeedback(createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec), promptResult)
   }
 
   internal fun createEncryptedItemWithCipher(
@@ -121,7 +131,7 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     keyStoreEntry: KeyStore.SecretKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): SecureStoreOriginalFeedback<String> {
     val ciphertext = encryptedItem.getString(CIPHERTEXT_PROPERTY)
     val ivString = encryptedItem.getString(IV_PROPERTY)
     val authenticationTagLength = encryptedItem.getInt(GCM_AUTHENTICATION_TAG_LENGTH_PROPERTY)
@@ -135,8 +145,17 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
       throw DecryptException("Authentication tag length must be at least $MIN_GCM_AUTHENTICATION_TAG_LENGTH bits long", key, options.keychainService)
     }
     cipher.init(Cipher.DECRYPT_MODE, keyStoreEntry.secretKey, gcmSpec)
-    val unlockedCipher = authenticationHelper.authenticateCipher(cipher, requiresAuthentication, options.authenticationPrompt, options.enableDeviceFallback)
-    return String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8)
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val unlockedCipher: Cipher
+
+    if (requiresAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(cipher, options.authenticationPrompt, options.enableDeviceFallback)
+      unlockedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      unlockedCipher = cipher
+    }
+
+    return SecureStoreOriginalFeedback(String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8), promptResult)
   }
 
   companion object {
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
index 5f8bbfd..7527001 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
@@ -9,6 +9,7 @@ import expo.modules.securestore.EncryptException
 import expo.modules.securestore.KeyStoreException
 import expo.modules.securestore.SecureStoreModule
 import expo.modules.securestore.SecureStoreOptions
+import expo.modules.securestore.SecureStoreOriginalFeedback
 import org.json.JSONException
 import org.json.JSONObject
 import java.security.GeneralSecurityException
@@ -71,7 +72,7 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject {
+  ): SecureStoreOriginalFeedback<JSONObject> {
     // This should never be called after we dropped Android SDK 22 support.
     throw EncryptException(
       "HybridAESEncryption should not be used on Android SDK >= 23. This shouldn't happen. " +
@@ -88,7 +89,7 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     keyStoreEntry: KeyStore.PrivateKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): SecureStoreOriginalFeedback<String> {
     // Decrypt the encrypted symmetric key
     val encryptedSecretKeyString = encryptedItem.getString(ENCRYPTED_SECRET_KEY_PROPERTY)
     val encryptedSecretKeyBytes = Base64.decode(encryptedSecretKeyString, Base64.DEFAULT)
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
index 39459ff..a531aff 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
@@ -2,6 +2,7 @@ package expo.modules.securestore.encryptors
 
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.SecureStoreOptions
+import expo.modules.securestore.SecureStoreOriginalFeedback
 import org.json.JSONException
 import org.json.JSONObject
 import java.security.GeneralSecurityException
@@ -27,7 +28,7 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject
+  ): SecureStoreOriginalFeedback<JSONObject>
 
   @Throws(GeneralSecurityException::class, JSONException::class)
   suspend fun decryptItem(
@@ -36,5 +37,5 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     keyStoreEntry: E,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String
+  ): SecureStoreOriginalFeedback<String>
 }
diff --git a/node_modules/expo-secure-store/build/SecureStore.d.ts b/node_modules/expo-secure-store/build/SecureStore.d.ts
index 835a4d4..7bfcc98 100644
--- a/node_modules/expo-secure-store/build/SecureStore.d.ts
+++ b/node_modules/expo-secure-store/build/SecureStore.d.ts
@@ -1,4 +1,53 @@
+type EmptyObject = Record<string, never>;
+type SecureStoreSetFeedback<R extends SecureStoreOptions> = R['returnUsedAuthenticationType'] extends true ? AuthType : void;
+type SecureStoreGetFeedback<T, R extends SecureStoreOptions> = R['returnUsedAuthenticationType'] extends true ? [T | null, AuthType] : T | null;
 export type KeychainAccessibilityConstant = number;
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export declare const AUTH_TYPE: {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    readonly UNKNOWN: -1;
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    readonly NONE: 0;
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    readonly CREDENTIALS: 1;
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    readonly BIOMETRICS: 2;
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    readonly FACE_ID: 3;
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    readonly TOUCH_ID: 4;
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    readonly OPTIC_ID: 5;
+};
+type AuthType = (typeof AUTH_TYPE)[keyof typeof AUTH_TYPE];
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -59,6 +108,7 @@ export type SecureStoreOptions = {
      * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.
      * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.
      *
+     * > **Note:** This library requires a real device for testing since emulators/simulators do not require biometric authentication when retrieving secrets, unlike real iOS devices.
      */
     requireAuthentication?: boolean;
     /**
@@ -88,6 +138,22 @@ export type SecureStoreOptions = {
      * @platform ios
      */
     enableDeviceFallback?: boolean;
+    /**
+     * When this flag is set to true, the get methods of SecureStore will return a two-element array. The first value will be the original value returned when this flag is set to false.
+     * The second value is the authentication type used to read the value from the AUTH_TYPE object.
+     * As for the set function, the returned value will simply be AUTH_TYPE.
+     *
+     * @warning
+     * If the iOS device supports biometrics and the user falls back to device credentials, it will not be detected.
+     * This is not the case on Android, but we cannot specify the exact type of biometrics (e.g. fingerprint or face scan).
+     * Whether the type is detected correctly depends on the platform and its native implementation.
+     * This should be treated as more of a hint.
+     *
+     * @default false
+     * @platform android
+     * @platform ios
+     */
+    returnUsedAuthenticationType?: boolean;
 };
 /**
  * Returns whether the SecureStore API is enabled on the current device. This does not check the app
@@ -119,27 +185,27 @@ export declare function deleteItemAsync(key: string, options?: SecureStoreOption
  * > After a key has been invalidated, it becomes impossible to read its value.
  * > This only applies to values stored with `requireAuthentication` set to `true`.
  */
-export declare function getItemAsync(key: string, options?: SecureStoreOptions): Promise<string | null>;
+export declare function getItemAsync<R extends SecureStoreOptions>(key: string, options?: R | EmptyObject): Promise<SecureStoreGetFeedback<string, R>>;
 /**
  * Stores a key–value pair.
  *
  * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.
- * @param value The value to store. Size limit is 2048 bytes.
+ * @param value The value to store.
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  * @return A promise that rejects if value cannot be stored on the device.
  */
-export declare function setItemAsync(key: string, value: string, options?: SecureStoreOptions): Promise<void>;
+export declare function setItemAsync<R extends SecureStoreOptions>(key: string, value: string, options?: R | EmptyObject): Promise<SecureStoreSetFeedback<R>>;
 /**
  * Stores a key–value pair synchronously.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.
  *
  * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.
- * @param value The value to store. Size limit is 2048 bytes.
+ * @param value The value to store.
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export declare function setItem(key: string, value: string, options?: SecureStoreOptions): void;
+export declare function setItem<R extends SecureStoreOptions>(key: string, value: string, options?: R | EmptyObject): SecureStoreSetFeedback<R>;
 /**
  * Synchronously reads the stored value associated with the provided key.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`
@@ -150,7 +216,7 @@ export declare function setItem(key: string, value: string, options?: SecureStor
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export declare function getItem(key: string, options?: SecureStoreOptions): string | null;
+export declare function getItem<R extends SecureStoreOptions>(key: string, options?: R | EmptyObject): SecureStoreGetFeedback<string, R>;
 /**
  * Checks if the value can be saved with `requireAuthentication` option enabled.
  * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.
@@ -165,4 +231,5 @@ export declare function canUseBiometricAuthentication(): boolean;
  * @platform ios
  */
 export declare function canUseDeviceCredentialsAuthentication(): boolean;
+export {};
 //# sourceMappingURL=SecureStore.d.ts.map
diff --git a/node_modules/expo-secure-store/build/SecureStore.js b/node_modules/expo-secure-store/build/SecureStore.js
index e11bd94..04569ac 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js
+++ b/node_modules/expo-secure-store/build/SecureStore.js
@@ -1,6 +1,53 @@
 import ExpoSecureStore from './ExpoSecureStore';
 import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';
 // @needsAudit
+
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    UNKNOWN: -1,
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    NONE: 0,
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    CREDENTIALS: 1,
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    BIOMETRICS: 2,
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    FACE_ID: 3,
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    TOUCH_ID: 4,
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    OPTIC_ID: 5,
+};
+// @needsAudit
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -92,7 +139,7 @@ export async function getItemAsync(key, options = {}) {
  * Stores a key–value pair.
  *
  * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.
- * @param value The value to store. Size limit is 2048 bytes.
+ * @param value The value to store.
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  * @return A promise that rejects if value cannot be stored on the device.
@@ -102,14 +149,14 @@ export async function setItemAsync(key, value, options = {}) {
     if (!isValidValue(value)) {
         throw new Error(`Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`);
     }
-    await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+    return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }
 /**
  * Stores a key–value pair synchronously.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.
  *
  * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.
- * @param value The value to store. Size limit is 2048 bytes.
+ * @param value The value to store.
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
diff --git a/node_modules/expo-secure-store/ios/SecureStoreModule.swift b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
index 1268979..5280020 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreModule.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
@@ -8,38 +8,44 @@ public final class SecureStoreModule: Module {
   public func definition() -> ModuleDefinition {
     Name("ExpoSecureStore")
 
-    Constants([
-      "AFTER_FIRST_UNLOCK": SecureStoreAccessible.afterFirstUnlock.rawValue,
-      "AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY": SecureStoreAccessible.afterFirstUnlockThisDeviceOnly.rawValue,
-      "ALWAYS": SecureStoreAccessible.always.rawValue,
-      "WHEN_PASSCODE_SET_THIS_DEVICE_ONLY": SecureStoreAccessible.whenPasscodeSetThisDeviceOnly.rawValue,
-      "ALWAYS_THIS_DEVICE_ONLY": SecureStoreAccessible.alwaysThisDeviceOnly.rawValue,
-      "WHEN_UNLOCKED": SecureStoreAccessible.whenUnlocked.rawValue,
-      "WHEN_UNLOCKED_THIS_DEVICE_ONLY": SecureStoreAccessible.whenUnlockedThisDeviceOnly.rawValue
-    ])
-
-    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    Constant("AFTER_FIRST_UNLOCK") { SecureStoreAccessible.afterFirstUnlock.rawValue }
+    Constant("AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY") { SecureStoreAccessible.afterFirstUnlockThisDeviceOnly.rawValue }
+    Constant("ALWAYS") { SecureStoreAccessible.always.rawValue }
+    Constant("WHEN_PASSCODE_SET_THIS_DEVICE_ONLY") { SecureStoreAccessible.whenPasscodeSetThisDeviceOnly.rawValue }
+    Constant("ALWAYS_THIS_DEVICE_ONLY") { SecureStoreAccessible.alwaysThisDeviceOnly.rawValue }
+    Constant("WHEN_UNLOCKED") { SecureStoreAccessible.whenUnlocked.rawValue }
+    Constant("WHEN_UNLOCKED_THIS_DEVICE_ONLY") { SecureStoreAccessible.whenUnlockedThisDeviceOnly.rawValue }
+
+    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
+      let result = try get(with: key, options: options)
+
+      return wrapResultWithFeedback(action: .get, result: result, options: options).value
     }
 
-    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) in
+      let result = try get(with: key, options: options)
+
+      return wrapResultWithFeedback(action: .get, result: result, options: options).value
     }
 
-    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) -> Bool in
+    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }
 
-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+
+      return wrapResultWithFeedback(action: .set, result: result, options: options).value
     }
 
-    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) -> Bool in
+    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }
 
-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+
+      return wrapResultWithFeedback(action: .set, result: result, options: options).value
     }
 
     AsyncFunction("deleteValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
@@ -53,18 +59,7 @@ public final class SecureStoreModule: Module {
     }
 
     Function("canUseBiometricAuthentication") {() -> Bool in
-      #if os(tvOS)
-      return false
-      #else
-      let context = LAContext()
-      var error: NSError?
-      let isBiometricsSupported: Bool = context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &error)
-
-      if error != nil {
-        return false
-      }
-      return isBiometricsSupported
-      #endif
+      return areBiometricsEnabled()
     }
 
     Function("canUseDeviceCredentialsAuthentication") { () -> Bool in
@@ -76,6 +71,41 @@ public final class SecureStoreModule: Module {
     return LAContext().canEvaluatePolicy(LAPolicy.deviceOwnerAuthentication, error: nil)
   }
 
+  private func getAuthType() -> AuthType {
+    if !areBiometricsEnabled() {return AuthType.credentials}
+    let biometryType = LAContext().biometryType
+
+    switch biometryType {
+      case .faceID: return .faceID
+      case .touchID: return .touchID
+      case .opticID: return .opticID // available since iOS 17
+      case .none: fallthrough // this one continues to the next line
+      @unknown default: return .credentials
+    }
+  }
+
+  private func wrapResultWithFeedback<T>(action: SecureStoreFeedbackAction, result: T, options: SecureStoreOptions) -> any SecureStoreFeedback {
+    let authType = getAuthType().rawValue
+
+    if (!options.returnUsedAuthenticationType) {
+      return SecureStoreOriginalFeedback(source: result, authType: authType)
+    }
+
+    if (action == .get) {
+      return SecureStoreGetFeedback(source: result, authType: authType)
+    }
+
+    return SecureStoreSetFeedback(source: result, authType: authType)
+  }
+
+  private func areBiometricsEnabled() -> Bool {
+    #if os(tvOS)
+      return false
+    #else
+      return LAContext().canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: nil)
+    #endif
+  }
+
   private func get(with key: String, options: SecureStoreOptions) throws -> String? {
     guard let key = validate(for: key) else {
       throw InvalidKeyException()
diff --git a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
index c9e843b..b95eca7 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
@@ -18,4 +18,71 @@ internal struct SecureStoreOptions: Record {
 
   @Field
   var enableDeviceFallback: Bool = false
+
+  @Field
+  var returnUsedAuthenticationType: Bool = false
+}
+
+@available(iOS 11.2, *)
+public enum AuthType: Int, @unchecked Sendable {
+  /// The device does not support biometry.
+  case none = 0
+
+  /// The device supports device credentials
+  case credentials = 1
+
+  /// Generic type, not specified whether it was a faceID or touchID
+  case biometrics = 2
+
+  /// The device supports Face ID.
+  case faceID = 3
+
+  /// The device supports Touch ID.
+  case touchID = 4
+
+  /// The device supports Optic ID
+  case opticID = 5
+}
+
+public enum SecureStoreFeedbackAction: String {
+  case set
+  case get
+}
+
+protocol SecureStoreFeedback {
+  associatedtype Source
+  associatedtype Value
+  var source: Source { get }
+  var authType: Int { get }
+  var value: Value { get }
+}
+
+struct SecureStoreGetFeedback<T>: SecureStoreFeedback {
+  typealias Source = T
+  typealias Value = Array<Any>
+  var source: Source
+  var authType: Int = AuthType.none.rawValue
+  var value: Value {
+    get { return [source, authType] }
+  }
+}
+
+struct SecureStoreOriginalFeedback<T>: SecureStoreFeedback {
+  typealias Source = T
+  typealias Value = T
+  var source: Source
+  var authType: Int = AuthType.none.rawValue
+  var value: Value {
+    get { return source }
+  }
+}
+
+struct SecureStoreSetFeedback<T>: SecureStoreFeedback {
+  typealias Source = T
+  typealias Value = Int
+  var source: Source
+  var authType: Int = AuthType.none.rawValue
+  var value: Value {
+    get { return authType }
+  }
 }
diff --git a/node_modules/expo-secure-store/src/SecureStore.ts b/node_modules/expo-secure-store/src/SecureStore.ts
index 4f253a1..e32ebdf 100644
--- a/node_modules/expo-secure-store/src/SecureStore.ts
+++ b/node_modules/expo-secure-store/src/SecureStore.ts
@@ -1,8 +1,63 @@
 import ExpoSecureStore from './ExpoSecureStore';
 import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';
 
+type EmptyObject = Record<string, never>;
+type SecureStoreSetFeedback<R extends SecureStoreOptions> =
+    R['returnUsedAuthenticationType'] extends true ? AuthType : void;
+type SecureStoreGetFeedback<
+    T,
+    R extends SecureStoreOptions,
+> = R['returnUsedAuthenticationType'] extends true ? [T | null, AuthType] : T | null;
 export type KeychainAccessibilityConstant = number;
 
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    UNKNOWN: -1,
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    NONE: 0,
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    CREDENTIALS: 1,
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    BIOMETRICS: 2,
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    FACE_ID: 3,
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    TOUCH_ID: 4,
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    OPTIC_ID: 5,
+} as const;
+
+type AuthType = (typeof AUTH_TYPE)[keyof typeof AUTH_TYPE];
+
 // @needsAudit
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
@@ -17,7 +72,7 @@ export const AFTER_FIRST_UNLOCK: KeychainAccessibilityConstant = ExpoSecureStore
  * from a backup.
  */
 export const AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =
-  ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;
+    ExpoSecureStore.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY;
 
 // @needsAudit
 /**
@@ -34,7 +89,7 @@ export const ALWAYS: KeychainAccessibilityConstant = ExpoSecureStore.ALWAYS;
  * store an entry. If the user removes their passcode, the entry will be deleted.
  */
 export const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =
-  ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;
+    ExpoSecureStore.WHEN_PASSCODE_SET_THIS_DEVICE_ONLY;
 
 // @needsAudit
 /**
@@ -43,7 +98,7 @@ export const WHEN_PASSCODE_SET_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =
  * @deprecated Use an accessibility level that provides some user protection, such as `AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY`.
  */
 export const ALWAYS_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =
-  ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;
+    ExpoSecureStore.ALWAYS_THIS_DEVICE_ONLY;
 
 // @needsAudit
 /**
@@ -57,62 +112,80 @@ export const WHEN_UNLOCKED: KeychainAccessibilityConstant = ExpoSecureStore.WHEN
  * a backup.
  */
 export const WHEN_UNLOCKED_THIS_DEVICE_ONLY: KeychainAccessibilityConstant =
-  ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;
+    ExpoSecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY;
 
 // @needsAudit
 export type SecureStoreOptions = {
-  /**
-   * - Android: Equivalent of the public/private key pair `Alias`.
-   * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).
-   * > If the item is set with the `keychainService` option, it will be required to later fetch the value.
-   */
-  keychainService?: string;
-  /**
-   * Option responsible for enabling the usage of the user authentication methods available on the device while
-   * accessing data stored in SecureStore.
-   * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))
-   *   (requires API 23).
-   * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).
-   * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`
-   * value used for the others non-authenticated operations.
-   *
-   * This option works slightly differently across platforms: On Android, user authentication is required for all operations.
-   * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).
-   *
-   * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.
-   * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.
-   *
-   */
-  requireAuthentication?: boolean;
-  /**
-   * Custom message displayed to the user while `requireAuthentication` option is turned on.
-   */
-  authenticationPrompt?: string;
-  /**
-   * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.
-   * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).
-   * @default SecureStore.WHEN_UNLOCKED
-   * @platform ios
-   */
-  keychainAccessible?: KeychainAccessibilityConstant;
+    /**
+     * - Android: Equivalent of the public/private key pair `Alias`.
+     * - iOS: The item's service, equivalent to [`kSecAttrService`](https://developer.apple.com/documentation/security/ksecattrservice/).
+     * > If the item is set with the `keychainService` option, it will be required to later fetch the value.
+     */
+    keychainService?: string;
+    /**
+     * Option responsible for enabling the usage of the user authentication methods available on the device while
+     * accessing data stored in SecureStore.
+     * - Android: Equivalent to [`setUserAuthenticationRequired(true)`](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder#setUserAuthenticationRequired(boolean))
+     *   (requires API 23).
+     * - iOS: Equivalent to [`biometryCurrentSet`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/2937192-biometrycurrentset).
+     * Complete functionality is unlocked only with a freshly generated key - this would not work in tandem with the `keychainService`
+     * value used for the others non-authenticated operations.
+     *
+     * This option works slightly differently across platforms: On Android, user authentication is required for all operations.
+     * On iOS, the user is prompted to authenticate only when reading or updating an existing value (not when creating a new one).
+     *
+     * Warning: This option is not supported in Expo Go when biometric authentication is available due to a missing NSFaceIDUsageDescription.
+     * In release builds or when using continuous native generation, make sure to use the `expo-secure-store` config plugin.
+     *
+     * > **Note:** This library requires a real device for testing since emulators/simulators do not require biometric authentication when retrieving secrets, unlike real iOS devices.
+     */
+    requireAuthentication?: boolean;
+    /**
+     * Custom message displayed to the user while `requireAuthentication` option is turned on.
+     */
+    authenticationPrompt?: string;
+    /**
+     * Specifies when the stored entry is accessible, using iOS's `kSecAttrAccessible` property.
+     * @see Apple's documentation on [keychain item accessibility](https://developer.apple.com/documentation/security/ksecattraccessible/).
+     * @default SecureStore.WHEN_UNLOCKED
+     * @platform ios
+     */
+    keychainAccessible?: KeychainAccessibilityConstant;
+
+    /**
+     * Specifies the access group the stored entry belongs to.
+     * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).
+     * @platform ios
+     */
+    accessGroup?: string;
 
-  /**
-   * Specifies the access group the stored entry belongs to.
-   * @see Apple's documentation on [Sharing access to keychain items among a collection of apps](https://developer.apple.com/documentation/security/sharing-access-to-keychain-items-among-a-collection-of-apps).
-   * @platform ios
-   */
-  accessGroup?: string;
+    /**
+     * This flag enables users to authenticate using Lock Screen Knowledge Factor (e.g. PIN, pattern or password).
+     * For sensitive apps, it is recommended not having biometric fall back to such factor.
+     * @see: https://developer.android.com/security/fraud-prevention/authentication
+     *
+     * @default false
+     * @platform android
+     * @platform ios
+     */
+    enableDeviceFallback?: boolean;
 
-  /**
-   * This flag enables users to authenticate using Lock Screen Knowledge Factor (e.g. PIN, pattern or password).
-   * For sensitive apps, it is recommended not having biometric fall back to such factor.
-   * @see: https://developer.android.com/security/fraud-prevention/authentication
-   *
-   * @default false
-   * @platform android
-   * @platform ios
-   */
-  enableDeviceFallback?: boolean;
+    /**
+     * When this flag is set to true, the get methods of SecureStore will return a two-element array. The first value will be the original value returned when this flag is set to false.
+     * The second value is the authentication type used to read the value from the AUTH_TYPE object.
+     * As for the set function, the returned value will simply be AUTH_TYPE.
+     *
+     * @warning
+     * If the iOS device supports biometrics and the user falls back to device credentials, it will not be detected.
+     * This is not the case on Android, but we cannot specify the exact type of biometrics (e.g. fingerprint or face scan).
+     * Whether the type is detected correctly depends on the platform and its native implementation.
+     * This should be treated as more of a hint.
+     *
+     * @default false
+     * @platform android
+     * @platform ios
+     */
+    returnUsedAuthenticationType?: boolean;
 };
 
 // @needsAudit
@@ -124,7 +197,7 @@ export type SecureStoreOptions = {
  * on the current device. Currently, this resolves `true` on Android and iOS only.
  */
 export async function isAvailableAsync(): Promise<boolean> {
-  return !!ExpoSecureStore.getValueWithKeyAsync;
+    return !!ExpoSecureStore.getValueWithKeyAsync;
 }
 
 // @needsAudit
@@ -137,12 +210,12 @@ export async function isAvailableAsync(): Promise<boolean> {
  * @return A promise that rejects if the value can't be deleted.
  */
 export async function deleteItemAsync(
-  key: string,
-  options: SecureStoreOptions = {}
+    key: string,
+    options: SecureStoreOptions = {}
 ): Promise<void> {
-  ensureValidKey(key);
+    ensureValidKey(key);
 
-  await ExpoSecureStore.deleteValueWithKeyAsync(key, options);
+    await ExpoSecureStore.deleteValueWithKeyAsync(key, options);
 }
 
 // @needsAudit
@@ -159,12 +232,12 @@ export async function deleteItemAsync(
  * > After a key has been invalidated, it becomes impossible to read its value.
  * > This only applies to values stored with `requireAuthentication` set to `true`.
  */
-export async function getItemAsync(
-  key: string,
-  options: SecureStoreOptions = {}
-): Promise<string | null> {
-  ensureValidKey(key);
-  return await ExpoSecureStore.getValueWithKeyAsync(key, options);
+export async function getItemAsync<R extends SecureStoreOptions>(
+    key: string,
+    options: R | EmptyObject = {}
+): Promise<SecureStoreGetFeedback<string, R>> {
+    ensureValidKey(key);
+    return await ExpoSecureStore.getValueWithKeyAsync(key, options);
 }
 
 // @needsAudit
@@ -172,24 +245,24 @@ export async function getItemAsync(
  * Stores a key–value pair.
  *
  * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.
- * @param value The value to store. Size limit is 2048 bytes.
+ * @param value The value to store.
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  * @return A promise that rejects if value cannot be stored on the device.
  */
-export async function setItemAsync(
-  key: string,
-  value: string,
-  options: SecureStoreOptions = {}
-): Promise<void> {
-  ensureValidKey(key);
-  if (!isValidValue(value)) {
-    throw new Error(
-      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`
-    );
-  }
+export async function setItemAsync<R extends SecureStoreOptions>(
+    key: string,
+    value: string,
+    options: R | EmptyObject = {}
+): Promise<SecureStoreSetFeedback<R>> {
+    ensureValidKey(key);
+    if (!isValidValue(value)) {
+        throw new Error(
+            `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`
+        );
+    }
 
-  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+    return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }
 
 /**
@@ -197,19 +270,23 @@ export async function setItemAsync(
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.
  *
  * @param key The key to associate with the stored value. Keys may contain alphanumeric characters, `.`, `-`, and `_`.
- * @param value The value to store. Size limit is 2048 bytes.
+ * @param value The value to store.
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {
-  ensureValidKey(key);
-  if (!isValidValue(value)) {
-    throw new Error(
-      `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`
-    );
-  }
+export function setItem<R extends SecureStoreOptions>(
+    key: string,
+    value: string,
+    options: R | EmptyObject = {}
+): SecureStoreSetFeedback<R> {
+    ensureValidKey(key);
+    if (!isValidValue(value)) {
+        throw new Error(
+            `Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`
+        );
+    }
 
-  return ExpoSecureStore.setValueWithKeySync(value, key, options);
+    return ExpoSecureStore.setValueWithKeySync(value, key, options);
 }
 
 /**
@@ -222,9 +299,12 @@ export function setItem(key: string, value: string, options: SecureStoreOptions
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export function getItem(key: string, options: SecureStoreOptions = {}): string | null {
-  ensureValidKey(key);
-  return ExpoSecureStore.getValueWithKeySync(key, options);
+export function getItem<R extends SecureStoreOptions>(
+    key: string,
+    options: R | EmptyObject = {}
+): SecureStoreGetFeedback<string, R> {
+    ensureValidKey(key);
+    return ExpoSecureStore.getValueWithKeySync(key, options);
 }
 
 /**
@@ -234,7 +314,7 @@ export function getItem(key: string, options: SecureStoreOptions = {}): string |
  * @platform ios
  */
 export function canUseBiometricAuthentication(): boolean {
-  return ExpoSecureStore.canUseBiometricAuthentication();
+    return ExpoSecureStore.canUseBiometricAuthentication();
 }
 
 /**
@@ -244,7 +324,7 @@ export function canUseBiometricAuthentication(): boolean {
  * @platform ios
  */
 export function canUseDeviceCredentialsAuthentication(): boolean {
-  return ExpoSecureStore.canUseDeviceCredentialsAuthentication();
+    return ExpoSecureStore.canUseDeviceCredentialsAuthentication();
 }
 
 function ensureValidKey(key: string) {
