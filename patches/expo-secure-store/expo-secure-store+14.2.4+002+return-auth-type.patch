diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
index 4a1a009..980ef0a 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/AuthenticationHelper.kt
@@ -20,12 +20,12 @@ class AuthenticationHelper(
 ) {
   private var isAuthenticating = false

-  suspend fun authenticateCipher(cipher: Cipher, requiresAuthentication: Boolean, title: String, enableDeviceFallback: Boolean): Cipher {
-    if (requiresAuthentication) {
-      return openAuthenticationPrompt(cipher, title, enableDeviceFallback).cryptoObject?.cipher
-        ?: throw AuthenticationException("Couldn't get cipher from authentication result")
+  suspend fun authenticateCipher(cipher: Cipher, title: String, enableDeviceFallback: Boolean): BiometricPrompt.AuthenticationResult {
+    val promptResult = openAuthenticationPrompt(cipher, title, enableDeviceFallback)
+    if (promptResult.cryptoObject?.cipher == null) {
+      throw AuthenticationException("Couldn't get cipher from authentication result")
     }
-    return cipher
+    return promptResult
   }

   private suspend fun openAuthenticationPrompt(
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
index 3f21552..d209efc 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreModule.kt
@@ -36,23 +36,23 @@ open class SecureStoreModule : Module() {

     AsyncFunction("setValueWithKeyAsync") Coroutine { value: String?, key: String?, options: SecureStoreOptions ->
       key ?: throw NullKeyException()
-      return@Coroutine setItemImpl(key, value, options, false)
+      return@Coroutine narrowSecureStoreFeedback(SecureStoreFeedbackAction.SET, setItemImpl(key, value, options, false), options).value
     }

     AsyncFunction("getValueWithKeyAsync") Coroutine { key: String, options: SecureStoreOptions ->
-      return@Coroutine getItemImpl(key, options)
+      return@Coroutine narrowSecureStoreFeedback(SecureStoreFeedbackAction.GET,getItemImpl(key, options), options).value
     }

     Function("setValueWithKeySync") { value: String?, key: String?, options: SecureStoreOptions ->
       key ?: throw NullKeyException()
       return@Function runBlocking {
-        return@runBlocking setItemImpl(key, value, options, keyIsInvalidated = false)
+        return@runBlocking narrowSecureStoreFeedback(SecureStoreFeedbackAction.SET, setItemImpl(key, value, options, keyIsInvalidated = false), options).value
       }
     }

     Function("getValueWithKeySync") { key: String, options: SecureStoreOptions ->
       return@Function runBlocking {
-        return@runBlocking getItemImpl(key, options)
+        return@runBlocking narrowSecureStoreFeedback(SecureStoreFeedbackAction.GET, getItemImpl(key, options), options).value
       }
     }

@@ -94,7 +94,23 @@ open class SecureStoreModule : Module() {
     }
   }

-  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): String? {
+  private suspend fun <T> narrowSecureStoreFeedback(action: String, feedback: SecureStoreOriginalFeedback<T>, options: SecureStoreOptions): SecureStoreNarrowedFeedback<T> {
+    if (!options.returnUsedAuthenticationType) {
+      return feedback
+    }
+
+    if (action == SecureStoreFeedbackAction.GET) {
+      return SecureStoreGetFeedback(feedback.source, feedback.authenticationResult)
+    }
+
+    if (action == SecureStoreFeedbackAction.SET) {
+      return SecureStoreSetFeedback(feedback.source, feedback.authenticationResult)
+    }
+
+    return feedback
+  }
+
+  private suspend fun getItemImpl(key: String, options: SecureStoreOptions): SecureStoreOriginalFeedback<out String?> {
     // We use a SecureStore-specific shared preferences file, which lets us do things like enumerate
     // its entries or clear all of them
     val prefs: SharedPreferences = getSharedPreferences()
@@ -104,10 +120,10 @@ open class SecureStoreModule : Module() {
     } else if (prefs.contains(key)) { // For backwards-compatibility try to read using the old key format
       return readJSONEncodedItem(key, prefs, options)
     }
-    return null
+    return SecureStoreOriginalFeedback(null)
   }

-  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): String? {
+  private suspend fun readJSONEncodedItem(key: String, prefs: SharedPreferences, options: SecureStoreOptions): SecureStoreOriginalFeedback<out String?> {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)

     val legacyEncryptedItemString = prefs.getString(key, null)
@@ -126,7 +142,7 @@ open class SecureStoreModule : Module() {
       ""
     }

-    encryptedItemString ?: return null
+    encryptedItemString ?: return SecureStoreOriginalFeedback(null)

     val encryptedItem: JSONObject = try {
       JSONObject(encryptedItemString)
@@ -149,13 +165,13 @@ open class SecureStoreModule : Module() {
                 "This situation occurs when the app is reinstalled. The value will be removed to avoid future errors. Returning null"
             )
             deleteItemImpl(key, options)
-            return null
+            return SecureStoreOriginalFeedback(null)
           }
           return mAESEncryptor.decryptItem(key, encryptedItem, secretKeyEntry, options, authenticationHelper)
         }
         HybridAESEncryptor.NAME -> {
           val privateKeyEntry = getKeyEntryCompat(PrivateKeyEntry::class.java, hybridAESEncryptor, options, requireAuthentication, usesKeystoreSuffix)
-            ?: return null
+            ?: return SecureStoreOriginalFeedback(null)
           return hybridAESEncryptor.decryptItem(key, encryptedItem, privateKeyEntry, options, authenticationHelper)
         }
         else -> {
@@ -164,7 +180,7 @@ open class SecureStoreModule : Module() {
       }
     } catch (e: KeyPermanentlyInvalidatedException) {
       Log.w(TAG, "The requested key has been permanently invalidated. Returning null")
-      return null
+      return SecureStoreOriginalFeedback(null)
     } catch (e: BadPaddingException) {
       // The key from the KeyStore is unable to decode the entry. This is because a new key was generated, but the entries are encrypted using the old one.
       // This usually means that the user has reinstalled the app. We can safely remove the old value and return null as it's impossible to decrypt it.
@@ -174,7 +190,7 @@ open class SecureStoreModule : Module() {
           "The entry in shared preferences is out of sync with the keystore. It will be removed, returning null."
       )
       deleteItemImpl(key, options)
-      return null
+      return SecureStoreOriginalFeedback(null)
     } catch (e: GeneralSecurityException) {
       throw (DecryptException(e.message, key, options.keychainService, e))
     } catch (e: CodedException) {
@@ -184,7 +200,7 @@ open class SecureStoreModule : Module() {
     }
   }

-  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean) {
+  private suspend fun setItemImpl(key: String, value: String?, options: SecureStoreOptions, keyIsInvalidated: Boolean): SecureStoreOriginalFeedback<out JSONObject?> {
     val keychainAwareKey = createKeychainAwareKey(key, options.keychainService)
     val prefs: SharedPreferences = getSharedPreferences()

@@ -193,7 +209,7 @@ open class SecureStoreModule : Module() {
       if (!success) {
         throw WriteException("Could not write a null value to SecureStore", key, options.keychainService)
       }
-      return
+      return SecureStoreOriginalFeedback(null)
     }

     try {
@@ -210,7 +226,8 @@ open class SecureStoreModule : Module() {
        back a value.
        */
       val secretKeyEntry: SecretKeyEntry = getOrCreateKeyEntry(SecretKeyEntry::class.java, mAESEncryptor, options, options.requireAuthentication)
-      val encryptedItem = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper, options.enableDeviceFallback)
+      val encryptResult = mAESEncryptor.createEncryptedItem(value, secretKeyEntry, options.requireAuthentication, options.authenticationPrompt, authenticationHelper, options.enableDeviceFallback)
+      val encryptedItem = encryptResult.value
       encryptedItem.put(SCHEME_PROPERTY, AESEncryptor.NAME)
       saveEncryptedItem(encryptedItem, prefs, keychainAwareKey, options.requireAuthentication, options.keychainService)

@@ -218,6 +235,9 @@ open class SecureStoreModule : Module() {
       if (prefs.contains(key)) {
         prefs.edit().remove(key).apply()
       }
+
+      return encryptResult
+
     } catch (e: KeyPermanentlyInvalidatedException) {
       if (!keyIsInvalidated) {
         Log.w(TAG, "Key has been invalidated, retrying with the key deleted")
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
index 0455fd6..4e30440 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/SecureStoreOptions.kt
@@ -1,5 +1,6 @@
 package expo.modules.securestore

+import androidx.biometric.BiometricPrompt
 import expo.modules.kotlin.records.Field
 import expo.modules.kotlin.records.Record
 import java.io.Serializable
@@ -9,5 +10,58 @@ class SecureStoreOptions(
   @Field var authenticationPrompt: String = " ",
   @Field var keychainService: String = SecureStoreModule.DEFAULT_KEYSTORE_ALIAS,
   @Field var requireAuthentication: Boolean = false,
-  @Field var enableDeviceFallback: Boolean = false
+  @Field var enableDeviceFallback: Boolean = false,
+  @Field var returnUsedAuthenticationType: Boolean = false
 ) : Record, Serializable
+
+enum class SecureStoreAuthType(index: Int) {
+  UNKNOWN(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_UNKNOWN),
+  CREDENTIAL(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_DEVICE_CREDENTIAL),
+  BIOMETRIC(BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC),
+
+  /** Prompt failed, no authentication was used at all */
+  NONE(0)
+}
+
+open class SecureStoreFeedbackAction {
+  companion object {
+    const val GET = "GET"
+    const val SET = "SET"
+  }
+}
+
+abstract class SecureStoreFeedback<T, R>(
+  val source: T,
+  val authenticationResult: BiometricPrompt.AuthenticationResult?
+) {
+  @Field var authType: SecureStoreAuthType = when (authenticationResult?.authenticationType) {
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_UNKNOWN -> {
+      SecureStoreAuthType.UNKNOWN
+    }
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_DEVICE_CREDENTIAL -> {
+      SecureStoreAuthType.CREDENTIAL
+    }
+    BiometricPrompt.AUTHENTICATION_RESULT_TYPE_BIOMETRIC -> {
+      SecureStoreAuthType.BIOMETRIC
+    }
+    else -> {
+      SecureStoreAuthType.NONE
+    }
+  }
+  abstract val value: R
+}
+
+class SecureStoreGetFeedback<T>(source: T, authenticationResult: BiometricPrompt.AuthenticationResult? = null): SecureStoreFeedback<T, Pair<T, Int>>(source, authenticationResult) {
+  /** Used to return easily convertible values to JS code */
+  @Field override var value: Pair<T, Int> = Pair(source, authType.ordinal)
+}
+
+class SecureStoreSetFeedback<T>(source: T, authenticationResult: BiometricPrompt.AuthenticationResult? = null): SecureStoreFeedback<T, Int>(source, authenticationResult) {
+  @Field override var value: Int = authType.ordinal
+}
+
+class SecureStoreOriginalFeedback<T>(source: T, authenticationResult: BiometricPrompt.AuthenticationResult? = null): SecureStoreFeedback<T, T>(source, authenticationResult) {
+  @Field override var value: T = source
+}
+
+typealias SecureStoreNarrowedFeedback<T> = SecureStoreFeedback<T, out Any?>
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
index 1cd187f..d927ff1 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/AESEncryptor.kt
@@ -5,10 +5,12 @@ import android.security.keystore.KeyGenParameterSpec
 import android.security.keystore.KeyProperties
 import android.util.Base64
 import androidx.annotation.RequiresApi
+import androidx.biometric.BiometricPrompt
 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.DecryptException
 import expo.modules.securestore.SecureStoreModule
 import expo.modules.securestore.SecureStoreOptions
+import expo.modules.securestore.SecureStoreOriginalFeedback
 import org.json.JSONException
 import org.json.JSONObject
 import java.nio.charset.StandardCharsets
@@ -86,15 +88,23 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject {
+  ): SecureStoreOriginalFeedback<JSONObject> {
     val secretKey = keyStoreEntry.secretKey
     val cipher = Cipher.getInstance(AES_CIPHER)
     cipher.init(Cipher.ENCRYPT_MODE, secretKey)

     val gcmSpec = cipher.parameters.getParameterSpec(GCMParameterSpec::class.java)
-    val authenticatedCipher = authenticationHelper.authenticateCipher(cipher, requireAuthentication, authenticationPrompt, enableDeviceFallback)
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val authenticatedCipher: Cipher
+
+    if (requireAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(cipher, authenticationPrompt, enableDeviceFallback)
+      authenticatedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      authenticatedCipher = cipher
+    }

-    return createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec)
+    return SecureStoreOriginalFeedback(createEncryptedItemWithCipher(plaintextValue, authenticatedCipher, gcmSpec), promptResult)
   }

   internal fun createEncryptedItemWithCipher(
@@ -121,7 +131,7 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
     keyStoreEntry: KeyStore.SecretKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): SecureStoreOriginalFeedback<String> {
     val ciphertext = encryptedItem.getString(CIPHERTEXT_PROPERTY)
     val ivString = encryptedItem.getString(IV_PROPERTY)
     val authenticationTagLength = encryptedItem.getInt(GCM_AUTHENTICATION_TAG_LENGTH_PROPERTY)
@@ -135,8 +145,17 @@ class AESEncryptor : KeyBasedEncryptor<KeyStore.SecretKeyEntry> {
       throw DecryptException("Authentication tag length must be at least $MIN_GCM_AUTHENTICATION_TAG_LENGTH bits long", key, options.keychainService)
     }
     cipher.init(Cipher.DECRYPT_MODE, keyStoreEntry.secretKey, gcmSpec)
-    val unlockedCipher = authenticationHelper.authenticateCipher(cipher, requiresAuthentication, options.authenticationPrompt, options.enableDeviceFallback)
-    return String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8)
+    var promptResult: BiometricPrompt.AuthenticationResult? = null
+    val unlockedCipher: Cipher
+
+    if (requiresAuthentication) {
+      promptResult = authenticationHelper.authenticateCipher(cipher, options.authenticationPrompt, options.enableDeviceFallback)
+      unlockedCipher = promptResult.cryptoObject?.cipher ?: cipher
+    } else {
+      unlockedCipher = cipher
+    }
+
+    return SecureStoreOriginalFeedback(String(unlockedCipher.doFinal(ciphertextBytes), StandardCharsets.UTF_8), promptResult)
   }

   companion object {
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
index 5f8bbfd..7527001 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/HybridAESEncryptor.kt
@@ -9,6 +9,7 @@ import expo.modules.securestore.EncryptException
 import expo.modules.securestore.KeyStoreException
 import expo.modules.securestore.SecureStoreModule
 import expo.modules.securestore.SecureStoreOptions
+import expo.modules.securestore.SecureStoreOriginalFeedback
 import org.json.JSONException
 import org.json.JSONObject
 import java.security.GeneralSecurityException
@@ -71,7 +72,7 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject {
+  ): SecureStoreOriginalFeedback<JSONObject> {
     // This should never be called after we dropped Android SDK 22 support.
     throw EncryptException(
       "HybridAESEncryption should not be used on Android SDK >= 23. This shouldn't happen. " +
@@ -88,7 +89,7 @@ class HybridAESEncryptor(private var mContext: Context, private val mAESEncrypto
     keyStoreEntry: KeyStore.PrivateKeyEntry,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String {
+  ): SecureStoreOriginalFeedback<String> {
     // Decrypt the encrypted symmetric key
     val encryptedSecretKeyString = encryptedItem.getString(ENCRYPTED_SECRET_KEY_PROPERTY)
     val encryptedSecretKeyBytes = Base64.decode(encryptedSecretKeyString, Base64.DEFAULT)
diff --git a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
index 39459ff..a531aff 100644
--- a/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
+++ b/node_modules/expo-secure-store/android/src/main/java/expo/modules/securestore/encryptors/KeyBasedEncryptor.kt
@@ -2,6 +2,7 @@ package expo.modules.securestore.encryptors

 import expo.modules.securestore.AuthenticationHelper
 import expo.modules.securestore.SecureStoreOptions
+import expo.modules.securestore.SecureStoreOriginalFeedback
 import org.json.JSONException
 import org.json.JSONObject
 import java.security.GeneralSecurityException
@@ -27,7 +28,7 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     authenticationPrompt: String,
     authenticationHelper: AuthenticationHelper,
     enableDeviceFallback: Boolean,
-  ): JSONObject
+  ): SecureStoreOriginalFeedback<JSONObject>

   @Throws(GeneralSecurityException::class, JSONException::class)
   suspend fun decryptItem(
@@ -36,5 +37,5 @@ interface KeyBasedEncryptor<E : KeyStore.Entry> {
     keyStoreEntry: E,
     options: SecureStoreOptions,
     authenticationHelper: AuthenticationHelper
-  ): String
+  ): SecureStoreOriginalFeedback<String>
 }
diff --git a/node_modules/expo-secure-store/build/SecureStore.d.ts b/node_modules/expo-secure-store/build/SecureStore.d.ts
index 835a4d4..d2da8d9 100644
--- a/node_modules/expo-secure-store/build/SecureStore.d.ts
+++ b/node_modules/expo-secure-store/build/SecureStore.d.ts
@@ -1,4 +1,53 @@
+type EmptyObject = Record<string, never>;
+type SecureStoreSetFeedback<R extends SecureStoreOptions> = R['returnUsedAuthenticationType'] extends true ? AuthType : void;
+type SecureStoreGetFeedback<T, R extends SecureStoreOptions> = R['returnUsedAuthenticationType'] extends true ? [T | null, AuthType] : T | null;
 export type KeychainAccessibilityConstant = number;
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export declare const AUTH_TYPE: {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    readonly UNKNOWN: -1;
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    readonly NONE: 0;
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    readonly CREDENTIALS: 1;
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    readonly BIOMETRICS: 2;
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    readonly FACE_ID: 3;
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    readonly TOUCH_ID: 4;
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    readonly OPTIC_ID: 5;
+};
+type AuthType = (typeof AUTH_TYPE)[keyof typeof AUTH_TYPE];
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -88,6 +137,22 @@ export type SecureStoreOptions = {
      * @platform ios
      */
     enableDeviceFallback?: boolean;
+    /**
+     * When this flag is set to true, the get methods of SecureStore will return a two-element array. The first value will be the original value returned when this flag is set to false.
+     * The second value is the authentication type used to read the value from the AUTH_TYPE object.
+     * As for the set function, the returned value will simply be AUTH_TYPE.
+     *
+     * @warning
+     * If the iOS device supports biometrics and the user falls back to device credentials, it will not be detected.
+     * This is not the case on Android, but we cannot specify the exact type of biometrics (e.g. fingerprint or face scan).
+     * Whether the type is detected correctly depends on the platform and its native implementation.
+     * This should be treated as more of a hint.
+     *
+     * @default false
+     * @platform android
+     * @platform ios
+     */
+    returnUsedAuthenticationType?: boolean;
 };
 /**
  * Returns whether the SecureStore API is enabled on the current device. This does not check the app
@@ -119,7 +184,7 @@ export declare function deleteItemAsync(key: string, options?: SecureStoreOption
  * > After a key has been invalidated, it becomes impossible to read its value.
  * > This only applies to values stored with `requireAuthentication` set to `true`.
  */
-export declare function getItemAsync(key: string, options?: SecureStoreOptions): Promise<string | null>;
+export declare function getItemAsync<R extends SecureStoreOptions>(key: string, options?: R | EmptyObject): Promise<SecureStoreGetFeedback<string, R>>;
 /**
  * Stores a key–value pair.
  *
@@ -129,7 +194,7 @@ export declare function getItemAsync(key: string, options?: SecureStoreOptions):
  *
  * @return A promise that rejects if value cannot be stored on the device.
  */
-export declare function setItemAsync(key: string, value: string, options?: SecureStoreOptions): Promise<void>;
+export declare function setItemAsync<R extends SecureStoreOptions>(key: string, value: string, options?: R | EmptyObject): Promise<SecureStoreSetFeedback<R>>;
 /**
  * Stores a key–value pair synchronously.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when the `requireAuthentication` option is set to `true` until the user authenticates.
@@ -139,7 +204,7 @@ export declare function setItemAsync(key: string, value: string, options?: Secur
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export declare function setItem(key: string, value: string, options?: SecureStoreOptions): void;
+export declare function setItem<R extends SecureStoreOptions>(key: string, value: string, options?: R | EmptyObject): SecureStoreSetFeedback<R>;
 /**
  * Synchronously reads the stored value associated with the provided key.
  * > **Note:** This function blocks the JavaScript thread, so the application may not be interactive when reading a value with `requireAuthentication`
@@ -150,7 +215,7 @@ export declare function setItem(key: string, value: string, options?: SecureStor
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export declare function getItem(key: string, options?: SecureStoreOptions): string | null;
+export declare function getItem<R extends SecureStoreOptions>(key: string, options?: R | EmptyObject): SecureStoreGetFeedback<string, R>;
 /**
  * Checks if the value can be saved with `requireAuthentication` option enabled.
  * @return `true` if the device supports biometric authentication and the enrolled method is sufficiently secure. Otherwise, returns `false`. Always returns false on tvOS.
diff --git a/node_modules/expo-secure-store/build/SecureStore.js b/node_modules/expo-secure-store/build/SecureStore.js
index e11bd94..940fc61 100644
--- a/node_modules/expo-secure-store/build/SecureStore.js
+++ b/node_modules/expo-secure-store/build/SecureStore.js
@@ -1,6 +1,53 @@
 import ExpoSecureStore from './ExpoSecureStore';
 import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';
 // @needsAudit
+
+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    UNKNOWN: -1,
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    NONE: 0,
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    CREDENTIALS: 1,
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    BIOMETRICS: 2,
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    FACE_ID: 3,
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    TOUCH_ID: 4,
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    OPTIC_ID: 5,
+};
+// @needsAudit
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
  * unlocked once by the user. This may be useful if you need to access the item when the phone
@@ -102,7 +149,7 @@ export async function setItemAsync(key, value, options = {}) {
     if (!isValidValue(value)) {
         throw new Error(`Invalid value provided to SecureStore. Values must be strings; consider JSON-encoding your values if they are serializable.`);
     }
-    await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+    return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }
 /**
  * Stores a key–value pair synchronously.
diff --git a/node_modules/expo-secure-store/ios/SecureStoreModule.swift b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
index 1268979..7764c8e 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreModule.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreModule.swift
@@ -18,28 +18,36 @@ public final class SecureStoreModule: Module {
       "WHEN_UNLOCKED_THIS_DEVICE_ONLY": SecureStoreAccessible.whenUnlockedThisDeviceOnly.rawValue
     ])

-    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    AsyncFunction("getValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
+      let result = try get(with: key, options: options)
+
+      return wrapResultWithFeedback(action: .get, result: result, options: options).value
     }

-    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) -> String? in
-      return try get(with: key, options: options)
+    Function("getValueWithKeySync") { (key: String, options: SecureStoreOptions) in
+      let result = try get(with: key, options: options)
+
+      return wrapResultWithFeedback(action: .get, result: result, options: options).value
     }

-    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) -> Bool in
+    AsyncFunction("setValueWithKeyAsync") { (value: String, key: String, options: SecureStoreOptions) in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }

-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+
+      return wrapResultWithFeedback(action: .set, result: result, options: options).value
     }

-    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) -> Bool in
+    Function("setValueWithKeySync") {(value: String, key: String, options: SecureStoreOptions) in
       guard let key = validate(for: key) else {
         throw InvalidKeyException()
       }

-      return try set(value: value, with: key, options: options)
+      let result = try set(value: value, with: key, options: options)
+
+      return wrapResultWithFeedback(action: .set, result: result, options: options).value
     }

     AsyncFunction("deleteValueWithKeyAsync") { (key: String, options: SecureStoreOptions) in
@@ -53,18 +61,7 @@ public final class SecureStoreModule: Module {
     }

     Function("canUseBiometricAuthentication") {() -> Bool in
-      #if os(tvOS)
-      return false
-      #else
-      let context = LAContext()
-      var error: NSError?
-      let isBiometricsSupported: Bool = context.canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: &error)
-
-      if error != nil {
-        return false
-      }
-      return isBiometricsSupported
-      #endif
+      return areBiometricsEnabled()
     }

     Function("canUseDeviceCredentialsAuthentication") { () -> Bool in
@@ -76,6 +73,41 @@ public final class SecureStoreModule: Module {
     return LAContext().canEvaluatePolicy(LAPolicy.deviceOwnerAuthentication, error: nil)
   }

+  private func getAuthType() -> AuthType {
+    if !areBiometricsEnabled() {return AuthType.credentials}
+    let biometryType = LAContext().biometryType
+
+    switch biometryType {
+      case .faceID: return .faceID
+      case .touchID: return .touchID
+      case .opticID: return .opticID // available since iOS 17
+      case .none: fallthrough // this one continues to the next line
+      @unknown default: return .credentials
+    }
+  }
+
+  private func wrapResultWithFeedback<T>(action: SecureStoreFeedbackAction, result: T, options: SecureStoreOptions) -> any SecureStoreFeedback {
+    let authType = getAuthType().rawValue
+
+    if (!options.returnUsedAuthenticationType) {
+      return SecureStoreOriginalFeedback(source: result, authType: authType)
+    }
+
+    if (action == .get) {
+      return SecureStoreGetFeedback(source: result, authType: authType)
+    }
+
+    return SecureStoreSetFeedback(source: result, authType: authType)
+  }
+
+  private func areBiometricsEnabled() -> Bool {
+    #if os(tvOS)
+      return false
+    #else
+      return LAContext().canEvaluatePolicy(LAPolicy.deviceOwnerAuthenticationWithBiometrics, error: nil)
+    #endif
+  }
+
   private func get(with key: String, options: SecureStoreOptions) throws -> String? {
     guard let key = validate(for: key) else {
       throw InvalidKeyException()
diff --git a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
index c9e843b..b95eca7 100644
--- a/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
+++ b/node_modules/expo-secure-store/ios/SecureStoreOptions.swift
@@ -18,4 +18,71 @@ internal struct SecureStoreOptions: Record {

   @Field
   var enableDeviceFallback: Bool = false
+
+  @Field
+  var returnUsedAuthenticationType: Bool = false
+}
+
+@available(iOS 11.2, *)
+public enum AuthType: Int, @unchecked Sendable {
+  /// The device does not support biometry.
+  case none = 0
+
+  /// The device supports device credentials
+  case credentials = 1
+
+  /// Generic type, not specified whether it was a faceID or touchID
+  case biometrics = 2
+
+  /// The device supports Face ID.
+  case faceID = 3
+
+  /// The device supports Touch ID.
+  case touchID = 4
+
+  /// The device supports Optic ID
+  case opticID = 5
+}
+
+public enum SecureStoreFeedbackAction: String {
+  case set
+  case get
+}
+
+protocol SecureStoreFeedback {
+  associatedtype Source
+  associatedtype Value
+  var source: Source { get }
+  var authType: Int { get }
+  var value: Value { get }
+}
+
+struct SecureStoreGetFeedback<T>: SecureStoreFeedback {
+  typealias Source = T
+  typealias Value = Array<Any>
+  var source: Source
+  var authType: Int = AuthType.none.rawValue
+  var value: Value {
+    get { return [source, authType] }
+  }
+}
+
+struct SecureStoreOriginalFeedback<T>: SecureStoreFeedback {
+  typealias Source = T
+  typealias Value = T
+  var source: Source
+  var authType: Int = AuthType.none.rawValue
+  var value: Value {
+    get { return source }
+  }
+}
+
+struct SecureStoreSetFeedback<T>: SecureStoreFeedback {
+  typealias Source = T
+  typealias Value = Int
+  var source: Source
+  var authType: Int = AuthType.none.rawValue
+  var value: Value {
+    get { return authType }
+  }
 }
diff --git a/node_modules/expo-secure-store/src/SecureStore.ts b/node_modules/expo-secure-store/src/SecureStore.ts
index 4f253a1..d44c0bb 100644
--- a/node_modules/expo-secure-store/src/SecureStore.ts
+++ b/node_modules/expo-secure-store/src/SecureStore.ts
@@ -1,8 +1,63 @@
 import ExpoSecureStore from './ExpoSecureStore';
 import { byteCountOverLimit, VALUE_BYTES_LIMIT } from './byteCounter';

+type EmptyObject = Record<string, never>;
+type SecureStoreSetFeedback<R extends SecureStoreOptions> =
+    R['returnUsedAuthenticationType'] extends true ? AuthType : void;
+type SecureStoreGetFeedback<
+    T,
+    R extends SecureStoreOptions,
+> = R['returnUsedAuthenticationType'] extends true ? [T | null, AuthType] : T | null;
 export type KeychainAccessibilityConstant = number;

+/**
+ * Authentication type returned by the SecureStore after reading item or saving it to the store.
+ */
+export const AUTH_TYPE = {
+    /**
+     * This is purely for backwards compatibility.
+     * Although it is not listed as a return value of the getAuthenticationType() method,
+     * it is still present in the Android code.
+     * @see https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt.AuthenticationResult#getAuthenticationType()
+     * @see https://developer.android.com/reference/androidx/biometric/BiometricPrompt#AUTHENTICATION_RESULT_TYPE_UNKNOWN()
+     * @platform android
+     */
+    UNKNOWN: -1,
+    /**
+     * Returned when the authentication fails
+     * @platform android
+     * @platform ios
+     */
+    NONE: 0,
+    /**
+     * Generic type, not specified whether it was a passcode or pattern.
+     * @platform android
+     * @platform ios
+     */
+    CREDENTIALS: 1,
+    /**
+     * Generic type, not specified whether it was a face scan or a fingerprint
+     * @platform android
+     */
+    BIOMETRICS: 2,
+    /**
+     * FaceID was used to authenticate
+     * @platform ios
+     */
+    FACE_ID: 3,
+    /**
+     * TouchID was used to authenticate
+     * @platform ios
+     */
+    TOUCH_ID: 4,
+    /**
+     * OpticID was used to authenticate (reserved by apple, used on Apple Vision Pro, not iOS)
+     */
+    OPTIC_ID: 5,
+} as const;
+
+type AuthType = (typeof AUTH_TYPE)[keyof typeof AUTH_TYPE];
+
 // @needsAudit
 /**
  * The data in the keychain item cannot be accessed after a restart until the device has been
@@ -113,6 +168,23 @@ export type SecureStoreOptions = {
    * @platform ios
    */
   enableDeviceFallback?: boolean;
+
+  /**
+   * When this flag is set to true, the get methods of SecureStore will return a two-element array. The first value will be the original value returned when this flag is set to false.
+   * The second value is the authentication type used to read the value from the AUTH_TYPE object.
+   * As for the set function, the returned value will simply be AUTH_TYPE.
+   *
+   * @warning
+   * If the iOS device supports biometrics and the user falls back to device credentials, it will not be detected.
+   * This is not the case on Android, but we cannot specify the exact type of biometrics (e.g. fingerprint or face scan).
+   * Whether the type is detected correctly depends on the platform and its native implementation.
+   * This should be treated as more of a hint.
+   *
+   * @default false
+   * @platform android
+   * @platform ios
+   */
+  returnUsedAuthenticationType?: boolean;
 };

 // @needsAudit
@@ -159,10 +231,10 @@ export async function deleteItemAsync(
  * > After a key has been invalidated, it becomes impossible to read its value.
  * > This only applies to values stored with `requireAuthentication` set to `true`.
  */
-export async function getItemAsync(
+export async function getItemAsync<R extends SecureStoreOptions>(
   key: string,
-  options: SecureStoreOptions = {}
-): Promise<string | null> {
+  options: R | EmptyObject = {}
+): Promise<SecureStoreGetFeedback<string, R>> {
   ensureValidKey(key);
   return await ExpoSecureStore.getValueWithKeyAsync(key, options);
 }
@@ -177,11 +249,11 @@ export async function getItemAsync(
  *
  * @return A promise that rejects if value cannot be stored on the device.
  */
-export async function setItemAsync(
+export async function setItemAsync<R extends SecureStoreOptions>(
   key: string,
   value: string,
-  options: SecureStoreOptions = {}
-): Promise<void> {
+  options: R | EmptyObject = {}
+): Promise<SecureStoreSetFeedback<R>> {
   ensureValidKey(key);
   if (!isValidValue(value)) {
     throw new Error(
@@ -189,7 +261,7 @@ export async function setItemAsync(
     );
   }

-  await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
+  return await ExpoSecureStore.setValueWithKeyAsync(value, key, options);
 }

 /**
@@ -201,7 +273,11 @@ export async function setItemAsync(
  * @param options An [`SecureStoreOptions`](#securestoreoptions) object.
  *
  */
-export function setItem(key: string, value: string, options: SecureStoreOptions = {}): void {
+export function setItem<R extends SecureStoreOptions>(
+  key: string,
+  value: string,
+  options: R | EmptyObject = {}
+): SecureStoreSetFeedback<R> {
   ensureValidKey(key);
   if (!isValidValue(value)) {
     throw new Error(
@@ -222,7 +298,10 @@ export function setItem(key: string, value: string, options: SecureStoreOptions
  * @return Previously stored value. It resolves with `null` if there is no entry
  * for the given key or if the key has been invalidated.
  */
-export function getItem(key: string, options: SecureStoreOptions = {}): string | null {
+export function getItem<R extends SecureStoreOptions>(
+  key: string,
+  options: R | EmptyObject = {}
+): SecureStoreGetFeedback<string, R> {
   ensureValidKey(key);
   return ExpoSecureStore.getValueWithKeySync(key, options);
 }
