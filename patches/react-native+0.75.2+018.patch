diff --git a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm
index db7cba4..1b54a43 100644
--- a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm
+++ b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm
@@ -479,8 +479,7 @@ - (void)setTextAndSelection:(NSInteger)eventCount
   if (value && ![value isEqualToString:_backedTextInputView.attributedText.string]) {
     NSAttributedString *attributedString =
         [[NSAttributedString alloc] initWithString:value attributes:_backedTextInputView.defaultTextAttributes];
-    [self _setAttributedString:attributedString];
-    [self _updateState];
+    [self _updateStateWithString:attributedString];
   }
 
   UITextPosition *startPosition = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument
@@ -490,6 +489,7 @@ - (void)setTextAndSelection:(NSInteger)eventCount
 
   if (startPosition && endPosition) {
     UITextRange *range = [_backedTextInputView textRangeFromPosition:startPosition toPosition:endPosition];
+    // _updateStateWithString executes any state updates sync, so its safe to update the selection as the attributedString is already updated!
     [_backedTextInputView setSelectedTextRange:range notifyDelegate:NO];
   }
   _comingFromJS = NO;
@@ -611,17 +611,27 @@ - (void)handleInputAccessoryDoneButton
 }
 
 - (void)_updateState
+{
+    NSAttributedString *attributedString = _backedTextInputView.attributedText;
+    [self _updateStateWithString:attributedString];
+}
+
+- (void)_updateStateWithString:(NSAttributedString*)attributedString
 {
   if (!_state) {
     return;
   }
-  NSAttributedString *attributedString = _backedTextInputView.attributedText;
   auto data = _state->getData();
   _lastStringStateWasUpdatedWith = attributedString;
   data.attributedStringBox = RCTAttributedStringBoxFromNSAttributedString(attributedString);
   _mostRecentEventCount += _comingFromJS ? 0 : 1;
   data.mostRecentEventCount = _mostRecentEventCount;
-  _state->updateState(std::move(data));
+  const auto &textInputEventEmitter = static_cast<const TextInputEventEmitter &>(*_eventEmitter);
+  // When the textInputDidChange gets called, the text is already updated
+  // in the UI. We execute the state update synchronously so that the layout gets calculated immediately.
+  textInputEventEmitter.experimental_flushSync([state = _state, data = std::move(data)]() mutable {
+    state->updateState(std::move(data));
+  });
 }
