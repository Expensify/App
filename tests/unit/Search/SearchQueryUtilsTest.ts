/* eslint-disable @typescript-eslint/naming-convention */
// we need "dirty" object key names in these tests
import type {OnyxCollection} from 'react-native-onyx';
import {generatePolicyID} from '@libs/actions/Policy/Policy';
// eslint-disable-next-line no-restricted-syntax
import type * as PersonalDetailsUtils from '@libs/PersonalDetailsUtils';
import CONST from '@src/CONST';
import {
    buildFilterFormValuesFromQuery,
    buildQueryStringFromFilterFormValues,
    buildSearchQueryJSON,
    buildSearchQueryString,
    buildUserReadableQueryString,
    getFilterDisplayValue,
    getQueryWithUpdatedValues,
    shouldHighlight,
    sortOptionsWithEmptyValue,
} from '@src/libs/SearchQueryUtils';
import ONYXKEYS from '@src/ONYXKEYS';
import type {SearchAdvancedFiltersForm} from '@src/types/form';
import type * as OnyxTypes from '@src/types/onyx';
import {localeCompare} from '../../utils/TestHelper';

const personalDetailsFakeData = {
    'johndoe@example.com': {
        accountID: 12345,
    },
    'janedoe@example.com': {
        accountID: 78901,
    },
} as Record<string, {accountID: number}>;

jest.mock('@libs/PersonalDetailsUtils', () => {
    const actual = jest.requireActual<typeof PersonalDetailsUtils>('@libs/PersonalDetailsUtils');
    return {
        ...actual,
        getPersonalDetailByEmail(email: string) {
            return personalDetailsFakeData[email];
        },
    };
});

// The default query is generated by default values from parser, which are defined in grammar.
// We don't want to test or mock the grammar and the parser, so we're simply defining this string directly here.
// Note: view:table is not included because it's only added when explicitly set by the user.
const defaultQuery = `type:expense sortBy:date sortOrder:desc`;

describe('SearchQueryUtils', () => {
    describe('getQueryWithUpdatedValues', () => {
        test('returns default query for empty value', () => {
            const userQuery = '';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(defaultQuery);
        });

        test('returns query with updated amounts', () => {
            const userQuery = 'foo test amount:20000';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} amount:2000000 foo test`);
        });

        test('returns query with user emails substituted', () => {
            const userQuery = 'from:johndoe@example.com hello';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} from:12345 hello`);
        });

        test('returns query with user emails substituted and preserves user ids', () => {
            const userQuery = 'from:johndoe@example.com to:112233';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} from:12345 to:112233`);
        });

        test('returns query with all of the fields correctly substituted', () => {
            const userQuery = 'from:9876,87654 to:janedoe@example.com hello amount:150 test';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} from:9876,87654 to:78901 amount:15000 hello test`);
        });

        test('returns query with updated groupBy', () => {
            const userQuery = 'from:johndoe@example.com groupBy:reports';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} groupBy:reports from:12345`);
        });

        test('returns query with updated view', () => {
            const userQuery = 'from:johndoe@example.com view:bar';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} view:bar from:12345`);
        });

        test('returns query with view:line', () => {
            const userQuery = 'type:expense view:line category:travel';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} view:line category:travel`);
        });

        test('returns query with view:pie', () => {
            const userQuery = 'type:expense view:pie merchant:Amazon';

            const result = getQueryWithUpdatedValues(userQuery);

            expect(result).toEqual(`${defaultQuery} view:pie merchant:Amazon`);
        });

        test('deduplicates conflicting type filters keeping the last occurrence', () => {
            const userQuery = 'type:expense-report action:submit from:me type:expense';

            const result = getQueryWithUpdatedValues(userQuery);
            expect(result).toEqual(`${defaultQuery} action:submit from:me`);

            const queryJSON = buildSearchQueryJSON(result ?? '', userQuery);
            expect(queryJSON?.rawFilterList).toEqual([
                {key: CONST.SEARCH.SYNTAX_FILTER_KEYS.ACTION, operator: CONST.SEARCH.SYNTAX_OPERATORS.EQUAL_TO, value: 'submit', isDefault: false},
                {key: CONST.SEARCH.SYNTAX_FILTER_KEYS.FROM, operator: CONST.SEARCH.SYNTAX_OPERATORS.EQUAL_TO, value: 'me', isDefault: false},
                {key: CONST.SEARCH.SYNTAX_FILTER_KEYS.TYPE, operator: CONST.SEARCH.SYNTAX_OPERATORS.EQUAL_TO, value: CONST.SEARCH.DATA_TYPES.EXPENSE, isDefault: true},
            ]);
        });
    });

    describe('buildQueryStringFromFilterFormValues', () => {
        test('simple filter value', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                policyID: ['12345'],
                amountLessThan: '100',
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense policyID:12345 amount<100');
        });

        test('with Policy ID', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                policyID: ['12345'],
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc policyID:12345');
        });

        test('with keywords', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                policyID: ['67890'],
                merchant: 'Amazon',
                description: 'Electronics',
                keyword: 'laptop',
                category: ['electronics', 'gadgets'],
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense policyID:67890 merchant:Amazon description:Electronics laptop category:electronics,gadgets');
        });

        test('currencies and categories', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                category: ['services', 'consulting'],
                currency: ['USD', 'EUR'],
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense category:services,consulting currency:USD,EUR');
        });

        test('has empty category values', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                category: ['equipment', 'consulting', 'none,Uncategorized'],
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense category:equipment,consulting,none,Uncategorized');
        });

        test('empty filter values', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {};

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc');
        });

        test('array of from', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                from: ['user1@gmail.com', 'user2@gmail.com'],
                to: ['user3@gmail.com'],
            };
            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense from:user1@gmail.com,user2@gmail.com to:user3@gmail.com');
        });

        test('complex filter values', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                from: ['user1@gmail.com', 'user2@gmail.com'],
                to: ['user3@gmail.com'],
                dateAfter: '2025-03-01',
                dateBefore: '2025-03-10',
                amountLessThan: '1000',
                amountGreaterThan: '1',
                category: ['finance', 'insurance'],
            };
            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual(
                'sortBy:date sortOrder:desc type:expense from:user1@gmail.com,user2@gmail.com to:user3@gmail.com category:finance,insurance date>2025-03-01 date<2025-03-10 amount>1 amount<1000',
            );
            expect(result).not.toMatch(CONST.VALIDATE_FOR_HTML_TAG_REGEX);
        });

        test('total filter values', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                totalLessThan: '1000',
                totalGreaterThan: '1',
            };
            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense total>1 total<1000');
        });

        test('equal to filter values', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                amountEqualTo: '500',
                totalEqualTo: '750',
            };
            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense amount:500 total:750');
        });

        test('combined equal to and range filter values', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                amountEqualTo: '100',
                totalGreaterThan: '50',
                totalLessThan: '200',
            };
            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense amount:100 total>50 total<200');
        });

        test('with withdrawal type filter', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                withdrawalType: CONST.SEARCH.WITHDRAWAL_TYPE.EXPENSIFY_CARD,
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense withdrawalType:expensify-card');
        });

        test('with withdrawn filter', () => {
            const filterValues: Partial<SearchAdvancedFiltersForm> = {
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                withdrawnOn: CONST.SEARCH.DATE_PRESETS.LAST_MONTH,
            };

            const result = buildQueryStringFromFilterFormValues(filterValues);

            expect(result).toEqual('sortBy:date sortOrder:desc type:expense withdrawn:last-month');
        });

        describe('limit option', () => {
            test('includes limit in query string when provided', () => {
                const filterValues: Partial<SearchAdvancedFiltersForm> = {
                    type: 'expense',
                };

                const result = buildQueryStringFromFilterFormValues(filterValues, {limit: 10});

                expect(result).toEqual('sortBy:date sortOrder:desc type:expense limit:10');
            });

            test('combines limit with sort options', () => {
                const filterValues: Partial<SearchAdvancedFiltersForm> = {
                    type: 'expense',
                    merchant: 'Amazon',
                };

                const result = buildQueryStringFromFilterFormValues(filterValues, {sortBy: 'amount', sortOrder: 'asc', limit: 25});

                expect(result).toEqual('sortBy:amount sortOrder:asc type:expense merchant:Amazon limit:25');
            });

            test('omits limit when not provided', () => {
                const filterValues: Partial<SearchAdvancedFiltersForm> = {
                    type: 'expense',
                };

                const result = buildQueryStringFromFilterFormValues(filterValues);

                expect(result).not.toContain('limit:');
            });

            test('omits limit when form value is empty string (user cleared the field)', () => {
                const filterValues: Partial<SearchAdvancedFiltersForm> = {
                    type: 'expense',
                    limit: '',
                };

                const result = buildQueryStringFromFilterFormValues(filterValues, {limit: 10});

                expect(result).not.toContain('limit:');
            });
        });
    });

    describe('buildUserReadableQueryString', () => {
        const emptyReports: OnyxCollection<OnyxTypes.Report> = {};
        const emptyCardList: OnyxTypes.CardList = {};
        const emptyCardFeeds: OnyxCollection<OnyxTypes.CardFeeds> = {};
        const emptyPolicies: OnyxCollection<OnyxTypes.Policy> = {};
        const emptyTaxRates: Record<string, string[]> = {};
        const currentUserAccountID = 0;

        test('preserves manual filter order for raw queries', () => {
            const queryString = 'type:expense date:this-month groupBy:from tag:travel';
            const canonicalQueryString = getQueryWithUpdatedValues(queryString);

            if (!canonicalQueryString) {
                throw new Error('Failed to standardize query string');
            }

            const queryJSON = buildSearchQueryJSON(canonicalQueryString, queryString);

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildUserReadableQueryString(queryJSON, undefined, emptyReports, emptyTaxRates, emptyCardList, emptyCardFeeds, emptyPolicies, currentUserAccountID);

            expect(result).toBe('type:expense date:this-month group-by:from tag:travel');
        });

        test('preserves status all default value from manual query', () => {
            const queryString = 'type:expense status:all merchant:Uber';
            const canonicalQueryString = getQueryWithUpdatedValues(queryString);

            if (!canonicalQueryString) {
                throw new Error('Failed to standardize query string');
            }

            const queryJSON = buildSearchQueryJSON(canonicalQueryString, queryString);

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildUserReadableQueryString(queryJSON, undefined, emptyReports, emptyTaxRates, emptyCardList, emptyCardFeeds, emptyPolicies, currentUserAccountID);

            expect(result).toBe('type:expense status:all merchant:Uber');
        });

        test('maps workspace names and maintains manual order', () => {
            const queryString = 'policyID:123 type:expense merchant:Starbucks';
            const canonicalQueryString = getQueryWithUpdatedValues(queryString);

            if (!canonicalQueryString) {
                throw new Error('Failed to standardize query string');
            }

            const queryJSON = buildSearchQueryJSON(canonicalQueryString, queryString);
            const policies: OnyxCollection<OnyxTypes.Policy> = {
                [`${ONYXKEYS.COLLECTION.POLICY}123`]: {
                    name: 'Team Space',
                } as OnyxTypes.Policy,
            };

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildUserReadableQueryString(queryJSON, undefined, emptyReports, emptyTaxRates, emptyCardList, emptyCardFeeds, policies, currentUserAccountID);

            expect(result).toBe('workspace:"Team Space" type:expense merchant:Starbucks');
        });

        test('rawQuery overrides canonical filter values when provided', () => {
            const queryString = 'type:expense merchant:Uber';
            const canonicalQueryString = getQueryWithUpdatedValues(queryString);

            if (!canonicalQueryString) {
                throw new Error('Failed to standardize query string');
            }

            const overriddenRawQuery = 'type:expense merchant:Lyft';
            const queryJSON = buildSearchQueryJSON(canonicalQueryString, overriddenRawQuery);
            const merchantFilter = queryJSON?.rawFilterList?.find((filter) => filter.key === CONST.SEARCH.SYNTAX_FILTER_KEYS.MERCHANT);

            expect(merchantFilter?.value).toBe('Lyft');
        });

        test('includes limit in readable query string when present', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:25');

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildUserReadableQueryString(queryJSON, undefined, emptyReports, emptyTaxRates, emptyCardList, emptyCardFeeds, emptyPolicies, currentUserAccountID);

            expect(result).toContain('limit:25');
        });

        test('does not include limit in readable query string when not specified', () => {
            const queryJSON = buildSearchQueryJSON('type:expense merchant:Test');

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildUserReadableQueryString(queryJSON, undefined, emptyReports, emptyTaxRates, emptyCardList, emptyCardFeeds, emptyPolicies, currentUserAccountID);

            expect(result).not.toContain('limit:');
        });

        test('includes limit with other root parameters in readable query string', () => {
            const queryJSON = buildSearchQueryJSON('type:expense groupBy:category limit:50');

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildUserReadableQueryString(queryJSON, undefined, emptyReports, emptyTaxRates, emptyCardList, emptyCardFeeds, emptyPolicies, currentUserAccountID);

            expect(result).toContain('limit:50');
            expect(result).toContain('group-by:category');
        });
    });

    describe('buildFilterFormValuesFromQuery', () => {
        test('category filter includes empty values', () => {
            const policyID = generatePolicyID();
            const queryString = 'sortBy:date sortOrder:desc type:expense category:none,Uncategorized,Maintenance';
            const queryJSON = buildSearchQueryJSON(queryString);

            const policyCategories = {
                [`${ONYXKEYS.COLLECTION.POLICY_CATEGORIES}${policyID}`]: {
                    Maintenance: {
                        enabled: true,
                        name: 'Maintenance',
                    },
                    Travel: {
                        enabled: true,
                        name: 'Travel',
                    },
                    Meals: {
                        enabled: true,
                        name: 'Meals',
                    },
                },
            };
            const policyTags = {};
            const currencyList = {};
            const personalDetails = {};
            const cardList = {};
            const reports = {};
            const taxRates = {};

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildFilterFormValuesFromQuery(queryJSON, policyCategories, policyTags, currencyList, personalDetails, cardList, reports, taxRates);

            expect(result).toEqual({
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                category: ['Maintenance', 'none'],
            });
        });

        test('action filter should be set to undefined if the input value is invalid', () => {
            const policyCategories = {};
            const policyTags = {};
            const currencyList = {};
            const personalDetails = {};
            const cardList = {};
            const reports = {};
            const taxRates = {};

            let queryString = 'sortBy:date sortOrder:desc type:expense action:submit';
            let queryJSON = buildSearchQueryJSON(queryString);

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            let result = buildFilterFormValuesFromQuery(queryJSON, policyCategories, policyTags, currencyList, personalDetails, cardList, reports, taxRates);

            expect(result).toEqual({
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                action: 'submit',
            });

            // invalid action value
            queryString = 'sortBy:date sortOrder:desc type:expense action:INVALID,submit';
            queryJSON = buildSearchQueryJSON(queryString);

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            result = buildFilterFormValuesFromQuery(queryJSON, policyCategories, policyTags, currencyList, personalDetails, cardList, reports, taxRates);

            expect(result).toEqual({
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                action: undefined,
            });
        });

        test('parses negative backend amounts into filter form values', () => {
            const policyCategories = {};
            const policyTags = {};
            const currencyList = {};
            const personalDetails = {};
            const cardList = {};
            const reports = {};
            const taxRates = {};

            const queryString = 'sortBy:date sortOrder:desc type:expense amount<-12345 amount>-67890 amount:-54321';
            const queryJSON = buildSearchQueryJSON(queryString);

            if (!queryJSON) {
                throw new Error('Failed to parse query string');
            }

            const result = buildFilterFormValuesFromQuery(queryJSON, policyCategories, policyTags, currencyList, personalDetails, cardList, reports, taxRates);

            expect(result).toEqual({
                type: 'expense',
                status: CONST.SEARCH.STATUS.EXPENSE.ALL,
                amountLessThan: '-12345',
                amountGreaterThan: '-67890',
                amountEqualTo: '-54321',
            });
        });
    });

    describe('shouldHighlight', () => {
        it('returns false if either input is empty', () => {
            expect(shouldHighlight('', 'test')).toBe(false);
            expect(shouldHighlight('Some text', '')).toBe(false);
        });

        it('matches exact word at beginning', () => {
            expect(shouldHighlight('Take a 2-minute tour', 'Take')).toBe(true);
        });

        it('matches word with accent', () => {
            expect(shouldHighlight('f200é', 'f200e')).toBe(true);
        });

        it('matches exact word in middle', () => {
            expect(shouldHighlight('Take a 2-minute tour', '2-minute')).toBe(true);
        });

        it('matches phrase with leading space', () => {
            expect(shouldHighlight('Take a 2-minute tour', ' 2-minute tour')).toBe(true);
        });

        it('matches with special characters', () => {
            // cspell:disable-next-line
            expect(shouldHighlight('Explore the #%tự đặc biệt!', '#%tự')).toBe(true);
        });

        it('is case-insensitive', () => {
            expect(shouldHighlight('Take a 2-minute tour', 'TOUR')).toBe(true);
        });

        it('does not match partial word in the middle', () => {
            expect(shouldHighlight('Take a 2-minute tour', 'in')).toBe(false);
        });

        it('does not match incomplete trailing text', () => {
            expect(shouldHighlight('Take a 2-minute tour', '2-minute to')).toBe(false);
        });

        it('matches multi-word phrase exactly', () => {
            expect(shouldHighlight('Take a 2-minute tour', '2-minute tour')).toBe(true);
        });

        it('does not match words out of order', () => {
            expect(shouldHighlight('Take a 2-minute tour', 'tour 2-minute')).toBe(false);
        });
    });

    describe('sortOptionsWithEmptyValue', () => {
        it('should prioritize empty values at the start', () => {
            const options = ['B', 'A', CONST.SEARCH.CATEGORY_EMPTY_VALUE, 'C'];
            const sortedOptions = options.sort((a, b) => sortOptionsWithEmptyValue(a, b, localeCompare));

            expect(sortedOptions).toEqual([CONST.SEARCH.CATEGORY_EMPTY_VALUE, 'A', 'B', 'C']);
        });

        it('should sort non-empty values properly', () => {
            const options = ['B', 'A', 'C'];
            const sortedOptions = options.sort((a, b) => sortOptionsWithEmptyValue(a, b, localeCompare));

            expect(sortedOptions).toEqual(['A', 'B', 'C']);
        });
    });

    describe('similarSearchHash', () => {
        it('should return same similarSearchHash for two queries that are the same but use different sorting', () => {
            const queryJSONa = buildSearchQueryJSON('sortBy:date sortOrder:desc type:expense category:none,Uncategorized,Maintenance');
            const queryJSONb = buildSearchQueryJSON('sortBy:date sortOrder:asc type:expense category:none,Uncategorized,Maintenance');

            expect(queryJSONa?.similarSearchHash).toEqual(queryJSONb?.similarSearchHash);
        });

        it('should return same similarSearchHash for two queries that have same filters but different values', () => {
            const queryJSONa = buildSearchQueryJSON('sortBy:date sortOrder:desc type:expense feed:"oauth.americanexpressfdx.com 1001" posted:last-statement');
            const queryJSONb = buildSearchQueryJSON('sortBy:date sortOrder:desc type:expense feed:"1234_stripe" posted:last-month');

            expect(queryJSONa?.similarSearchHash).toEqual(queryJSONb?.similarSearchHash);
        });

        it('should return same similarSearchHash for queries with a date range', () => {
            const queryJSONa = buildSearchQueryJSON('type:expense withdrawal-type:reimbursement withdrawn:last-month');
            const queryJSONb = buildSearchQueryJSON('type:expense withdrawal-type:reimbursement withdrawn>2025-01-01 withdrawn<2025-01-03');

            expect(queryJSONa?.similarSearchHash).toEqual(queryJSONb?.similarSearchHash);
        });

        it('should return different similarSearchHash for two queries that have different types', () => {
            const queryJSONa = buildSearchQueryJSON('sortBy:date sortOrder:desc type:expense feed:"oauth.americanexpressfdx.com 1001"');
            const queryJSONb = buildSearchQueryJSON('sortBy:date sortOrder:desc type:trip feed:"oauth.americanexpressfdx.com 1001"');

            expect(queryJSONa?.similarSearchHash).not.toEqual(queryJSONb?.similarSearchHash);
        });

        describe('limit filter hashing', () => {
            it('should return same similarSearchHash for queries with different limit values', () => {
                const queryJSONa = buildSearchQueryJSON('type:expense limit:10');
                const queryJSONb = buildSearchQueryJSON('type:expense limit:50');

                expect(queryJSONa?.similarSearchHash).toEqual(queryJSONb?.similarSearchHash);
            });

            it('should return different primaryHash for queries with different limit values', () => {
                const queryJSONa = buildSearchQueryJSON('type:expense limit:10');
                const queryJSONb = buildSearchQueryJSON('type:expense limit:50');

                expect(queryJSONa?.hash).not.toEqual(queryJSONb?.hash);
            });

            it('should return same primaryHash for queries without limit (hash stability)', () => {
                const queryJSONa = buildSearchQueryJSON('type:expense');
                const queryJSONb = buildSearchQueryJSON('type:expense');

                expect(queryJSONa?.hash).toEqual(queryJSONb?.hash);
            });

            it('should return different primaryHash for query with valid limit vs without limit', () => {
                const withoutLimit = buildSearchQueryJSON('type:expense');
                const withLimit = buildSearchQueryJSON('type:expense limit:10');

                expect(withoutLimit?.hash).not.toEqual(withLimit?.hash);
            });

            it('should return same primaryHash for same limit value queried twice', () => {
                const queryJSONa = buildSearchQueryJSON('type:expense limit:25');
                const queryJSONb = buildSearchQueryJSON('type:expense limit:25');

                expect(queryJSONa?.hash).toEqual(queryJSONb?.hash);
            });

            it('should not include limit in hash when limit is not in query string', () => {
                const queryJSON = buildSearchQueryJSON('type:expense merchant:test');

                expect(queryJSON?.limit).toBeUndefined();
                expect(queryJSON?.hash).toBeDefined();
            });

            it('should return same primaryHash for invalid limit as no limit (normalization before hashing)', () => {
                const withoutLimit = buildSearchQueryJSON('type:expense');
                const withZeroLimit = buildSearchQueryJSON('type:expense limit:0');
                const withNegativeLimit = buildSearchQueryJSON('type:expense limit:-5');
                const withDecimalLimit = buildSearchQueryJSON('type:expense limit:10.5');

                // All invalid limits should normalize to undefined and produce same hash as no limit
                expect(withZeroLimit?.hash).toEqual(withoutLimit?.hash);
                expect(withNegativeLimit?.hash).toEqual(withoutLimit?.hash);
                expect(withDecimalLimit?.hash).toEqual(withoutLimit?.hash);
            });
        });
    });

    describe('limit filter parsing', () => {
        it('parses limit value as a number', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:25');

            expect(queryJSON?.limit).toBe(25);
            expect(typeof queryJSON?.limit).toBe('number');
        });

        it('preserves limit when combined with other filters', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:100 merchant:Amazon');

            expect(queryJSON?.limit).toBe(100);
            expect(queryJSON?.type).toBe('expense');
        });

        it('returns undefined limit when not specified in query', () => {
            const queryJSON = buildSearchQueryJSON('type:expense merchant:Amazon');

            expect(queryJSON?.limit).toBeUndefined();
        });

        it('handles large limit values', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:9999');

            expect(queryJSON?.limit).toBe(9999);
        });

        it('converts limit:0 to undefined', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:0');

            expect(queryJSON?.limit).toBeUndefined();
        });

        it('converts negative limit to undefined', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:-10');

            expect(queryJSON?.limit).toBeUndefined();
        });

        it('converts decimal limit to undefined', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:10.5');

            expect(queryJSON?.limit).toBeUndefined();
        });

        it('converts non-numeric limit to undefined', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:abc');

            expect(queryJSON?.limit).toBeUndefined();
        });

        it('converts comma-separated limit to undefined', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:10,20');

            expect(queryJSON?.limit).toBeUndefined();
        });

        it('uses last limit value when multiple limits specified', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:10 limit:20');

            expect(queryJSON?.limit).toBe(20);
        });

        it('treats empty limit as keyword, not limit filter', () => {
            const queryJSON = buildSearchQueryJSON('type:expense limit:');

            expect(queryJSON?.limit).toBeUndefined();
            const keywordFilter = queryJSON?.flatFilters.find((filter) => filter.key === 'keyword');
            expect(keywordFilter?.filters.some((f) => f.value === 'limit:')).toBe(true);
        });

        it('treats negated limit as keyword since limit is non-negatable', () => {
            const queryJSON = buildSearchQueryJSON('type:expense -limit:10');

            expect(queryJSON?.limit).toBeUndefined();
            const keywordFilter = queryJSON?.flatFilters.find((filter) => filter.key === 'keyword');
            expect(keywordFilter?.filters.some((f) => f.value === '-limit:10')).toBe(true);
        });
    });

    describe('getFilterDisplayValue', () => {
        const mockCardList = {};
        const mockCardFeeds = {};
        const mockPolicies = {};
        const mockReports = {};
        const currentUserAccountID = 12345;

        it('should return clean phone number without @expensify.sms for SMS login users', () => {
            const personalDetails = {
                '99999': {
                    accountID: 99999,
                    login: '+15551234567@expensify.sms',
                    displayName: '+15551234567@expensify.sms',
                },
            };

            const result = getFilterDisplayValue(
                CONST.SEARCH.SYNTAX_FILTER_KEYS.FROM,
                '99999',
                personalDetails,
                mockReports,
                mockCardList,
                mockCardFeeds,
                mockPolicies,
                currentUserAccountID,
            );

            expect(result).toBe('+15551234567');
            expect(result).not.toContain('@expensify.sms');
        });

        it('should return display name for regular email users', () => {
            const personalDetails = {
                '78901': {
                    accountID: 78901,
                    login: 'janedoe@example.com',
                    displayName: 'Jane Doe',
                },
            };

            const result = getFilterDisplayValue(
                CONST.SEARCH.SYNTAX_FILTER_KEYS.FROM,
                '78901',
                personalDetails,
                mockReports,
                mockCardList,
                mockCardFeeds,
                mockPolicies,
                currentUserAccountID,
            );

            expect(result).toBe('Jane Doe');
        });

        it('should return "Me" for current user account ID', () => {
            const personalDetails = {
                '12345': {
                    accountID: 12345,
                    login: 'currentuser@example.com',
                    displayName: 'Current User',
                },
            };

            const result = getFilterDisplayValue(
                CONST.SEARCH.SYNTAX_FILTER_KEYS.FROM,
                '12345',
                personalDetails,
                mockReports,
                mockCardList,
                mockCardFeeds,
                mockPolicies,
                currentUserAccountID,
            );

            expect(result).toBe(CONST.SEARCH.ME);
        });

        it('should return fallback value when personal details not found', () => {
            const personalDetails = {};

            const result = getFilterDisplayValue(
                CONST.SEARCH.SYNTAX_FILTER_KEYS.FROM,
                '88888',
                personalDetails,
                mockReports,
                mockCardList,
                mockCardFeeds,
                mockPolicies,
                currentUserAccountID,
            );

            expect(result).toBe('88888');
        });

        it('should handle SMS login with custom display name', () => {
            const personalDetails = {
                '77777': {
                    accountID: 77777,
                    login: '+15559876543@expensify.sms',
                    displayName: 'Custom Name',
                },
            };

            const result = getFilterDisplayValue(
                CONST.SEARCH.SYNTAX_FILTER_KEYS.FROM,
                '77777',
                personalDetails,
                mockReports,
                mockCardList,
                mockCardFeeds,
                mockPolicies,
                currentUserAccountID,
            );

            expect(result).toBe('Custom Name');
            expect(result).not.toContain('@expensify.sms');
        });

        it('should work with TO filter key', () => {
            const personalDetails = {
                '66666': {
                    accountID: 66666,
                    login: '+15551112222@expensify.sms',
                    displayName: '+15551112222@expensify.sms',
                },
            };

            const result = getFilterDisplayValue(CONST.SEARCH.SYNTAX_FILTER_KEYS.TO, '66666', personalDetails, mockReports, mockCardList, mockCardFeeds, mockPolicies, currentUserAccountID);

            expect(result).toBe('+15551112222');
            expect(result).not.toContain('@expensify.sms');
        });

        it('should work with other user-related filter keys (ASSIGNEE, PAYER, EXPORTER, ATTENDEE)', () => {
            const personalDetails = {
                '55555': {
                    accountID: 55555,
                    login: '+15553334444@expensify.sms',
                    displayName: '+15553334444@expensify.sms',
                },
            };

            const filterKeys = [
                CONST.SEARCH.SYNTAX_FILTER_KEYS.ASSIGNEE,
                CONST.SEARCH.SYNTAX_FILTER_KEYS.PAYER,
                CONST.SEARCH.SYNTAX_FILTER_KEYS.EXPORTER,
                CONST.SEARCH.SYNTAX_FILTER_KEYS.ATTENDEE,
            ];

            for (const filterKey of filterKeys) {
                const result = getFilterDisplayValue(filterKey, '55555', personalDetails, mockReports, mockCardList, mockCardFeeds, mockPolicies, currentUserAccountID);

                expect(result).toBe('+15553334444');
                expect(result).not.toContain('@expensify.sms');
            }
        });
    });

    describe('buildSearchQueryString', () => {
        test('includes view when explicitly set in rawFilterList', () => {
            const queryJSON = buildSearchQueryJSON('type:expense view:line', 'type:expense view:line');

            const result = buildSearchQueryString(queryJSON);

            expect(result).toContain('view:line');
        });

        test('includes view when differs from default even without rawFilterList', () => {
            const queryJSON = buildSearchQueryJSON('type:expense view:pie');

            const result = buildSearchQueryString(queryJSON);

            expect(result).toContain('view:pie');
        });

        test('includes view when set to bar', () => {
            const queryJSON = buildSearchQueryJSON('type:expense view:bar');

            const result = buildSearchQueryString(queryJSON);

            expect(result).toContain('view:bar');
        });

        test('skips view when not explicitly set and matches default', () => {
            const queryJSON = buildSearchQueryJSON('type:expense');

            const result = buildSearchQueryString(queryJSON);

            expect(result).not.toContain('view:table');
        });

        test('includes view when explicitly set to table in rawFilterList', () => {
            const queryJSON = buildSearchQueryJSON('type:expense view:table', 'type:expense view:table');

            const result = buildSearchQueryString(queryJSON);

            expect(result).toContain('view:table');
        });

        test('preserves view along with other filters', () => {
            const queryJSON = buildSearchQueryJSON('type:expense view:line category:travel');

            const result = buildSearchQueryString(queryJSON);

            expect(result).toContain('view:line');
            expect(result).toContain('category:travel');
        });

        test('handles view with rawFilterList containing other filters', () => {
            const queryJSON = buildSearchQueryJSON('type:expense view:pie merchant:Amazon', 'type:expense view:pie merchant:Amazon');

            const result = buildSearchQueryString(queryJSON);

            expect(result).toContain('view:pie');
            expect(result).toContain('merchant:Amazon');
        });
    });
});
