# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

require 'ostruct'

skip_docs
opt_out_usage

KEY_GRADLE_APK_PATH = "gradleAPKOutputPath"
KEY_GRADLE_AAB_PATH = "gradleAABOutputPath"
KEY_IPA_PATH = "ipaPath"
KEY_DSYM_PATH = "dsymPath"

# Export environment variables in the parent shell.
# In a GitHub Actions environment, it will save the environment variables in the GITHUB_ENV file.
# In any other environment, it will save them to the current shell environment using the `export` command.
def exportEnvVars(env_vars)
  github_env_path = ENV['GITHUB_ENV']
  if github_env_path && File.exist?(github_env_path)
    puts "Saving environment variables in GITHUB_ENV..."
    File.open(github_env_path, "a") do |file|
      env_vars.each do |key, value|
        puts "#{key}=#{value}"
        file.puts "#{key}=#{value}"
      end
    end
  else
    puts "Saving environment variables in parent shell..."
    env_vars.each do |key, value|
      puts "#{key}=#{value}"
      command = "export #{key}=#{value}"
      system(command)
    end
  end
end

def setGradleOutputsInEnv()
  puts "Saving Android build outputs in env..."
  env_vars = {
    KEY_GRADLE_APK_PATH => lane_context[SharedValues::GRADLE_APK_OUTPUT_PATH],
  }
  if lane_context.key?(SharedValues::GRADLE_AAB_OUTPUT_PATH)
    env_vars[KEY_GRADLE_AAB_PATH] = lane_context[SharedValues::GRADLE_AAB_OUTPUT_PATH]
  end
  exportEnvVars(env_vars)
end

def setIOSBuildOutputsInEnv()
  puts "Saving iOS build outputs in env..."
  exportEnvVars({
    KEY_IPA_PATH => lane_context[SharedValues::IPA_OUTPUT_PATH],
    KEY_DSYM_PATH => lane_context[SharedValues::DSYM_OUTPUT_PATH],
  })
end

platform :android do
  desc "Generate a production AAB"
  lane :build do
    ENV["ENVFILE"]=".env.production"
    gradle(
      project_dir: './android',
      task: 'bundle',
      flavor: 'Production',
      build_type: 'Release',
    )
    setGradleOutputsInEnv()
  end

  desc "Generate a production HybridApp AAB"
    lane :build_hybrid do
      ENV["ENVFILE"]="../.env.production.hybridapp"
      gradle(
        project_dir: '../Android',
        task: "bundleRelease",
        flags: "--refresh-dependencies",
        properties: {
            "android.injected.signing.store.file" => './upload-key.keystore',
            "android.injected.signing.store.password" => ENV["ANDROID_UPLOAD_KEYSTORE_PASSWORD"],
            "android.injected.signing.key.alias" => ENV["ANDROID_UPLOAD_KEYSTORE_ALIAS"],
            "android.injected.signing.key.password" => ENV["ANDROID_UPLOAD_KEY_PASSWORD"],
        }
      )
      setGradleOutputsInEnv()
    end

  desc "Generate a new local APK"
  lane :build_local do
    ENV["ENVFILE"]=".env.production"
    gradle(
      project_dir: './android',
      task: 'assemble',
      flavor: 'Production',
      build_type: 'Release',
    )
    setGradleOutputsInEnv()
  end

  desc "Generate a new local HybridApp APK"
    lane :build_local_hybrid do
      ENV["ENVFILE"]=".env.production"
      gradle(
        project_dir: '../Android',
        task: 'assemble',
        flavor: 'Production',
        build_type: 'Release',
      )
      setGradleOutputsInEnv()
    end

  desc "Generate a new local APK for e2e testing"
  lane :build_e2e do
    ENV["ENVFILE"]="tests/e2e/.env.e2e"
    ENV["ENTRY_FILE"]="src/libs/E2E/reactNativeLaunchingTest.ts"
    ENV["E2E_TESTING"]="true"

    gradle(
      project_dir: './android',
      task: ':app:assemble',
      flavor: 'e2e',
      build_type: 'Release',
    )
    setGradleOutputsInEnv()
  end

  lane :build_e2edelta do
    ENV["ENVFILE"]="tests/e2e/.env.e2edelta"
    ENV["ENTRY_FILE"]="src/libs/E2E/reactNativeLaunchingTest.ts"
    ENV["E2E_TESTING"]="true"

    gradle(
      project_dir: './android',
      task: ':app:assemble',
      flavor: 'e2edelta',
      build_type: 'Release',
    )
    setGradleOutputsInEnv()
  end

  desc "Build AdHoc testing build"
  lane :build_adhoc do
    ENV["ENVFILE"]=".env.adhoc"
    gradle(
      project_dir: './android',
      task: 'assemble',
      flavor: 'Adhoc',
      build_type: 'Release',
    )
    setGradleOutputsInEnv()
  end

  desc "Upload build to S3"
  lane :upload_s3 do
    puts "APK path: #{ENV[KEY_GRADLE_APK_PATH]}"
    aws_s3(
      access_key: ENV['S3_ACCESS_KEY'],
      secret_access_key: ENV['S3_SECRET_ACCESS_KEY'],
      bucket: ENV['S3_BUCKET'],
      region: ENV['S3_REGION'],
      apk: ENV[KEY_GRADLE_APK_PATH],
      app_directory: "android/#{ENV['PULL_REQUEST_NUMBER']}",
    )
    sh("echo '{\"apk_path\": \"#{lane_context[SharedValues::S3_APK_OUTPUT_PATH]}\",\"html_path\": \"#{lane_context[SharedValues::S3_HTML_OUTPUT_PATH]}\"}' > ../android_paths.json")
  end

  desc "Upload app to Google Play for internal testing"
  lane :upload_google_play_internal do
    # Google is very unreliable, so we retry a few times
    ENV["SUPPLY_UPLOAD_MAX_RETRIES"]="5"
    upload_to_play_store(
      package_name: "com.expensify.chat",
      json_key: './android/app/android-fastlane-json-key.json',
      aab: ENV[KEY_GRADLE_AAB_PATH],
      track: 'internal',
      rollout: '1.0'
    )
  end

  desc "Deploy app to Google Play production"
  lane :upload_google_play_production do
    # Google is very unreliable, so we retry a few times
    ENV["SUPPLY_UPLOAD_MAX_RETRIES"]="5"
    google_play_track_version_codes(
      package_name: "com.expensify.chat",
      json_key: './android/app/android-fastlane-json-key.json',
      track: 'internal'
    )
    upload_to_play_store(
      package_name: "com.expensify.chat",
      json_key: './android/app/android-fastlane-json-key.json',
      version_code: ENV["VERSION"].to_i,
      track: 'internal',
      track_promote_to: 'production',
      rollout: '1.0',
      skip_upload_apk: true,
      skip_upload_aab: true,
      skip_upload_metadata: true,
      skip_upload_changelogs: true,
      skip_upload_images: true,
      skip_upload_screenshots: true
    )
  end
end

def setupIOSSigningCertificate()
  require 'securerandom'
  keychain_password = SecureRandom.uuid

  create_keychain(
    name: "ios-build.keychain",
    password: keychain_password,
    default_keychain: "true",
    unlock: "true",
    timeout: "3600",
    add_to_search_list: "true"
  )

  import_certificate(
    certificate_path: "./ios/Certificates.p12",
    keychain_name: "ios-build.keychain",
    keychain_password: keychain_password
  )
end

platform :ios do
  desc "Build an iOS production build"
  lane :build do
    ENV["ENVFILE"]=".env.production"

    setupIOSSigningCertificate()

    install_provisioning_profile(
      path: "./ios/NewApp_AppStore.mobileprovision"
    )

    install_provisioning_profile(
      path: "./ios/NewApp_AppStore_Notification_Service.mobileprovision"
    )

    build_app(
      workspace: "./ios/NewExpensify.xcworkspace",
      scheme: "New Expensify",
      output_name: "New Expensify.ipa",
      export_options: {
        provisioningProfiles: {
          "com.chat.expensify.chat" => "(NewApp) AppStore",
          "com.chat.expensify.chat.NotificationServiceExtension" => "(NewApp) AppStore: Notification Service",
        },
        manageAppVersionAndBuildNumber: false
      }
    )

    setIOSBuildOutputsInEnv()
  end

  desc "Build an iOS HybridApp production build"
    lane :build_hybrid do
      ENV["ENVFILE"]="../.env.production.hybridapp"

      setupIOSSigningCertificate()

      install_provisioning_profile(
        path: "./OldApp_AppStore.mobileprovision"
      )

      install_provisioning_profile(
        path: "./OldApp_AppStore_Share_Extension.mobileprovision"
      )

      build_app(
        workspace: "../iOS/Expensify.xcworkspace",
        scheme: "Expensify",
        output_name: "Expensify.ipa",
        export_method: "app-store",
        export_options: {
          manageAppVersionAndBuildNumber: false,
          provisioningProfiles: {
              "com.expensify.expensifylite" => "(OldApp) AppStore",
              "com.expensify.expensifylite.SmartScanExtension" => "(OldApp) AppStore: Share Extension"
          }
        }
      )

      setIOSBuildOutputsInEnv()
    end

  desc "Build an unsigned iOS production build"
  lane :build_unsigned do
    ENV["ENVFILE"]=".env.production"
    build_app(
        workspace: "./ios/NewExpensify.xcworkspace",
        scheme: "New Expensify"
    )
    setIOSBuildOutputsInEnv()
  end

  desc "Build an unsigned iOS HybridApp production build"
    lane :build_unsigned_hybrid do
      ENV["ENVFILE"]="../Mobile-Expensify/.env.production.hybridapp"
      build_app(
          workspace: "../Mobile-Expensify/iOS/Expensify.xcworkspace",
          scheme: "Expensify"
      )
      setIOSBuildOutputsInEnv()
    end

  desc "Build AdHoc app for testing"
  lane :build_adhoc do
    ENV["ENVFILE"]=".env.adhoc"

    setupIOSSigningCertificate()

    install_provisioning_profile(
      path: "./ios/NewApp_AdHoc.mobileprovision"
    )

    install_provisioning_profile(
      path: "./ios/NewApp_AdHoc_Notification_Service.mobileprovision"
    )

    build_app(
      workspace: "./ios/NewExpensify.xcworkspace",
      skip_profile_detection: true,
      scheme: "New Expensify AdHoc",
      export_method: "ad-hoc",
      export_options: {
        method: "ad-hoc",
        provisioningProfiles: {
          "com.expensify.chat.adhoc" => "(NewApp) AdHoc",
          "com.expensify.chat.adhoc.NotificationServiceExtension" => "(NewApp) AdHoc: Notification Service",
        },
        manageAppVersionAndBuildNumber: false
      }
    )
    setIOSBuildOutputsInEnv()
  end

  desc "Upload app to S3"
  lane :upload_s3 do
    puts "IPA path: #{ENV[KEY_IPA_PATH]}"
    aws_s3(
      access_key: ENV['S3_ACCESS_KEY'],
      secret_access_key: ENV['S3_SECRET_ACCESS_KEY'],
      bucket: ENV['S3_BUCKET'],
      region: ENV['S3_REGION'],
      ipa: ENV[KEY_IPA_PATH],
      app_directory: "ios/#{ENV['PULL_REQUEST_NUMBER']}",
    )
    sh("echo '{\"ipa_path\": \"#{lane_context[SharedValues::S3_IPA_OUTPUT_PATH]}\",\"html_path\": \"#{lane_context[SharedValues::S3_HTML_OUTPUT_PATH]}\"}' > ../ios_paths.json")
  end

  desc "Upload app to TestFlight"
  lane :upload_testflight do
    upload_to_testflight(
      api_key_path: "./ios/ios-fastlane-json-key.json",
      distribute_external: true,
      notify_external_testers: true,
      changelog: "Thank you for beta testing New Expensify, this version includes bug fixes and improvements.",
      groups: ["Beta"],
      demo_account_required: true,
      beta_app_review_info: {
        contact_email: ENV["APPLE_CONTACT_EMAIL"],
        contact_first_name: "Andrew",
        contact_last_name: "Gable",
        contact_phone: ENV["APPLE_CONTACT_PHONE"],
        demo_account_name: ENV["APPLE_DEMO_EMAIL"],
        demo_account_password: ENV["APPLE_DEMO_PASSWORD"],
        notes: "1. In the Expensify app, enter the email 'appletest.expensify@proton.me'. This will trigger a sign-in link to be sent to 'appletest.expensify@proton.me'
                2. Navigate to https://account.proton.me/login, log into Proton Mail using 'appletest.expensify@proton.me' as email and the password associated with 'appletest.expensify@proton.me', provided above
                3. Once logged into Proton Mail, navigate to your inbox and locate the email triggered in step 1. The email subject should be 'Your magic sign-in link for Expensify'
                4. Open the email and copy the 6-digit sign-in code provided within
                5. Return to the Expensify app and enter the copied 6-digit code in the designated login field"
      }
    )

    puts "dsym path: #{ENV[KEY_DSYM_PATH]}"
    upload_symbols_to_crashlytics(
      app_id: "1:921154746561:ios:216bd10ccc947659027c40",
      dsym_path: ENV[KEY_DSYM_PATH],
      gsp_path: "./ios/GoogleService-Info.plist",
      binary_path: "./ios/Pods/FirebaseCrashlytics/upload-symbols"
    )
  end

  desc "Submit app to App Store Review"
  lane :submit_for_review do
    deliver(
      api_key_path: "./ios/ios-fastlane-json-key.json",

      # Skip HTMl report verification
      force: true,

      # VERSION will be set to the full build_number e.g. '1.0.92.0'
      build_number: ENV["VERSION"],

      # app_version needs to be set to the short version, without the last digit e.g. '1.0.92'
      app_version: ENV["VERSION"].rpartition(".")[0],

      # We want to submit the version for Apple to review
      submit_for_review: true,

      # We want to release the app as soon as it's approved
      automatic_release: true,

      # We need to upload metadata to upload the release notes which is required for rach new version
      skip_metadata: false,

      # We do not want to upload any screenshots
      skip_screenshots: true,

      # We do not have any binary to upload as it's already in TestFlight
      skip_binary_upload: true,

      # Reject the current build if there is one in review
      reject_if_possible: true,

      # We do not want to reset the ratings
      reset_ratings: false,

      # Precheck cannot check for in app purchases with the API key we use
      precheck_include_in_app_purchases: false,
      submission_information: {
        # We currently do not use idfa: https://developer.apple.com/app-store/user-privacy-and-data-use/
        add_id_info_uses_idfa: false,

        # We do not need any additional compliance
        export_compliance_compliance_required: false,

        # We do not use any encrpytion
        export_compliance_encryption_updated: false,
        export_compliance_app_type: nil,
        export_compliance_uses_encryption: false,
        export_compliance_is_exempt: false,
        export_compliance_contains_third_party_cryptography: false,
        export_compliance_contains_proprietary_cryptography: false,

        # We do not show any third party content
        content_rights_contains_third_party_content: false,

        # Indicate that our key has admin permissions
        content_rights_has_rights: true
      },
      release_notes: {
        'en-US' => "Improvements and bug fixes"
      }
    )
  end
end
